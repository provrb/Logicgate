; Listing generated by Microsoft (R) Optimizing Compiler Version 19.40.33811.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	?ConnectSocket@@3P6AH_KPEBUsockaddr@@H@ZEA	; ConnectSocket
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CleanWSA@@3P6AHXZEA				; CleanWSA
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CreateSocket@@3P6A_KHHH@ZEA			; CreateSocket
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?ReceiveFrom@@3P6AH_KPEADHHPEAUsockaddr@@PEAH@ZEA ; ReceiveFrom
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	?Send@@3P6AH_KPEBDHH@ZEA			; Send
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	?CloseSocket@@3P6AH_K@ZEA			; CloseSocket
PUBLIC	?SendTo@@3P6AH_KPEBDHHPEBUsockaddr@@H@ZEA	; SendTo
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
EXTRN	__tlregdtor:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__std_terminate:PROC
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	__std_exception_copy:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__std_exception_destroy:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__CxxFrameHandler4:PROC
;	COMDAT ?ConnectSocket@@3P6AH_KPEBUsockaddr@@H@ZEA
_BSS	SEGMENT
?ConnectSocket@@3P6AH_KPEBUsockaddr@@H@ZEA DQ 01H DUP (?) ; ConnectSocket
_BSS	ENDS
;	COMDAT ?CleanWSA@@3P6AHXZEA
_BSS	SEGMENT
?CleanWSA@@3P6AHXZEA DQ 01H DUP (?)			; CleanWSA
_BSS	ENDS
;	COMDAT ?CreateSocket@@3P6A_KHHH@ZEA
_BSS	SEGMENT
?CreateSocket@@3P6A_KHHH@ZEA DQ 01H DUP (?)		; CreateSocket
_BSS	ENDS
;	COMDAT ?ReceiveFrom@@3P6AH_KPEADHHPEAUsockaddr@@PEAH@ZEA
_BSS	SEGMENT
?ReceiveFrom@@3P6AH_KPEADHHPEAUsockaddr@@PEAH@ZEA DQ 01H DUP (?) ; ReceiveFrom
_BSS	ENDS
;	COMDAT ?Send@@3P6AH_KPEBDHH@ZEA
_BSS	SEGMENT
?Send@@3P6AH_KPEBDHH@ZEA DQ 01H DUP (?)			; Send
_BSS	ENDS
;	COMDAT ?CloseSocket@@3P6AH_K@ZEA
_BSS	SEGMENT
?CloseSocket@@3P6AH_K@ZEA DQ 01H DUP (?)		; CloseSocket
_BSS	ENDS
;	COMDAT ?SendTo@@3P6AH_KPEBDHHPEBUsockaddr@@H@ZEA
_BSS	SEGMENT
?SendTo@@3P6AH_KPEBDHHPEBUsockaddr@@H@ZEA DQ 01H DUP (?) ; SendTo
_BSS	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z	; std::construct_at<unsigned char,unsigned char,0>
PUBLIC	??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z	; std::construct_at<unsigned char,unsigned char &,0>
PUBLIC	??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z	; std::construct_at<unsigned char,0>
PUBLIC	??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
PUBLIC	??$forward@E@std@@YA$$QEAEAEAE@Z		; std::forward<unsigned char>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
PUBLIC	??$forward@AEAE@std@@YAAEAEAEAE@Z		; std::forward<unsigned char &>
PUBLIC	??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z	; std::construct_at<unsigned char,unsigned char const &,0>
PUBLIC	??$addressof@E@std@@YAPEAEAEAE@Z		; std::addressof<unsigned char>
PUBLIC	??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>
PUBLIC	??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
PUBLIC	??$move@AEAE@std@@YA$$QEAEAEAE@Z		; std::move<unsigned char &>
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &,0>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z	; std::construct_at<char,0>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char &>
PUBLIC	??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$to_address@E@std@@YAPEAEQEAE@Z		; std::to_address<unsigned char>
PUBLIC	??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z	; std::move<unsigned char * &>
PUBLIC	??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
PUBLIC	??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z	; std::_Construct_in_place<unsigned char,unsigned char const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>
PUBLIC	??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Unfancy@E@std@@YAPEAEPEAE@Z			; std::_Unfancy<unsigned char>
PUBLIC	??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z	; std::_Get_unwrapped<unsigned char * const &>
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?allocate@?$allocator@E@std@@QEAAPEAE_K@Z	; std::allocator<unsigned char>::allocate
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::__autoclassinit2
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z	; std::_To_address<unsigned char *>
PUBLIC	??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ; std::ranges::_Unwrap_sent<unsigned char *,unsigned char *>
PUBLIC	??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ; std::ranges::_Unwrap_iter<unsigned char *,unsigned char *>
PUBLIC	??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z	; std::forward<unsigned char * const &>
PUBLIC	??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z	; std::forward<unsigned char *>
PUBLIC	??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::forward<std::allocator<unsigned char> >
PUBLIC	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>
PUBLIC	??$forward@AEBE@std@@YAAEBEAEBE@Z		; std::forward<unsigned char const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$forward@AEBD@std@@YAAEBDAEBD@Z		; std::forward<char const &>
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??0?$allocator@E@std@@QEAA@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
PUBLIC	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
PUBLIC	??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z	; std::construct_at<char,char const &,0>
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
PUBLIC	??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char * const &,unsigned char * const &>
PUBLIC	??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >
PUBLIC	??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>
PUBLIC	??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ; std::exchange<unsigned char *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::move<std::allocator<unsigned char> &>
PUBLIC	??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z	; std::_Unfancy_maybe_null<unsigned char>
PUBLIC	??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptInternetData<UDPResponse>
PUBLIC	??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptInternetData<ServerCommand>
PUBLIC	?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?KEY_256_ASSIST_1@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z ; Cipher::Aes<256>::KEY_256_ASSIST_1
PUBLIC	?KEY_256_ASSIST_2@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z ; Cipher::Aes<256>::KEY_256_ASSIST_2
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ; Cipher::Aes<256>::AES_256_Key_Expansion
PUBLIC	?data@?$obfuscator@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ ; ay::obfuscator<13,8022544353138530575,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ ; ay::obfuscated_data<13,8022544353138530575,char>::decrypt
PUBLIC	?data@?$obfuscator@$09$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ ; ay::obfuscator<10,-2048805790205510789,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ ; ay::obfuscated_data<10,-2048805790205510789,char>::decrypt
PUBLIC	?data@?$obfuscator@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<13,6339698204315287977,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<13,6339698204315287977,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,-4509840863236766927,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,-4509840863236766927,char>::decrypt
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::data
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z		; Cipher::Aes<256>::Aes<256>
PUBLIC	??1?$Aes@$0BAA@@Cipher@@QEAA@XZ			; Cipher::Aes<256>::~Aes<256>
PUBLIC	?decrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z	; Cipher::Aes<256>::decrypt_block
PUBLIC	??0?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0GPFFMNJFHLKDFJAP@D@1@@Z ; ay::obfuscated_data<13,8022544353138530575,char>::obfuscated_data<13,8022544353138530575,char>
PUBLIC	??1?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ ; ay::obfuscated_data<13,8022544353138530575,char>::~obfuscated_data<13,8022544353138530575,char>
PUBLIC	??B?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<13,8022544353138530575,char>::operator char *
PUBLIC	??0?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$09$0?BMGONCACNKPGIEIF@D@1@@Z ; ay::obfuscated_data<10,-2048805790205510789,char>::obfuscated_data<10,-2048805790205510789,char>
PUBLIC	??1?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ ; ay::obfuscated_data<10,-2048805790205510789,char>::~obfuscated_data<10,-2048805790205510789,char>
PUBLIC	??B?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<10,-2048805790205510789,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0FHPLCBONHLGFABKJ@D@1@@Z ; ay::obfuscated_data<13,6339698204315287977,char>::obfuscated_data<13,6339698204315287977,char>
PUBLIC	??1?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<13,6339698204315287977,char>::~obfuscated_data<13,6339698204315287977,char>
PUBLIC	??B?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<13,6339698204315287977,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@1@@Z ; ay::obfuscated_data<11,-4509840863236766927,char>::obfuscated_data<11,-4509840863236766927,char>
PUBLIC	??1?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,-4509840863236766927,char>::~obfuscated_data<11,-4509840863236766927,char>
PUBLIC	??B?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,-4509840863236766927,char>::operator char *
PUBLIC	?Disconnect@Client@@QEAAHXZ			; Client::Disconnect
PUBLIC	?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z ; Client::MakeServerRequest
PUBLIC	?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ; Client::TCPSendMessageToServer
PUBLIC	?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ; Client::UDPSendMessageToServer
PUBLIC	?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ ; Client::UDPRecvMessageFromServer
PUBLIC	?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z ; Client::DecryptServerRequest
PUBLIC	??0NET_BLOB@@QEAA@AEBU0@@Z			; NET_BLOB::NET_BLOB
PUBLIC	?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z ; Client::EncryptClientRequest
PUBLIC	?Connect@Client@@QEAAHXZ			; Client::Connect
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??1Client@@QEAA@XZ				; Client::~Client
PUBLIC	??0Client@@QEAA@XZ				; Client::Client
PUBLIC	?SocketReady@Client@@QEBAHW4SocketTypes@@@Z	; Client::SocketReady
PUBLIC	??$cipher@D@ay@@YAXPEAD_K1@Z			; ay::cipher<char>
PUBLIC	??0ClientRequest@@QEAA@AEBU0@@Z			; ClientRequest::ClientRequest
PUBLIC	?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; NetCommon::RequestToBlob
PUBLIC	??0ProcessInformation@@QEAA@AEBU0@@Z		; ProcessInformation::ProcessInformation
PUBLIC	??0ServerCommand@@QEAA@AEBU0@@Z			; ServerCommand::ServerCommand
PUBLIC	??1ProcessInformation@@QEAA@XZ			; ProcessInformation::~ProcessInformation
PUBLIC	??1ServerCommand@@QEAA@XZ			; ServerCommand::~ServerCommand
PUBLIC	??1ClientRequest@@QEAA@XZ			; ClientRequest::~ClientRequest
PUBLIC	??1NET_BLOB@@QEAA@XZ				; NET_BLOB::~NET_BLOB
PUBLIC	?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptByteString
PUBLIC	?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2
PUBLIC	?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::SerializeString
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	__isa_available_default
PUBLIC	__real@5f000000
PUBLIC	__xmm@00000000000000010000000000000000
PUBLIC	__xmm@00000000000000030000000000000002
PUBLIC	__xmm@00000000000000050000000000000004
PUBLIC	__xmm@00000000000000070000000000000006
PUBLIC	__xmm@00000000000000070000000000000007
PUBLIC	__xmm@000000000000000f0000000000000000
PUBLIC	__xmm@00000000000008000000000000000800
PUBLIC	__xmm@09376f353935157309376f3539351573
PUBLIC	__xmm@1114cdf5faf7edaa4c73d8edfefaf386
PUBLIC	__xmm@1301a3a71d258b291301a3a71d258b29
PUBLIC	__xmm@193305173d3dc37b193305173d3dc37b
PUBLIC	__xmm@2327bd999f9f81c52327bd999f9f81c5
PUBLIC	__xmm@57fb21ed7b6501a957fb21ed7b6501a9
PUBLIC	__xmm@6f55cd957ba3590f6f55cd957ba3590f
PUBLIC	__xmm@7d410717b555f99b7d410717b555f99b
PUBLIC	__xmm@7d561b665c567c057b523c4c4b506022
PUBLIC	__xmm@83af0533df55afe783af0533df55afe7
PUBLIC	__xmm@8707dd23b1c9b5ef8707dd23b1c9b5ef
PUBLIC	__xmm@89f52b3945a9b13589f52b3945a9b135
PUBLIC	__xmm@95db052fc5cb633595db052fc5cb6335
PUBLIC	__xmm@9d3fe36fdf3909279d3fe36fdf390927
PUBLIC	__xmm@a9fb6ded3163673ba9fb6ded3163673b
PUBLIC	__xmm@ae8f341def7b9fc9b49d3413b83bc697
PUBLIC	__xmm@b920101e2aaed804bf19221938aec928
PUBLIC	__xmm@bd4045c34225ea7786414cdb5024eb4d
PUBLIC	__xmm@cc9c0a827d06135ac7941e9f54130a72
PUBLIC	__xmm@cd49476d59cbbb6bcd49476d59cbbb6b
PUBLIC	__xmm@cf2529af23519919cf2529af23519919
PUBLIC	__xmm@cff1734fb9430b19cff1734fb9430b19
PUBLIC	__xmm@d11bf34b25d5a973d11bf34b25d5a973
PUBLIC	__xmm@dfa009bc1d20bbd9ec840eaa0c268fbb
PUBLIC	__xmm@dff77dcf6f49fdebdff77dcf6f49fdeb
PUBLIC	__xmm@e3912dfd25097b7be3912dfd25097b7b
PUBLIC	__xmm@ea1fa840ff5c7142b35b8e0c830b3a4a
PUBLIC	__xmm@f84b90168c657a50f25b8d0688653364
PUBLIC	__xmm@ffc3978bc98f5399ffc3978bc98f5399
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_CxxThrowException:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	ceilf:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	__isa_available:DWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
;	COMDAT ??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V34@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V34@A DB 0cH DUP (?) ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A DB 0bH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::kernel32
?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::ntdll
?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::advapi32
_BSS	ENDS
;	COMDAT __isa_available_default
_BSS	SEGMENT
__isa_available_default DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+58
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN30
	DD	imagerel $LN30+88
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN27
	DD	imagerel $LN27+88
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN33
	DD	imagerel $LN33+91
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD imagerel $LN24
	DD	imagerel $LN24+49
	DD	imagerel $unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD imagerel $LN30
	DD	imagerel $LN30+88
	DD	imagerel $unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+131
	DD	imagerel $unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z DD imagerel $LN33
	DD	imagerel $LN33+91
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN52
	DD	imagerel $LN52+110
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z DD imagerel $LN24
	DD	imagerel $LN24+49
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD imagerel $LN128
	DD	imagerel $LN128+64
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD imagerel $LN128+64
	DD	imagerel $LN128+305
	DD	imagerel $chain$2$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD imagerel $LN128+305
	DD	imagerel $LN128+317
	DD	imagerel $chain$4$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD imagerel $LN128+317
	DD	imagerel $LN128+323
	DD	imagerel $chain$5$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z DD imagerel $LN29
	DD	imagerel $LN29+41
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN108
	DD	imagerel $LN108+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN108+34
	DD	imagerel $LN108+244
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN108+244
	DD	imagerel $LN108+256
	DD	imagerel $chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN108+256
	DD	imagerel $LN108+262
	DD	imagerel $chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+115
	DD	imagerel $unwind$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD imagerel $LN46
	DD	imagerel $LN46+136
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ DD imagerel $LN37
	DD	imagerel $LN37+92
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN20
	DD	imagerel $LN20+52
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN99
	DD	imagerel $LN99+242
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN97
	DD	imagerel $LN97+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN97+78
	DD	imagerel $LN97+233
	DD	imagerel $chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN97+233
	DD	imagerel $LN97+245
	DD	imagerel $chain$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN97+245
	DD	imagerel $LN97+251
	DD	imagerel $chain$3$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+46
	DD	imagerel $LN104+162
	DD	imagerel $chain$0$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+162
	DD	imagerel $LN104+163
	DD	imagerel $chain$1$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+163
	DD	imagerel $LN104+169
	DD	imagerel $chain$2$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+169
	DD	imagerel $LN104+175
	DD	imagerel $chain$3$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+175
	DD	imagerel $LN104+181
	DD	imagerel $chain$4$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN38
	DD	imagerel $LN38+125
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD imagerel $LN75
	DD	imagerel $LN75+273
	DD	imagerel $unwind$??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD imagerel $LN85
	DD	imagerel $LN85+326
	DD	imagerel $unwind$??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN23
	DD	imagerel $LN23+61
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN16
	DD	imagerel $LN16+23
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN27
	DD	imagerel $LN27+62
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD imagerel $LN23
	DD	imagerel $LN23+61
	DD	imagerel $unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN38
	DD	imagerel $LN38+94
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+87
	DD	imagerel $unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN123
	DD	imagerel $LN123+276
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN117
	DD	imagerel $LN117+285
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+94
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN111
	DD	imagerel $LN111+188
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD imagerel $LN35
	DD	imagerel $LN35+87
	DD	imagerel $unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+125
	DD	imagerel $unwind$?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Disconnect@Client@@QEAAHXZ DD imagerel $LN14
	DD	imagerel $LN14+45
	DD	imagerel $unwind$?Disconnect@Client@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z DD imagerel $LN62
	DD	imagerel $LN62+262
	DD	imagerel $unwind$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DD imagerel $LN126
	DD	imagerel $LN126+451
	DD	imagerel $unwind$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DD imagerel $LN125
	DD	imagerel $LN125+527
	DD	imagerel $unwind$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ DD imagerel $LN185
	DD	imagerel $LN185+426
	DD	imagerel $unwind$?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z DD imagerel $LN40
	DD	imagerel $LN40+209
	DD	imagerel $unwind$?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0NET_BLOB@@QEAA@AEBU0@@Z DD imagerel $LN19
	DD	imagerel $LN19+227
	DD	imagerel $unwind$??0NET_BLOB@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z DD imagerel $LN63
	DD	imagerel $LN63+307
	DD	imagerel $unwind$?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Connect@Client@@QEAAHXZ DD imagerel $LN99
	DD	imagerel $LN99+359
	DD	imagerel $unwind$?Connect@Client@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DD imagerel ??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ+105
	DD	imagerel $unwind$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Client@@QEAA@XZ DD imagerel $LN136
	DD	imagerel $LN136+345
	DD	imagerel $unwind$??1Client@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Client@@QEAA@XZ DD imagerel $LN47
	DD	imagerel $LN47+104
	DD	imagerel $unwind$??0Client@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DD imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ+108
	DD	imagerel $unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$cipher@D@ay@@YAXPEAD_K1@Z DD imagerel $LN29
	DD	imagerel $LN29+88
	DD	imagerel $unwind$??$cipher@D@ay@@YAXPEAD_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$cipher@D@ay@@YAXPEAD_K1@Z DD imagerel $LN29+88
	DD	imagerel $LN29+368
	DD	imagerel $chain$1$??$cipher@D@ay@@YAXPEAD_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$cipher@D@ay@@YAXPEAD_K1@Z DD imagerel $LN29+368
	DD	imagerel $LN29+400
	DD	imagerel $chain$2$??$cipher@D@ay@@YAXPEAD_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ClientRequest@@QEAA@AEBU0@@Z DD imagerel $LN6
	DD	imagerel $LN6+49
	DD	imagerel $unwind$??0ClientRequest@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN161
	DD	imagerel $LN161+404
	DD	imagerel $unwind$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ProcessInformation@@QEAA@AEBU0@@Z DD imagerel $LN6
	DD	imagerel $LN6+47
	DD	imagerel $unwind$??0ProcessInformation@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ServerCommand@@QEAA@AEBU0@@Z DD imagerel $LN11
	DD	imagerel $LN11+105
	DD	imagerel $unwind$??0ServerCommand@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ProcessInformation@@QEAA@XZ DD imagerel $LN48
	DD	imagerel $LN48+96
	DD	imagerel $unwind$??1ProcessInformation@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ServerCommand@@QEAA@XZ DD imagerel $LN134
	DD	imagerel $LN134+250
	DD	imagerel $unwind$??1ServerCommand@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ClientRequest@@QEAA@XZ DD imagerel $LN48
	DD	imagerel $LN48+96
	DD	imagerel $unwind$??1ClientRequest@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1NET_BLOB@@QEAA@XZ DD imagerel $LN94
	DD	imagerel $LN94+195
	DD	imagerel $unwind$??1NET_BLOB@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD imagerel $LN94
	DD	imagerel $LN94+387
	DD	imagerel $unwind$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD imagerel $LN96
	DD	imagerel $LN96+284
	DD	imagerel $unwind$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA DD imagerel ?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA
	DD	imagerel ?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+42
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN9
	DD	imagerel $LN9+60
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN14
	DD	imagerel $LN14+60
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN22
	DD	imagerel $LN22+66
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+66
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kernel32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::kernel32$initializer$
;	COMDAT __xmm@ffc3978bc98f5399ffc3978bc98f5399
CONST	SEGMENT
__xmm@ffc3978bc98f5399ffc3978bc98f5399 DB 099H, 'S', 08fH, 0c9H, 08bH, 097H
	DB	0c3H, 0ffH, 099H, 'S', 08fH, 0c9H, 08bH, 097H, 0c3H, 0ffH
CONST	ENDS
;	COMDAT __xmm@f84b90168c657a50f25b8d0688653364
CONST	SEGMENT
__xmm@f84b90168c657a50f25b8d0688653364 DB 'd3e', 088H, 06H, 08dH, '[', 0f2H
	DB	'Pze', 08cH, 016H, 090H, 'K', 0f8H
CONST	ENDS
;	COMDAT __xmm@ea1fa840ff5c7142b35b8e0c830b3a4a
CONST	SEGMENT
__xmm@ea1fa840ff5c7142b35b8e0c830b3a4a DB 'J:', 0bH, 083H, 0cH, 08eH, '[', 0b3H
	DB	'Bq\', 0ffH, '@', 0a8H, 01fH, 0eaH
CONST	ENDS
;	COMDAT __xmm@e3912dfd25097b7be3912dfd25097b7b
CONST	SEGMENT
__xmm@e3912dfd25097b7be3912dfd25097b7b DB '{{', 09H, '%', 0fdH, '-', 091H
	DB	0e3H, '{{', 09H, '%', 0fdH, '-', 091H, 0e3H
CONST	ENDS
;	COMDAT __xmm@dff77dcf6f49fdebdff77dcf6f49fdeb
CONST	SEGMENT
__xmm@dff77dcf6f49fdebdff77dcf6f49fdeb DB 0ebH, 0fdH, 'Io', 0cfH, '}', 0f7H
	DB	0dfH, 0ebH, 0fdH, 'Io', 0cfH, '}', 0f7H, 0dfH
CONST	ENDS
;	COMDAT __xmm@dfa009bc1d20bbd9ec840eaa0c268fbb
CONST	SEGMENT
__xmm@dfa009bc1d20bbd9ec840eaa0c268fbb DB 0bbH, 08fH, '&', 0cH, 0aaH, 0eH
	DB	084H, 0ecH, 0d9H, 0bbH, ' ', 01dH, 0bcH, 09H, 0a0H, 0dfH
CONST	ENDS
;	COMDAT __xmm@d11bf34b25d5a973d11bf34b25d5a973
CONST	SEGMENT
__xmm@d11bf34b25d5a973d11bf34b25d5a973 DB 's', 0a9H, 0d5H, '%K', 0f3H, 01bH
	DB	0d1H, 's', 0a9H, 0d5H, '%K', 0f3H, 01bH, 0d1H
CONST	ENDS
;	COMDAT __xmm@cff1734fb9430b19cff1734fb9430b19
CONST	SEGMENT
__xmm@cff1734fb9430b19cff1734fb9430b19 DB 019H, 0bH, 'C', 0b9H, 'Os', 0f1H
	DB	0cfH, 019H, 0bH, 'C', 0b9H, 'Os', 0f1H, 0cfH
CONST	ENDS
;	COMDAT __xmm@cf2529af23519919cf2529af23519919
CONST	SEGMENT
__xmm@cf2529af23519919cf2529af23519919 DB 019H, 099H, 'Q#', 0afH, ')%', 0cfH
	DB	019H, 099H, 'Q#', 0afH, ')%', 0cfH
CONST	ENDS
;	COMDAT __xmm@cd49476d59cbbb6bcd49476d59cbbb6b
CONST	SEGMENT
__xmm@cd49476d59cbbb6bcd49476d59cbbb6b DB 'k', 0bbH, 0cbH, 'YmGI', 0cdH, 'k'
	DB	0bbH, 0cbH, 'YmGI', 0cdH
CONST	ENDS
;	COMDAT __xmm@cc9c0a827d06135ac7941e9f54130a72
CONST	SEGMENT
__xmm@cc9c0a827d06135ac7941e9f54130a72 DB 'r', 0aH, 013H, 'T', 09fH, 01eH
	DB	094H, 0c7H, 'Z', 013H, 06H, '}', 082H, 0aH, 09cH, 0ccH
CONST	ENDS
;	COMDAT __xmm@bd4045c34225ea7786414cdb5024eb4d
CONST	SEGMENT
__xmm@bd4045c34225ea7786414cdb5024eb4d DB 'M', 0ebH, '$P', 0dbH, 'LA', 086H
	DB	'w', 0eaH, '%B', 0c3H, 'E@', 0bdH
CONST	ENDS
;	COMDAT __xmm@b920101e2aaed804bf19221938aec928
CONST	SEGMENT
__xmm@b920101e2aaed804bf19221938aec928 DB '(', 0c9H, 0aeH, '8', 019H, '"', 019H
	DB	0bfH, 04H, 0d8H, 0aeH, '*', 01eH, 010H, ' ', 0b9H
CONST	ENDS
;	COMDAT __xmm@ae8f341def7b9fc9b49d3413b83bc697
CONST	SEGMENT
__xmm@ae8f341def7b9fc9b49d3413b83bc697 DB 097H, 0c6H, ';', 0b8H, 013H, '4'
	DB	09dH, 0b4H, 0c9H, 09fH, '{', 0efH, 01dH, '4', 08fH, 0aeH
CONST	ENDS
;	COMDAT __xmm@a9fb6ded3163673ba9fb6ded3163673b
CONST	SEGMENT
__xmm@a9fb6ded3163673ba9fb6ded3163673b DB ';gc1', 0edH, 'm', 0fbH, 0a9H, ';'
	DB	'gc1', 0edH, 'm', 0fbH, 0a9H
CONST	ENDS
;	COMDAT __xmm@9d3fe36fdf3909279d3fe36fdf390927
CONST	SEGMENT
__xmm@9d3fe36fdf3909279d3fe36fdf390927 DB '''', 09H, '9', 0dfH, 'o', 0e3H
	DB	'?', 09dH, '''', 09H, '9', 0dfH, 'o', 0e3H, '?', 09dH
CONST	ENDS
;	COMDAT __xmm@95db052fc5cb633595db052fc5cb6335
CONST	SEGMENT
__xmm@95db052fc5cb633595db052fc5cb6335 DB '5c', 0cbH, 0c5H, '/', 05H, 0dbH
	DB	095H, '5c', 0cbH, 0c5H, '/', 05H, 0dbH, 095H
CONST	ENDS
;	COMDAT __xmm@89f52b3945a9b13589f52b3945a9b135
CONST	SEGMENT
__xmm@89f52b3945a9b13589f52b3945a9b135 DB '5', 0b1H, 0a9H, 'E9+', 0f5H, 089H
	DB	'5', 0b1H, 0a9H, 'E9+', 0f5H, 089H
CONST	ENDS
;	COMDAT __xmm@8707dd23b1c9b5ef8707dd23b1c9b5ef
CONST	SEGMENT
__xmm@8707dd23b1c9b5ef8707dd23b1c9b5ef DB 0efH, 0b5H, 0c9H, 0b1H, '#', 0ddH
	DB	07H, 087H, 0efH, 0b5H, 0c9H, 0b1H, '#', 0ddH, 07H, 087H
CONST	ENDS
;	COMDAT __xmm@83af0533df55afe783af0533df55afe7
CONST	SEGMENT
__xmm@83af0533df55afe783af0533df55afe7 DB 0e7H, 0afH, 'U', 0dfH, '3', 05H
	DB	0afH, 083H, 0e7H, 0afH, 'U', 0dfH, '3', 05H, 0afH, 083H
CONST	ENDS
;	COMDAT __xmm@7d561b665c567c057b523c4c4b506022
CONST	SEGMENT
__xmm@7d561b665c567c057b523c4c4b506022 DB '"`PKL<R{', 05H, '|V\f', 01bH, 'V'
	DB	'}'
CONST	ENDS
;	COMDAT __xmm@7d410717b555f99b7d410717b555f99b
CONST	SEGMENT
__xmm@7d410717b555f99b7d410717b555f99b DB 09bH, 0f9H, 'U', 0b5H, 017H, 07H
	DB	'A}', 09bH, 0f9H, 'U', 0b5H, 017H, 07H, 'A}'
CONST	ENDS
;	COMDAT __xmm@6f55cd957ba3590f6f55cd957ba3590f
CONST	SEGMENT
__xmm@6f55cd957ba3590f6f55cd957ba3590f DB 0fH, 'Y', 0a3H, '{', 095H, 0cdH
	DB	'Uo', 0fH, 'Y', 0a3H, '{', 095H, 0cdH, 'Uo'
CONST	ENDS
;	COMDAT __xmm@57fb21ed7b6501a957fb21ed7b6501a9
CONST	SEGMENT
__xmm@57fb21ed7b6501a957fb21ed7b6501a9 DB 0a9H, 01H, 'e{', 0edH, '!', 0fbH
	DB	'W', 0a9H, 01H, 'e{', 0edH, '!', 0fbH, 'W'
CONST	ENDS
;	COMDAT __xmm@2327bd999f9f81c52327bd999f9f81c5
CONST	SEGMENT
__xmm@2327bd999f9f81c52327bd999f9f81c5 DB 0c5H, 081H, 09fH, 09fH, 099H, 0bdH
	DB	'''#', 0c5H, 081H, 09fH, 09fH, 099H, 0bdH, '''#'
CONST	ENDS
;	COMDAT __xmm@193305173d3dc37b193305173d3dc37b
CONST	SEGMENT
__xmm@193305173d3dc37b193305173d3dc37b DB '{', 0c3H, '==', 017H, 05H, '3', 019H
	DB	'{', 0c3H, '==', 017H, 05H, '3', 019H
CONST	ENDS
;	COMDAT __xmm@1301a3a71d258b291301a3a71d258b29
CONST	SEGMENT
__xmm@1301a3a71d258b291301a3a71d258b29 DB ')', 08bH, '%', 01dH, 0a7H, 0a3H
	DB	01H, 013H, ')', 08bH, '%', 01dH, 0a7H, 0a3H, 01H, 013H
CONST	ENDS
;	COMDAT __xmm@1114cdf5faf7edaa4c73d8edfefaf386
CONST	SEGMENT
__xmm@1114cdf5faf7edaa4c73d8edfefaf386 DB 086H, 0f3H, 0faH, 0feH, 0edH, 0d8H
	DB	'sL', 0aaH, 0edH, 0f7H, 0faH, 0f5H, 0cdH, 014H, 011H
CONST	ENDS
;	COMDAT __xmm@09376f353935157309376f3539351573
CONST	SEGMENT
__xmm@09376f353935157309376f3539351573 DB 's', 015H, '595o7', 09H, 's', 015H
	DB	'595o7', 09H
CONST	ENDS
;	COMDAT __xmm@00000000000008000000000000000800
CONST	SEGMENT
__xmm@00000000000008000000000000000800 DB 00H, 08H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 08H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@000000000000000f0000000000000000
CONST	SEGMENT
__xmm@000000000000000f0000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 0fH, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000070000000000000007
CONST	SEGMENT
__xmm@00000000000000070000000000000007 DB 07H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000070000000000000006
CONST	SEGMENT
__xmm@00000000000000070000000000000006 DB 06H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000050000000000000004
CONST	SEGMENT
__xmm@00000000000000050000000000000004 DB 04H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 05H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000030000000000000002
CONST	SEGMENT
__xmm@00000000000000030000000000000002 DB 02H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 03H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000010000000000000000
CONST	SEGMENT
__xmm@00000000000000010000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@5f000000
CONST	SEGMENT
__real@5f000000 DD 05f000000r			; 9.22337e+18
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 04H
	DB	085H, 02H
	DB	04H
	DB	0baH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	imagerel $ip2state$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 082119H
	DD	0f5412H
	DD	0e3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 06H
	DB	'|'
	DB	02H
	DB	'M', 03H
	DB	00H
	DB	0ccH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	imagerel $ip2state$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 051f19H
	DD	032340dH
	DD	02e010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	0162H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1NET_BLOB@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ClientRequest@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ServerCommand@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ProcessInformation@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ServerCommand@@QEAA@AEBU0@@Z DB 06H
	DB	'h'
	DB	00H
	DB	01cH
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ServerCommand@@QEAA@AEBU0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ServerCommand@@QEAA@AEBU0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0ServerCommand@@QEAA@AEBU0@@Z
	DD	imagerel $ip2state$??0ServerCommand@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ServerCommand@@QEAA@AEBU0@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ServerCommand@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ProcessInformation@@QEAA@AEBU0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 06H
	DB	09eH
	DB	04H
	DB	'%', 02H
	DB	08H
	DB	'm', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
	DB	034H
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	080H
	DB	034H
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$7@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 061b19H
	DD	013340cH
	DD	07008b20cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ClientRequest@@QEAA@AEBU0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$cipher@D@ay@@YAXPEAD_K1@Z DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+88
	DD	imagerel $unwind$??$cipher@D@ay@@YAXPEAD_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$cipher@D@ay@@YAXPEAD_K1@Z DD 041021H
	DD	07410H
	DD	023405H
	DD	imagerel $LN29
	DD	imagerel $LN29+88
	DD	imagerel $unwind$??$cipher@D@ay@@YAXPEAD_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$cipher@D@ay@@YAXPEAD_K1@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0a6H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a2H
	DB	02H
	DB	'i', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Client@@QEAA@XZ DB 02H
	DB	0b2H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Client@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0Client@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0Client@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Client@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0Client@@QEAA@XZ
	DD	imagerel $ip2state$??0Client@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Client@@QEAA@XZ DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0Client@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1Client@@QEAA@XZ DB 02H
	DB	'.'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1Client@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1Client@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Client@@QEAA@XZ DD 040a19H
	DD	0b340aH
	DD	07006720aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1Client@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DB 02H
	DB	0a0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Connect@Client@@QEAAHXZ DB 06H
	DB	'l'
	DB	00H
	DB	0c4H
	DB	02H
	DB	0d4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Connect@Client@@QEAAHXZ DB 02H
	DB	0aH
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Connect@Client@@QEAAHXZ DB 028H
	DD	imagerel $stateUnwindMap$?Connect@Client@@QEAAHXZ
	DD	imagerel $ip2state$?Connect@Client@@QEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Connect@Client@@QEAAHXZ DD 051f19H
	DD	015340dH
	DD	012010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Connect@Client@@QEAAHXZ
	DD	08aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z DB 0cH
	DB	08cH
	DB	02H
	DB	'N'
	DB	04H
	DB	','
	DB	02H
	DB	'D'
	DB	06H
	DB	'"'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z DB 06H
	DB	0cH
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	01H
	DB	06H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	06aH
	DD	imagerel ??1NET_BLOB@@QEAA@XZ
	DB	041H
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z
	DD	imagerel $ip2state$?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z DD 051d19H
	DD	054010bH
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z
	DD	0292H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0NET_BLOB@@QEAA@AEBU0@@Z DB 0aH
	DB	'h'
	DB	00H
	DB	'^'
	DB	02H
	DB	01cH
	DB	04H
	DB	'"'
	DB	06H
	DB	090H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0NET_BLOB@@QEAA@AEBU0@@Z DB 08H
	DB	0cH
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$4@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA
	DB	086H
	DD	imagerel ?dtor$1@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0NET_BLOB@@QEAA@AEBU0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0NET_BLOB@@QEAA@AEBU0@@Z
	DD	imagerel $ip2state$??0NET_BLOB@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0NET_BLOB@@QEAA@AEBU0@@Z DD 061411H
	DD	096414H
	DD	083414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0NET_BLOB@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 08H
	DB	086H
	DB	02H
	DB	' '
	DB	04H
	DB	01eH
	DB	02H
	DB	0a2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0e0H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	imagerel $ip2state$?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z DD 061e19H
	DD	017340fH
	DD	07008f20fH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ DB 0cH
	DB	086H
	DB	02H
	DB	084H
	DB	00H
	DB	0d4H
	DB	02H
	DB	'6'
	DB	04H
	DB	'&'
	DB	02H
	DB	084H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ DB 04H
	DB	0aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	081H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ DB 028H
	DD	imagerel $stateUnwindMap$?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ
	DD	imagerel $ip2state$?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ DD 072519H
	DD	01d6413H
	DD	01c3413H
	DD	0180113H
	DD	0700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ
	DD	0baH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DB 0aH
	DB	05H, 03H
	DB	02H
	DB	'6'
	DB	04H
	DB	'\'
	DB	02H
	DB	0d4H
	DB	04H
	DB	0deH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	041H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	061H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
	DD	imagerel $ip2state$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DD 072419H
	DD	01d6412H
	DD	01c3412H
	DD	0180112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DB 08H
	DB	0c9H, 02H
	DB	02H
	DB	'0'
	DB	04H
	DB	'<'
	DB	02H
	DB	0e5H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
	DD	imagerel $ip2state$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DD 041c19H
	DD	014340dH
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z DB 04H
	DB	09aH
	DB	02H
	DB	08aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z DB 02H
	DB	0cH
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	021H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z
	DD	imagerel $ip2state$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z DD 052119H
	DD	018340fH
	DD	014010fH
	DD	07008H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z
	DD	092H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Disconnect@Client@@QEAAHXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 0aH
	DB	'x'
	DB	04H
	DB	'x'
	DB	06H
	DB	01cH
	DB	08H
	DB	'('
	DB	02H
	DB	'A', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 08H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0b0H
	DB	036H
	DD	imagerel ?dtor$4@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	imagerel $ip2state$??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 061a19H
	DD	0e007d20bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	06aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 06H
	DB	'l'
	DB	04H
	DB	'V'
	DB	02H
	DB	'=', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a0H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	imagerel $ip2state$??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 061b19H
	DD	010340cH
	DD	07008b20cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 020021H
	DD	047400H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 021H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 020021H
	DD	047400H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 021H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 020521H
	DD	047405H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 051301H
	DD	0f00f4213H
	DD	0600be00dH
	DD	0300aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 021H
	DD	imagerel $LN97
	DD	imagerel $LN97+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 020021H
	DD	047400H
	DD	imagerel $LN97
	DD	imagerel $LN97+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 020521H
	DD	047405H
	DD	imagerel $LN97
	DD	imagerel $LN97+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 050a01H
	DD	0e006420aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 060c01H
	DD	0b340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN108
	DD	imagerel $LN108+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060021H
	DD	04f400H
	DD	057400H
	DD	0c6400H
	DD	imagerel $LN108
	DD	imagerel $LN108+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 061221H
	DD	04f412H
	DD	05740dH
	DD	0c6405H
	DD	imagerel $LN108
	DD	imagerel $LN108+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040901H
	DD	0e0055209H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD 021H
	DD	imagerel $LN128
	DD	imagerel $LN128+64
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD 060021H
	DD	04c400H
	DD	056400H
	DD	0e3400H
	DD	imagerel $LN128
	DD	imagerel $LN128+64
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD 061521H
	DD	04c415H
	DD	05640aH
	DD	0e3405H
	DD	imagerel $LN128
	DD	imagerel $LN128+64
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD 060d01H
	DD	0f009520dH
	DD	0d005e007H
	DD	050027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
CRT$XCU	SEGMENT
?ntdll$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::ntdll$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?advapi32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::advapi32$initializer$
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 183  :     return __builtin_is_constant_evaluated();

	xor	al, al

; 184  : }

	ret	0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, rdx

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 636  :         return LLONG_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 637  :     }

	ret	0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 68   :         _Data._What = _Message;
; 69   :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0
	lea	rdx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx], rcx

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	__std_exception_copy

; 75   :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	jmp	__std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rdx, QWORD PTR [rcx+8]
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	test	rdx, rdx
	cmovne	rax, rdx

; 97   :     }

	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	__std_exception_destroy
	test	bl, 1
	je	SHORT $LN8@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@

; 66   :         : _Data()

	mov	QWORD PTR [rcx+16], 0

; 133  :     {

	mov	QWORD PTR [rcx], rax

; 134  :     }

	mov	rax, rcx

; 68   :         _Data._What = _Message;

	mov	QWORD PTR [rcx+8], rdx

; 134  :     }

	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	__std_exception_destroy
	test	bl, 1
	je	SHORT $LN13@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	jmp	__std_exception_destroy
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 68   :         _Data._What = _Message;

	lea	rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rax

; 144  :     {

	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rcx], rax

; 145  :     }

	mov	rax, rcx
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	__std_exception_destroy
	test	bl, 1
	je	SHORT $LN18@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN18@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	jmp	__std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 74   : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
	sub	rsp, 72					; 00000048H

; 75   :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 73   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 72   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]

; 73   :     {

	mov	QWORD PTR [rbx], rcx

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	__std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 73   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 72   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]

; 73   :     {

	mov	QWORD PTR [rbx], rcx

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	__std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 8
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 169  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN13:
	sub	rsp, 40					; 00000028H

; 170  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 171  :     _Bytes += _Non_user_size;

	add	QWORD PTR [rdx], 39			; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rdx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN7@Adjust_man

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	QWORD PTR [rcx], rdx

; 190  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Adjust_man:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN11@Adjust_man:
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1149 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1150 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1151 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1415 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	rax, rcx
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1418 :     _CONSTEXPR20 void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2326 : [[noreturn]] inline void _Xlen_string() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2327 :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlen_strin:
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
_TEXT	SEGMENT
c$1 = 32
$T2 = 36
__$ReturnUdt$GSCopy$ = 40
s$GSCopy$ = 48
__$ArrayPad$ = 56
__$ReturnUdt$ = 96
s$ = 104
?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; NetCommon::SerializeString, COMDAT

; 59   :     inline BYTESTRING SerializeString(std::string s) {

$LN96:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR s$GSCopy$[rsp], rdx
	xor	r14d, r14d
	mov	DWORD PTR $T2[rsp], r14d
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], r14
	mov	QWORD PTR [rcx+8], r14
	mov	QWORD PTR [rcx+16], r14
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 60   :         BYTESTRING bs;

	mov	DWORD PTR $T2[rsp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN90@SerializeS

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdx]
	mov	rcx, rdi
	mov	rdx, rdi
	jmp	SHORT $LN35@SerializeS
$LN90@SerializeS:
	mov	rdi, rsi
	mov	rcx, rsi
$LN35@SerializeS:

; 3987 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	rbp, QWORD PTR [rsi+16]
	add	rbp, rcx
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 61   :         for ( BYTE c : s )

	cmp	rdx, rbp
	je	SHORT $LN3@SerializeS
	npad	10
$LL4@SerializeS:
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR c$1[rsp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 775  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+8]
	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN44@SerializeS

; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], al

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;
; 800  :         ++_Mylast;

	inc	QWORD PTR [rbx+8]

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@SerializeS
$LN44@SerializeS:

; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR c$1[rsp]
	mov	rcx, rbx
	call	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
$LN2@SerializeS:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 61   :         for ( BYTE c : s )

	inc	rdi
	cmp	rdi, rbp
	jne	SHORT $LL4@SerializeS
$LN3@SerializeS:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rsi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN65@SerializeS

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rsi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN79@SerializeS

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN76@SerializeS

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN79@SerializeS:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN65@SerializeS:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+16], r14

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rsi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 63   :         return bs;

	mov	rax, rbx

; 64   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN76@SerializeS:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN93@SerializeS:
?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; NetCommon::SerializeString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
c$1 = 32
$T2 = 36
__$ReturnUdt$GSCopy$ = 40
s$GSCopy$ = 48
__$ArrayPad$ = 56
__$ReturnUdt$ = 96
s$ = 104
?dtor$0@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::SerializeString'::`1'::dtor$0
	mov	rcx, QWORD PTR s$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::SerializeString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
c$1 = 32
$T2 = 36
__$ReturnUdt$GSCopy$ = 40
s$GSCopy$ = 48
__$ArrayPad$ = 56
__$ReturnUdt$ = 96
s$ = 104
?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::SerializeString'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$1
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
$LN8@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::SerializeString'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
_TEXT	SEGMENT
$T1 = 40
key$GSCopy$ = 72
byteKey$ = 80
aes$ = 112
__$ArrayPad$ = 352
string$ = 384
key$ = 392
?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; NetCommon::DecryptByteString, COMDAT

; 78   :     inline void DecryptByteString(BYTESTRING& string, std::string key) {

$LN94:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 368				; 00000170H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR key$GSCopy$[rsp], rdx
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR byteKey$[rsp], xmm0
	mov	QWORD PTR byteKey$[rsp+16], rax

; 79   :         BYTESTRING byteKey = NetCommon::SerializeString(key);

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR byteKey$[rsp]
	call	?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::SerializeString
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 608  :         Aes(unsigned char key[key_bits]) : round_keys() {

	xor	edx, edx
	mov	r8d, 240				; 000000f0H
	lea	rcx, QWORD PTR aes$[rsp]
	call	memset

; 609  :             constexpr bool invalid_aes_key_bit_size = key_bits == 128 || key_bits == 192 || key_bits == 256;
; 610  :             static_assert( invalid_aes_key_bit_size, "The valid values are only: 128, 192 & 256" );
; 611  : 
; 612  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 613  :             if constexpr ( key_bits == 128 ) {
; 614  :                 AES_128_Key_Expansion(key, round_keys);
; 615  :             }
; 616  :             else if constexpr ( key_bits == 192 ) {
; 617  :                 AES_192_Key_Expansion(key, round_keys);
; 618  :             }
; 619  :             else if constexpr ( key_bits == 256 ) {
; 620  :                 AES_256_Key_Expansion(key, round_keys);

	lea	r8, QWORD PTR aes$[rsp]
	mov	rdx, QWORD PTR byteKey$[rsp]
	call	?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ; Cipher::Aes<256>::AES_256_Key_Expansion
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 81   :         aes.decrypt_block(string.data());

	mov	rdx, QWORD PTR [rbx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 778  :             state = _mm_xor_si128(state, xmm_round_keys[Nr]);

	movdqu	xmm5, XMMWORD PTR [rdx]
	xorps	xmm5, XMMWORD PTR aes$[rsp+224]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 78   :     inline void DecryptByteString(BYTESTRING& string, std::string key) {

	lea	rax, QWORD PTR aes$[rsp+208]
	mov	ecx, 6
	npad	3
$LL15@DecryptByt:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 782  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i]));

	aesimc	xmm0, XMMWORD PTR [rax]

; 783  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i - 1]));

	aesimc	xmm1, XMMWORD PTR [rax-16]

; 782  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i]));

	aesdec	xmm5, xmm0

; 783  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i - 1]));

	aesdec	xmm5, xmm1

; 779  : 
; 780  :             // usual rounds
; 781  :             for ( size_t i = Nr - 1; i > 1; i -= 2 ) {

	lea	rax, QWORD PTR [rax-32]
	sub	rcx, 1
	jne	SHORT $LL15@DecryptByt

; 784  :             }
; 785  : 
; 786  :             // last round
; 787  :             state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[1]));

	aesimc	xmm0, XMMWORD PTR aes$[rsp+16]
	aesdec	xmm5, xmm0

; 788  :             state = _mm_aesdeclast_si128(state, xmm_round_keys[0]);

	aesdeclast xmm5, XMMWORD PTR aes$[rsp]

; 789  : 
; 790  :             // store from register to array
; 791  :             _mm_storeu_si128(( __m128i* ) block, state);

	movdqu	XMMWORD PTR [rdx], xmm5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	xor	ebx, ebx
	mov	rcx, QWORD PTR byteKey$[rsp]
	test	rcx, rcx
	je	SHORT $LN24@DecryptByt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR byteKey$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN43@DecryptByt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN92@DecryptByt
$LN43@DecryptByt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR byteKey$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR byteKey$[rsp+16], rbx
$LN24@DecryptByt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN66@DecryptByt

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN80@DecryptByt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN77@DecryptByt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN80@DecryptByt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN66@DecryptByt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbx

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 82   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+400]
	add	rsp, 368				; 00000170H
	pop	rdi
	ret	0
$LN92@DecryptByt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN77@DecryptByt:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN90@DecryptByt:
?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; NetCommon::DecryptByteString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
key$GSCopy$ = 72
byteKey$ = 80
aes$ = 112
__$ArrayPad$ = 352
string$ = 384
key$ = 392
?dtor$0@?0??DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptByteString'::`1'::dtor$0
	mov	rcx, QWORD PTR key$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptByteString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1NET_BLOB@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1NET_BLOB@@QEAA@XZ PROC				; NET_BLOB::~NET_BLOB, COMDAT
$LN94:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+240]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@NET_BLOB
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+216]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@NET_BLOB

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN75@NET_BLOB

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@NET_BLOB:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@NET_BLOB:
	lea	rcx, QWORD PTR [rbx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+232], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+240], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+216], 0
	call	??1ServerCommand@@QEAA@XZ

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN64@NET_BLOB
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN78@NET_BLOB

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN75@NET_BLOB

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN78@NET_BLOB:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN64@NET_BLOB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN75@NET_BLOB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN91@NET_BLOB:
??1NET_BLOB@@QEAA@XZ ENDP				; NET_BLOB::~NET_BLOB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1ClientRequest@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ClientRequest@@QEAA@XZ PROC				; ClientRequest::~ClientRequest, COMDAT
$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+40]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@ClientRequ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@ClientRequ

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN32@ClientRequ

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@ClientRequ:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@ClientRequ:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN32@ClientRequ:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN45@ClientRequ:
??1ClientRequest@@QEAA@XZ ENDP				; ClientRequest::~ClientRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1ServerCommand@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ServerCommand@@QEAA@XZ PROC				; ServerCommand::~ServerCommand, COMDAT
$LN134:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+112]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@ServerComm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@ServerComm

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN112@ServerComm

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@ServerComm:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@ServerComm:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+104], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+112], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+88], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+80]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN59@ServerComm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN73@ServerComm

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN112@ServerComm

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN73@ServerComm:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN59@ServerComm:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+72], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+80], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+56], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+48]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN101@ServerComm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN115@ServerComm

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN112@ServerComm

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN115@ServerComm:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN101@ServerComm:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+40], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+48], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+24], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN112@ServerComm:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN131@ServerComm:
??1ServerCommand@@QEAA@XZ ENDP				; ServerCommand::~ServerCommand
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1ProcessInformation@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ProcessInformation@@QEAA@XZ PROC			; ProcessInformation::~ProcessInformation, COMDAT
$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+40]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@ProcessInf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@ProcessInf

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN32@ProcessInf

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@ProcessInf:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@ProcessInf:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN32@ProcessInf:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN45@ProcessInf:
??1ProcessInformation@@QEAA@XZ ENDP			; ProcessInformation::~ProcessInformation
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ServerCommand@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ServerCommand@@QEAA@AEBU0@@Z PROC			; ServerCommand::ServerCommand, COMDAT
$LN11:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+12], eax
	mov	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rcx+16], eax
	add	rcx, 24
	add	rdx, 24
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+56]
	lea	rdx, QWORD PTR [rbx+56]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+88]
	lea	rdx, QWORD PTR [rbx+88]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rbx+120]
	mov	DWORD PTR [rdi+120], eax
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0ServerCommand@@QEAA@AEBU0@@Z ENDP			; ServerCommand::ServerCommand
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA PROC	; `ServerCommand::ServerCommand'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1ProcessInformation@@QEAA@XZ
?dtor$0@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA ENDP	; `ServerCommand::ServerCommand'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$1@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA PROC	; `ServerCommand::ServerCommand'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA ENDP	; `ServerCommand::ServerCommand'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ProcessInformation@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ProcessInformation@@QEAA@AEBU0@@Z PROC		; ProcessInformation::ProcessInformation, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rbx, rcx
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+8]
	add	rdx, 16
	mov	DWORD PTR [rcx+8], eax
	add	rcx, 16
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0ProcessInformation@@QEAA@AEBU0@@Z ENDP		; ProcessInformation::ProcessInformation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 48
request$GSCopy$ = 64
aesKey$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
request$ = 136
aesKey$ = 144
?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; NetCommon::RequestToBlob, COMDAT

; 117  :     inline NET_BLOB RequestToBlob(ClientRequest request, std::string aesKey) {

$LN161:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR request$GSCopy$[rsp], rdx
	mov	QWORD PTR aesKey$GSCopy$[rsp], rbx
	xor	ebp, ebp
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax
	add	rcx, 16
	lea	rdi, QWORD PTR [rdx+16]
	mov	rdx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 118  :         return NET_BLOB{ request, {0}, {0}, aesKey };

	xor	eax, eax
	mov	QWORD PTR [rsi+48], rax
	mov	QWORD PTR [rsi+168], rax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rsi+56], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rsi+72], xmm1

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+88], rbp

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rsi+96], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi+72], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rsi+104], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+120], rbp

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rsi+128], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi+104], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rsi+136], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+152], rbp

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rsi+160], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi+136], al
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 118  :         return NET_BLOB{ request, {0}, {0}, aesKey };

	mov	DWORD PTR [rsi+176], ebp
	movups	XMMWORD PTR [rsi+180], xmm0
	movups	XMMWORD PTR [rsi+196], xmm0
	mov	DWORD PTR [rsi+212], eax
	lea	rcx, QWORD PTR [rsi+216]
	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN99@RequestToB

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rdi]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN113@RequestToB

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN110@RequestToB

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN113@RequestToB:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN99@RequestToB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbp

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN138@RequestToB

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN152@RequestToB

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN149@RequestToB

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN152@RequestToB:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN138@RequestToB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rbp

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 118  :         return NET_BLOB{ request, {0}, {0}, aesKey };

	mov	rax, rsi

; 119  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+152]
	add	rsp, 96					; 00000060H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN110@RequestToB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN149@RequestToB:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN158@RequestToB:
?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; NetCommon::RequestToBlob
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
request$GSCopy$ = 64
aesKey$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
request$ = 136
aesKey$ = 144
?dtor$0@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$0
	mov	rcx, QWORD PTR aesKey$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
request$GSCopy$ = 64
aesKey$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
request$ = 136
aesKey$ = 144
?dtor$1@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$1
	mov	rcx, QWORD PTR request$GSCopy$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$1@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
request$GSCopy$ = 64
aesKey$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
request$ = 136
aesKey$ = 144
?dtor$2@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$2@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
request$GSCopy$ = 64
aesKey$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
request$ = 136
aesKey$ = 144
?dtor$7@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$7
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1ServerCommand@@QEAA@XZ
?dtor$7@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ClientRequest@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ClientRequest@@QEAA@AEBU0@@Z PROC			; ClientRequest::ClientRequest, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rbx, rcx
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, QWORD PTR [rdx+8]
	add	rdx, 16
	mov	QWORD PTR [rcx+8], rax
	add	rcx, 16
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0ClientRequest@@QEAA@AEBU0@@Z ENDP			; ClientRequest::ClientRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??$cipher@D@ay@@YAXPEAD_K1@Z
_TEXT	SEGMENT
data$ = 16
size$ = 24
key$ = 32
??$cipher@D@ay@@YAXPEAD_K1@Z PROC			; ay::cipher<char>, COMDAT

; 66   : 	{

$LN29:
	sub	rsp, 8

; 67   : 		// Obfuscate with a simple XOR cipher based on key
; 68   : 		for ( size_type i = 0; i < size; i++ )

	xor	eax, eax
	movq	xmm2, r8
	punpcklqdq xmm2, xmm2
	mov	r9, rdx
	mov	r10, rcx
	test	rdx, rdx
	je	$LN3@cipher
	cmp	rdx, 8
	jb	$LL22@cipher
	cmp	DWORD PTR __isa_available, 5
	jl	$LL22@cipher
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000010000000000000000

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	mov	r11, rdx
	movdqa	xmm4, XMMWORD PTR __xmm@00000000000000070000000000000007
	lea	rdx, QWORD PTR [rcx+4]
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	and	r11, -8
	mov	QWORD PTR [rsp+16], rbx
	mov	rbx, -2
	mov	QWORD PTR [rsp], rdi
	sub	rbx, rcx
	mov	edi, 2
	sub	rdi, rcx
$LL4@cipher:
	movzx	ecx, WORD PTR [rdx-4]
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	add	rax, 8
	paddq	xmm0, xmm3
	andps	xmm0, xmm4
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-4], cx
	lea	rcx, QWORD PTR [rbx+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm3
	andps	xmm0, xmm4
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-2], cx
	mov	rcx, rdx
	sub	rcx, r10
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm3
	andps	xmm0, xmm4
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx], cx
	lea	rcx, QWORD PTR [rdi+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm3
	andps	xmm0, xmm4
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx+2], cx
	add	rdx, 8
	cmp	rax, r11
	jb	$LL4@cipher

; 67   : 		// Obfuscate with a simple XOR cipher based on key
; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	rdi, QWORD PTR [rsp]
	mov	rbx, QWORD PTR [rsp+16]
	cmp	rax, r9
	jae	SHORT $LN3@cipher
	npad	10
$LL22@cipher:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r8
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r10+rax], dl
	inc	rax
	cmp	rax, r9
	jb	SHORT $LL22@cipher
$LN3@cipher:

; 71   : 		}
; 72   : 	}

	add	rsp, 8
	ret	0
??$cipher@D@ay@@YAXPEAD_K1@Z ENDP			; ay::cipher<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_1>::operator(), COMDAT

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 26548175		; 019517cfH
	mov	DWORD PTR [rbx], 366034020		; 15d13c64H
	mov	DWORD PTR [rbx+4], 1567007216		; 5d66a1f0H
	mov	WORD PTR [rbx+8], 15649			; 00003d21H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'', COMDAT

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 26548175		; 019517cfH
	mov	DWORD PTR [rbx], 366034020		; 15d13c64H
	mov	DWORD PTR [rbx+4], 1567007216		; 5d66a1f0H
	mov	WORD PTR [rbx+8], 15649			; 00003d21H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@6f55cd957ba3590f6f55cd957ba3590f
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, 8022544353138530575			; 6f55cd957ba3590fH
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_2>::operator(), COMDAT

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN21@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 379			; 0000017bH
	mov	DWORD PTR [rbx], 1231884053		; 496d0f15H
	mov	DWORD PTR [rbx+4], -1879768175		; 8ff50391H
	mov	BYTE PTR [rbx+8], 23
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'', COMDAT

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN42@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 379			; 0000017bH
	mov	DWORD PTR [rbx], 1231884053		; 496d0f15H
	mov	DWORD PTR [rbx+4], -1879768175		; 8ff50391H
	mov	BYTE PTR [rbx+8], 23
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN42@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+10], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN51@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@e3912dfd25097b7be3912dfd25097b7b
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN51@dynamic:
	mov	r9, -2048805790205510789		; e3912dfd25097b7bH
	npad	9
$LL50@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 10
	jb	SHORT $LL50@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+10], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_3>::operator(), COMDAT

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32315145		; 01ed1709H
	mov	DWORD PTR [rbx], 437478856		; 1a1365c8H
	mov	DWORD PTR [rbx+4], 1707624605		; 65c8489dH
	mov	WORD PTR [rbx+8], 25991			; 00006587H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'', COMDAT

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32315145		; 01ed1709H
	mov	DWORD PTR [rbx], 437478856		; 1a1365c8H
	mov	DWORD PTR [rbx+4], 1707624605		; 65c8489dH
	mov	WORD PTR [rbx+8], 25991			; 00006587H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@57fb21ed7b6501a957fb21ed7b6501a9
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, 6339698204315287977			; 57fb21ed7b6501a9H
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?SocketReady@Client@@QEBAHW4SocketTypes@@@Z
_TEXT	SEGMENT
this$ = 8
type$ = 16
?SocketReady@Client@@QEBAHW4SocketTypes@@@Z PROC	; Client::SocketReady, COMDAT

; 6    : 	BOOL socketReady = FALSE;

	xor	r8d, r8d

; 7    : 
; 8    : 	switch ( type ) {

	sub	edx, 1
	je	SHORT $LN4@SocketRead
	cmp	edx, 1
	jne	SHORT $LN7@SocketRead

; 11   : 		break;
; 12   : 	case TCP:
; 13   : 		socketReady = this->TCPSocket != INVALID_SOCKET;

	cmp	QWORD PTR [rcx+76], -1

; 14   : 		break;
; 15   : 	}
; 16   : 
; 17   : 	return socketReady == TRUE;
; 18   : }

	setne	r8b
	mov	eax, r8d
	ret	0
$LN4@SocketRead:

; 9    : 	case UDP:
; 10   : 		socketReady = this->UDPSocket != INVALID_SOCKET;

	cmp	QWORD PTR [rcx+68], -1

; 14   : 		break;
; 15   : 	}
; 16   : 
; 17   : 	return socketReady == TRUE;
; 18   : }

	setne	r8b
$LN7@SocketRead:
	mov	eax, r8d
	ret	0
?SocketReady@Client@@QEBAHW4SocketTypes@@@Z ENDP	; Client::SocketReady
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??0Client@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0Client@@QEAA@XZ PROC					; Client::Client, COMDAT

; 22   : Client::Client() {

$LN47:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	xorps	xmm0, xmm0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h

; 94   :     Server        ConnectedServer = {0};          // Information on the clients connected server

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	mov	DWORD PTR [rcx+32], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+36], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+52], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+60], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+36], al
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h

; 99   :     SOCKET        UDPSocket       = INVALID_SOCKET;

	mov	QWORD PTR [rcx+68], -1

; 100  :     SOCKET        TCPSocket       = INVALID_SOCKET;

	mov	QWORD PTR [rcx+76], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+84], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+100], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+108], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+84], al
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h

; 107  :     long          ClientUID       = -1;           

	mov	DWORD PTR [rcx+116], -1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 23   : 	NetCommon::LoadWSAFunctions();

	call	?LoadWSAFunctions@NetCommon@@YAXXZ	; NetCommon::LoadWSAFunctions
	npad	1

; 24   : }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0Client@@QEAA@XZ ENDP					; Client::Client
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0Client@@QEAA@XZ@4HA PROC			; `Client::Client'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 36					; 00000024H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0Client@@QEAA@XZ@4HA ENDP			; `Client::Client'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0Client@@QEAA@XZ@4HA PROC			; `Client::Client'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 84					; 00000054H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???0Client@@QEAA@XZ@4HA ENDP			; `Client::Client'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??1Client@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 80
??1Client@@QEAA@XZ PROC					; Client::~Client, COMDAT

; 26   : Client::~Client() {

$LN136:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rcx

; 13   : 		socketReady = this->TCPSocket != INVALID_SOCKET;

	mov	rcx, QWORD PTR [rcx+76]

; 14   : 		break;
; 15   : 	}
; 16   : 
; 17   : 	return socketReady == TRUE;

	cmp	rcx, -1

; 122  : 	if ( !SocketReady(TCP) )

	je	SHORT $LN6@Client

; 123  : 		return FALSE;
; 124  : 
; 125  : 	int status = CloseSocket(this->TCPSocket);

	call	QWORD PTR ?CloseSocket@@3P6AH_K@ZEA	; CloseSocket
$LN6@Client:

; 27   : 	this->Disconnect(); // disconnect incase the socket is still connected
; 28   : 
; 29   : 	CleanWSA();

	call	QWORD PTR ?CleanWSA@@3P6AHXZEA		; CleanWSA

; 30   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	mov	edx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax+rdx*8]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V34@A
	add	rbx, rcx
	test	al, 1
	jne	SHORT $LN131@Client
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 20655965		; 013b2f5dH
	mov	DWORD PTR [rbx], 1443442790		; 56093066H
	mov	DWORD PTR [rbx+4], -1522015854		; a547e192H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 30   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
$LN131@Client:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN25@Client

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 49			; 00000031H
	xor	BYTE PTR [rbx+1], 67			; 00000043H
	xor	BYTE PTR [rbx+2], 59			; 0000003bH
	xor	BYTE PTR [rbx+3], 9
	xor	BYTE PTR [rbx+4], -95			; ffffffffffffffa1H
	xor	BYTE PTR [rbx+5], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rbx+6], 105			; 00000069H
	xor	BYTE PTR [rbx+7], -63			; ffffffffffffffc1H
	xor	BYTE PTR [rbx+8], 49			; 00000031H
	xor	BYTE PTR [rbx+9], 67			; 00000043H
	xor	BYTE PTR [rbx+10], 59			; 0000003bH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN25@Client:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 30   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::FreeUsedLibrary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+108]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN49@Client

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi+84]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN63@Client

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN98@Client

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN63@Client:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN49@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	xor	ebx, ebx
	mov	QWORD PTR [rdi+100], rbx

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+108], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi+84], bl

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+60]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN87@Client

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi+36]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN101@Client

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN98@Client

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN101@Client:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN87@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+52], rbx

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+60], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi+36], bl
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 31   : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN98@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN133@Client:
??1Client@@QEAA@XZ ENDP					; Client::~Client
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ PROC ; `Client::~Client'::`2'::<lambda_1>::operator(), COMDAT

; 30   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V34@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 20655965		; 013b2f5dH
	mov	DWORD PTR [rbx], 1443442790		; 56093066H
	mov	DWORD PTR [rbx+4], -1522015854		; a547e192H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 30   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ ENDP ; `Client::~Client'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA PROC ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA ENDP ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ PROC ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V34@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	mov	BYTE PTR [rax+rdx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ ENDP ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?Connect@Client@@QEAAHXZ
_TEXT	SEGMENT
$T1 = 40
request$ = 88
__$ArrayPad$ = 136
this$ = 160
?Connect@Client@@QEAAHXZ PROC				; Client::Connect, COMDAT

; 34   : BOOL Client::Connect() {

$LN99:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx

; 35   : 
; 36   : 	// make request to udp server
; 37   : 	this->UDPSocket = CreateSocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	mov	rax, QWORD PTR ?CreateSocket@@3P6A_KHHH@ZEA ; CreateSocket
	mov	edx, 2
	mov	ecx, edx
	mov	r8d, 17
	call	rax
	mov	QWORD PTR [rbx+68], rax

; 38   : 	if ( this->UDPSocket == INVALID_SOCKET )

	cmp	rax, -1
	jne	SHORT $LN2@Connect

; 39   : 		return FALSE;

	xor	eax, eax
	jmp	$LN1@Connect
$LN2@Connect:
	xorps	xmm0, xmm0

; 40   : 
; 41   : 	ClientRequest request = {};

	movups	XMMWORD PTR request$[rsp], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR request$[rsp+16], xmm1

; 2651 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR request$[rsp+32], xmm0

; 2652 :         _My_data._Myres  = _Small_string_capacity;
; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR request$[rsp+16], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 42   : 	request.action = ClientRequest::Action::CONNECT_CLIENT;

	mov	DWORD PTR request$[rsp+4], 1048576	; 00100000H

; 43   : 	request.client = reinterpret_cast<void*>(this);

	mov	QWORD PTR request$[rsp+8], rbx
	mov	eax, DWORD PTR request$[rsp]
	mov	DWORD PTR $T1[rsp], eax
	mov	DWORD PTR $T1[rsp+4], 1048576		; 00100000H
	mov	QWORD PTR $T1[rsp+8], rbx
	lea	rdx, QWORD PTR request$[rsp+16]
	lea	rcx, QWORD PTR $T1[rsp+16]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 44   : 
; 45   : 	BOOL validServerResponse = UDPSendMessageToServer(request);

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ; Client::UDPSendMessageToServer

; 46   : 	if ( !validServerResponse )

	test	eax, eax
	je	SHORT $LN11@Connect

; 47   : 		return FALSE;  
; 48   : 
; 49   : 	// connect to tcp server
; 50   : 	this->TCPSocket = CreateSocket(AF_INET, SOCK_STREAM, 0);

	mov	rax, QWORD PTR ?CreateSocket@@3P6A_KHHH@ZEA ; CreateSocket
	xor	r8d, r8d
	mov	edi, 1
	mov	edx, edi
	mov	ecx, 2
	call	rax
	mov	QWORD PTR [rbx+76], rax

; 51   : 	if ( this->TCPSocket == INVALID_SOCKET )

	cmp	rax, -1
	je	SHORT $LN11@Connect

; 52   : 		return FALSE;
; 53   : 
; 54   : 	int connect = ConnectSocket(this->TCPSocket, ( sockaddr* ) &this->ConnectedServer.addr, sizeof(this->ConnectedServer.addr));

	mov	r9, QWORD PTR ?ConnectSocket@@3P6AH_KPEBUsockaddr@@H@ZEA ; ConnectSocket
	lea	rdx, QWORD PTR [rbx+20]
	mov	r8d, 16
	mov	rcx, rax
	call	r9

; 55   : 	if ( connect == SOCKET_ERROR )

	cmp	eax, -1
	je	SHORT $LN11@Connect

; 56   : 		return FALSE;
; 57   : 
; 58   : 	// set everything now that we are connected to tcp server
; 59   : 	CloseSocket(this->UDPSocket); // no longer needed

	mov	rcx, QWORD PTR [rbx+68]
	call	QWORD PTR ?CloseSocket@@3P6AH_K@ZEA	; CloseSocket

; 60   : 	this->UDPSocket = INVALID_SOCKET;

	mov	QWORD PTR [rbx+68], -1

; 62   : 	return TRUE;

	jmp	SHORT $LN12@Connect
$LN11@Connect:
	xor	edi, edi
$LN12@Connect:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR request$[rsp+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN73@Connect

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR request$[rsp+16]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN87@Connect

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN97@Connect
$LN87@Connect:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN73@Connect:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 62   : 	return TRUE;

	mov	eax, edi
$LN1@Connect:

; 63   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
$LN97@Connect:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN95@Connect:
?Connect@Client@@QEAAHXZ ENDP				; Client::Connect
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
request$ = 88
__$ArrayPad$ = 136
this$ = 160
?dtor$1@?0??Connect@Client@@QEAAHXZ@4HA PROC		; `Client::Connect'::`1'::dtor$1
	lea	rcx, QWORD PTR request$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$1@?0??Connect@Client@@QEAAHXZ@4HA ENDP		; `Client::Connect'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 104
$T4 = 136
req$GSCopy$ = 384
__$ReturnUdt$GSCopy$ = 384
blob$ = 400
__$ArrayPad$ = 656
this$ = 704
__$ReturnUdt$ = 712
req$ = 720
?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z PROC ; Client::EncryptClientRequest, COMDAT

; 65   : BYTESTRING Client::EncryptClientRequest(ClientRequest req) const {

$LN63:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 672				; 000002a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	mov	QWORD PTR req$GSCopy$[rsp], r8

; 66   : 	NET_BLOB blob = NetCommon::RequestToBlob(req, this->AESEncryptionKey);

	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR [rcx+36]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR $T2[rsp], eax
	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR $T2[rsp+4], eax
	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR $T2[rsp+8], rax
	lea	rdx, QWORD PTR [rdi+16]
	lea	rcx, QWORD PTR $T2[rsp+16]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	r8, rbx
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR blob$[rsp]
	call	?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UClientRequest@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; NetCommon::RequestToBlob
	npad	1
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rsi], xmm0
	mov	QWORD PTR [rsi+16], rax

; 67   : 	BYTESTRING buff = NetCommon::AESEncryptBlob(blob);

	lea	rdx, QWORD PTR blob$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0NET_BLOB@@QEAA@AEBU0@@Z
	mov	rdx, rax
	mov	rcx, rsi
	call	?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z ; NetCommon::AESEncryptBlob
	npad	1

; 69   : 	return buff;

	lea	rcx, QWORD PTR blob$[rsp]
	call	??1NET_BLOB@@QEAA@XZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN38@EncryptCli

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi+16]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN52@EncryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN49@EncryptCli

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN52@EncryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN38@EncryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi+16], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 69   : 	return buff;

	mov	rax, rsi

; 70   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 672				; 000002a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN49@EncryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN60@EncryptCli:
?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z ENDP ; Client::EncryptClientRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 104
$T4 = 136
req$GSCopy$ = 384
__$ReturnUdt$GSCopy$ = 384
blob$ = 400
__$ArrayPad$ = 656
this$ = 704
__$ReturnUdt$ = 712
req$ = 720
?dtor$0@?0??EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z@4HA PROC ; `Client::EncryptClientRequest'::`1'::dtor$0
	mov	rcx, QWORD PTR req$GSCopy$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$0@?0??EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z@4HA ENDP ; `Client::EncryptClientRequest'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 104
$T4 = 136
req$GSCopy$ = 384
__$ReturnUdt$GSCopy$ = 384
blob$ = 400
__$ArrayPad$ = 656
this$ = 704
__$ReturnUdt$ = 712
req$ = 720
?dtor$1@?0??EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z@4HA PROC ; `Client::EncryptClientRequest'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z@4HA ENDP ; `Client::EncryptClientRequest'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 104
$T4 = 136
req$GSCopy$ = 384
__$ReturnUdt$GSCopy$ = 384
blob$ = 400
__$ArrayPad$ = 656
this$ = 704
__$ReturnUdt$ = 712
req$ = 720
?dtor$3@?0??EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z@4HA PROC ; `Client::EncryptClientRequest'::`1'::dtor$3
	lea	rcx, QWORD PTR blob$[rdx]
	jmp	??1NET_BLOB@@QEAA@XZ
?dtor$3@?0??EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z@4HA ENDP ; `Client::EncryptClientRequest'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0NET_BLOB@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
??0NET_BLOB@@QEAA@AEBU0@@Z PROC				; NET_BLOB::NET_BLOB, COMDAT
$LN19:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rsi, rcx
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax
	add	rcx, 16
	add	rdx, 16
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rbx, QWORD PTR [rsi+48]
	mov	QWORD PTR $T1[rsp], rbx
	movzx	eax, BYTE PTR [rdi+48]
	mov	BYTE PTR [rbx], al
	mov	eax, DWORD PTR [rdi+56]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rdi+60]
	mov	DWORD PTR [rbx+12], eax
	mov	eax, DWORD PTR [rdi+64]
	mov	DWORD PTR [rbx+16], eax
	lea	rcx, QWORD PTR [rbx+24]
	lea	rdx, QWORD PTR [rdi+72]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+56]
	lea	rdx, QWORD PTR [rdi+104]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+88]
	lea	rdx, QWORD PTR [rdi+136]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rdi+168]
	mov	DWORD PTR [rbx+120], eax
	movups	xmm0, XMMWORD PTR [rdi+176]
	movups	XMMWORD PTR [rsi+176], xmm0
	movups	xmm1, XMMWORD PTR [rdi+192]
	movups	XMMWORD PTR [rsi+192], xmm1
	movsd	xmm0, QWORD PTR [rdi+208]
	movsd	QWORD PTR [rsi+208], xmm0
	lea	rcx, QWORD PTR [rsi+216]
	lea	rdx, QWORD PTR [rdi+216]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0NET_BLOB@@QEAA@AEBU0@@Z ENDP				; NET_BLOB::NET_BLOB
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
?dtor$0@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA PROC		; `NET_BLOB::NET_BLOB'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$0@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA ENDP		; `NET_BLOB::NET_BLOB'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
?dtor$4@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA PROC		; `NET_BLOB::NET_BLOB'::`1'::dtor$4
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1ProcessInformation@@QEAA@XZ
?dtor$4@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA ENDP		; `NET_BLOB::NET_BLOB'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
?dtor$5@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA PROC		; `NET_BLOB::NET_BLOB'::`1'::dtor$5
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA ENDP		; `NET_BLOB::NET_BLOB'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
?dtor$1@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA PROC		; `NET_BLOB::NET_BLOB'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1ServerCommand@@QEAA@XZ
?dtor$1@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA ENDP		; `NET_BLOB::NET_BLOB'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 56
$T3 = 80
req$GSCopy$ = 112
__$ReturnUdt$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 160
__$ReturnUdt$ = 168
req$ = 176
?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; Client::DecryptServerRequest, COMDAT

; 72   : ServerRequest Client::DecryptServerRequest(BYTESTRING req) {

$LN40:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	mov	QWORD PTR req$GSCopy$[rsp], r8
	xor	ebp, ebp

; 73   : 	return NetCommon::DecryptInternetData<ServerRequest>(req, this->AESEncryptionKey);

	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR [rcx+36]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	mov	r8, rbx
	mov	rdx, rax
	mov	rcx, rsi
	call	??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptInternetData<ServerCommand>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN12@DecryptSer

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN31@DecryptSer

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN28@DecryptSer

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN31@DecryptSer:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [rdi], rbp

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rbp

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rbp
$LN12@DecryptSer:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 73   : 	return NetCommon::DecryptInternetData<ServerRequest>(req, this->AESEncryptionKey);

	mov	rax, rsi

; 74   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 128				; 00000080H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN28@DecryptSer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN37@DecryptSer:
?DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; Client::DecryptServerRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 56
$T3 = 80
req$GSCopy$ = 112
__$ReturnUdt$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 160
__$ReturnUdt$ = 168
req$ = 176
?dtor$0@?0??DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `Client::DecryptServerRequest'::`1'::dtor$0
	mov	rcx, QWORD PTR req$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0??DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `Client::DecryptServerRequest'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 56
$T3 = 80
req$GSCopy$ = 112
__$ReturnUdt$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 160
__$ReturnUdt$ = 168
req$ = 176
?dtor$1@?0??DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `Client::DecryptServerRequest'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??DecryptServerRequest@Client@@QEAA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `Client::DecryptServerRequest'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ
_TEXT	SEGMENT
$T2 = 48
$T3 = 64
$T4 = 88
$T5 = 120
responseBuffer$ = 160
__$ArrayPad$ = 184
this$ = 208
__$ReturnUdt$ = 216
?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ PROC ; Client::UDPRecvMessageFromServer, COMDAT

; 76   : UDPResponse Client::UDPRecvMessageFromServer() {

$LN185:
	mov	r11, rsp
	mov	QWORD PTR [r11+24], rbx
	mov	QWORD PTR [r11+32], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rsi, rcx
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR [r11-40], xmm1
	xor	ebx, ebx
	mov	QWORD PTR [r11-24], rbx

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	edx, 1000				; 000003e8H
	lea	rcx, QWORD PTR [r11-40]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 80   : 	int received = ReceiveFrom(this->UDPSocket, reinterpret_cast< char* >( responseBuffer.data() ), sizeof(responseBuffer), 0, NULL, NULL);

	mov	rax, QWORD PTR ?ReceiveFrom@@3P6AH_KPEADHHPEAUsockaddr@@PEAH@ZEA ; ReceiveFrom
	mov	QWORD PTR [rsp+40], rbx
	mov	QWORD PTR [rsp+32], rbx
	xor	r9d, r9d
	mov	r8d, 24
	mov	rdx, QWORD PTR responseBuffer$[rsp]
	mov	rcx, QWORD PTR [rsi+68]
	call	rax

; 81   : 	if ( received == SOCKET_ERROR )

	cmp	eax, -1
	jne	SHORT $LN2@UDPRecvMes
	xorps	xmm0, xmm0

; 82   : 		return {};

	xor	eax, eax
	movups	XMMWORD PTR [rdi], xmm0
	movups	XMMWORD PTR [rdi+16], xmm0
	mov	QWORD PTR [rdi+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR responseBuffer$[rsp]
	test	rcx, rcx
	je	SHORT $LN158@UDPRecvMes

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR responseBuffer$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN172@UDPRecvMes

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN169@UDPRecvMes
$LN172@UDPRecvMes:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 88   : 	return response;

	call	??3@YAXPEAX_K@Z				; operator delete
$LN158@UDPRecvMes:
	mov	rax, rdi

; 89   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN2@UDPRecvMes:

; 83   : 
; 84   : 	// decrypt the udp response and cast it to UDPResponse
; 85   : 	UDPResponse response = NetCommon::DecryptInternetData<UDPResponse>(responseBuffer, this->AESEncryptionKey);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR [rsi+36]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	lea	rdx, QWORD PTR responseBuffer$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	mov	r8, rbx
	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptInternetData<UDPResponse>
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rdi+16], xmm1
	movsd	xmm0, QWORD PTR [rax+32]
	movsd	QWORD PTR [rdi+32], xmm0

; 86   : 	if ( response.isValid ) this->ConnectedServer = response.TCPServer;

	cmp	DWORD PTR [rdi+36], 0
	je	SHORT $LN3@UDPRecvMes
	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rsi], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rsi+16], xmm1
	mov	eax, DWORD PTR [rdi+32]
	mov	DWORD PTR [rsi+32], eax
$LN3@UDPRecvMes:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR responseBuffer$[rsp]
	test	rcx, rcx
	je	$LN158@UDPRecvMes

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR responseBuffer$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	$LN172@UDPRecvMes

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN172@UDPRecvMes
$LN169@UDPRecvMes:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN182@UDPRecvMes:
?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ ENDP ; Client::UDPRecvMessageFromServer
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 64
$T4 = 88
$T5 = 120
responseBuffer$ = 160
__$ArrayPad$ = 184
this$ = 208
__$ReturnUdt$ = 216
?dtor$0@?0??UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ@4HA PROC ; `Client::UDPRecvMessageFromServer'::`1'::dtor$0
	lea	rcx, QWORD PTR responseBuffer$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0??UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ@4HA ENDP ; `Client::UDPRecvMessageFromServer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 64
$T4 = 88
$T5 = 120
responseBuffer$ = 160
__$ArrayPad$ = 184
this$ = 208
__$ReturnUdt$ = 216
?dtor$1@?0??UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ@4HA PROC ; `Client::UDPRecvMessageFromServer'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ@4HA ENDP ; `Client::UDPRecvMessageFromServer'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
_TEXT	SEGMENT
$T1 = 56
$T2 = 104
message$GSCopy$ = 144
encrypted$ = 152
__$ArrayPad$ = 176
this$ = 208
message$ = 216
?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z PROC ; Client::UDPSendMessageToServer, COMDAT

; 91   : BOOL Client::UDPSendMessageToServer(ClientMessage message) {

$LN125:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rsi, rcx
	mov	QWORD PTR message$GSCopy$[rsp], rdx

; 17   : 	return socketReady == TRUE;

	cmp	QWORD PTR [rcx+68], -1

; 92   : 	if ( !SocketReady(UDP) )

	jne	SHORT $LN2@UDPSendMes
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN36@UDPSendMes

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN50@UDPSendMes

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN47@UDPSendMes

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN50@UDPSendMes:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN36@UDPSendMes:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	xor	edi, edi
	mov	QWORD PTR [rbx+32], rdi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], dil
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 93   : 		return FALSE;

	xor	eax, eax
	jmp	$LN1@UDPSendMes
$LN2@UDPSendMes:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR encrypted$[rsp], xmm0
	mov	QWORD PTR encrypted$[rsp+16], rax
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR $T1[rsp], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR $T1[rsp+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR $T1[rsp+8], rax
	add	rdx, 16
	lea	rcx, QWORD PTR $T1[rsp+16]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 94   : 
; 95   : 	BYTESTRING encrypted = EncryptClientRequest(message);

	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR encrypted$[rsp]
	mov	rcx, rsi
	call	?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z ; Client::EncryptClientRequest
	npad	1

; 96   : 
; 97   : 	int sent = SendTo(this->UDPSocket, reinterpret_cast<char*>(encrypted.data()), sizeof(encrypted.size()), 0, NULL, NULL);

	mov	rax, QWORD PTR ?SendTo@@3P6AH_KPEBDHHPEBUsockaddr@@H@ZEA ; SendTo
	xor	edi, edi
	mov	DWORD PTR [rsp+40], edi
	mov	QWORD PTR [rsp+32], rdi
	xor	r9d, r9d
	mov	r8d, 8
	mov	rdx, QWORD PTR encrypted$[rsp]
	mov	rcx, QWORD PTR [rsi+68]
	call	rax

; 98   : 	if ( sent == SOCKET_ERROR )

	cmp	eax, -1
	jne	SHORT $LN3@UDPSendMes
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR encrypted$[rsp]
	test	rcx, rcx
	je	SHORT $LN68@UDPSendMes

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR encrypted$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN87@UDPSendMes

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN122@UDPSendMes
$LN87@UDPSendMes:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR encrypted$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR encrypted$[rsp+16], rdi
$LN68@UDPSendMes:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 99   : 		return FALSE;

	mov	rcx, rbx
	call	??1ClientRequest@@QEAA@XZ
	xor	eax, eax
	jmp	SHORT $LN1@UDPSendMes
$LN3@UDPSendMes:

; 101  : 	return UDPRecvMessageFromServer().isValid;

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rsi
	call	?UDPRecvMessageFromServer@Client@@IEAA?AUUDPResponse@@XZ ; Client::UDPRecvMessageFromServer
	mov	esi, DWORD PTR [rax+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR encrypted$[rsp]
	test	rcx, rcx
	je	SHORT $LN96@UDPSendMes

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR encrypted$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN115@UDPSendMes

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN123@UDPSendMes
$LN115@UDPSendMes:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR encrypted$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR encrypted$[rsp+16], rdi
$LN96@UDPSendMes:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 101  : 	return UDPRecvMessageFromServer().isValid;

	mov	rcx, rbx
	call	??1ClientRequest@@QEAA@XZ
	mov	eax, esi
$LN1@UDPSendMes:

; 102  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN123@UDPSendMes:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN47@UDPSendMes:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN122@UDPSendMes:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN120@UDPSendMes:
?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ENDP ; Client::UDPSendMessageToServer
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 56
$T2 = 104
message$GSCopy$ = 144
encrypted$ = 152
__$ArrayPad$ = 176
this$ = 208
message$ = 216
?dtor$0@?0??UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA PROC ; `Client::UDPSendMessageToServer'::`1'::dtor$0
	mov	rcx, QWORD PTR message$GSCopy$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$0@?0??UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA ENDP ; `Client::UDPSendMessageToServer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 56
$T2 = 104
message$GSCopy$ = 144
encrypted$ = 152
__$ArrayPad$ = 176
this$ = 208
message$ = 216
?dtor$2@?0??UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA PROC ; `Client::UDPSendMessageToServer'::`1'::dtor$2
	lea	rcx, QWORD PTR encrypted$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0??UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA ENDP ; `Client::UDPSendMessageToServer'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
_TEXT	SEGMENT
$T1 = 40
message$GSCopy$ = 88
encryptedRequest$ = 96
__$ArrayPad$ = 120
this$ = 144
message$ = 152
?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z PROC ; Client::TCPSendMessageToServer, COMDAT

; 104  : BOOL Client::TCPSendMessageToServer(ClientMessage message) {

$LN126:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR message$GSCopy$[rsp], rdx

; 17   : 	return socketReady == TRUE;

	cmp	QWORD PTR [rcx+76], -1

; 105  : 	if ( !SocketReady(TCP) ) 

	jne	SHORT $LN2@TCPSendMes
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN36@TCPSendMes

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN50@TCPSendMes

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN47@TCPSendMes

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN50@TCPSendMes:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN36@TCPSendMes:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 106  : 		return FALSE;

	xor	eax, eax
	jmp	$LN1@TCPSendMes
$LN2@TCPSendMes:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR encryptedRequest$[rsp], xmm0
	mov	QWORD PTR encryptedRequest$[rsp+16], rax
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR $T1[rsp], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR $T1[rsp+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR $T1[rsp+8], rax
	add	rdx, 16
	lea	rcx, QWORD PTR $T1[rsp+16]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 107  : 
; 108  : 	BYTESTRING encryptedRequest = EncryptClientRequest(message);

	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR encryptedRequest$[rsp]
	mov	rcx, rdi
	call	?EncryptClientRequest@Client@@QEBA?AV?$vector@EV?$allocator@E@std@@@std@@UClientRequest@@@Z ; Client::EncryptClientRequest
	npad	1

; 110  : 	int sent = Send(this->TCPSocket, reinterpret_cast< char* >( encryptedRequest.data() ), encryptedRequest.size(), 0);

	mov	rax, QWORD PTR ?Send@@3P6AH_KPEBDHH@ZEA	; Send
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1873 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8d, DWORD PTR encryptedRequest$[rsp+8]
	mov	rdx, QWORD PTR encryptedRequest$[rsp]
	sub	r8d, edx
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 110  : 	int sent = Send(this->TCPSocket, reinterpret_cast< char* >( encryptedRequest.data() ), encryptedRequest.size(), 0);

	xor	r9d, r9d
	mov	rcx, QWORD PTR [rdi+76]
	call	rax
	npad	1

; 111  : 	if ( sent == SOCKET_ERROR )

	mov	rcx, QWORD PTR encryptedRequest$[rsp]
	cmp	eax, -1
	jne	SHORT $LN3@TCPSendMes
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN71@TCPSendMes

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR encryptedRequest$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN90@TCPSendMes

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN115@TCPSendMes
$LN90@TCPSendMes:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR encryptedRequest$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR encryptedRequest$[rsp+16], 0
$LN71@TCPSendMes:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 112  : 		return FALSE;

	mov	rcx, rbx
	call	??1ClientRequest@@QEAA@XZ
	xor	eax, eax
	jmp	SHORT $LN1@TCPSendMes
$LN3@TCPSendMes:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN99@TCPSendMes

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR encryptedRequest$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN118@TCPSendMes

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN115@TCPSendMes
$LN118@TCPSendMes:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR encryptedRequest$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR encryptedRequest$[rsp+16], 0
$LN99@TCPSendMes:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 114  : 	return TRUE;

	mov	rcx, rbx
	call	??1ClientRequest@@QEAA@XZ
	mov	eax, 1
$LN1@TCPSendMes:

; 115  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
$LN115@TCPSendMes:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN47@TCPSendMes:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN123@TCPSendMes:
?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ENDP ; Client::TCPSendMessageToServer
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
message$GSCopy$ = 88
encryptedRequest$ = 96
__$ArrayPad$ = 120
this$ = 144
message$ = 152
?dtor$0@?0??TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA PROC ; `Client::TCPSendMessageToServer'::`1'::dtor$0
	mov	rcx, QWORD PTR message$GSCopy$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$0@?0??TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA ENDP ; `Client::TCPSendMessageToServer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
message$GSCopy$ = 88
encryptedRequest$ = 96
__$ArrayPad$ = 120
this$ = 144
message$ = 152
?dtor$2@?0??TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA PROC ; `Client::TCPSendMessageToServer'::`1'::dtor$2
	lea	rcx, QWORD PTR encryptedRequest$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0??TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA ENDP ; `Client::TCPSendMessageToServer'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 88
request$GSCopy$ = 136
__$ArrayPad$ = 144
this$ = 176
request$ = 184
udp$ = 192
?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z PROC ; Client::MakeServerRequest, COMDAT

; 117  : BOOL Client::MakeServerRequest(ClientRequest request, BOOL udp) {

$LN62:
	mov	r11, rsp
	mov	QWORD PTR [r11+24], rbx
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR [r11-32], rdx

; 118  : 	return udp ? UDPSendMessageToServer(request) : TCPSendMessageToServer(request);

	mov	eax, DWORD PTR [rdx]
	test	r8d, r8d
	je	SHORT $LN3@MakeServer
	mov	DWORD PTR $T1[rsp], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR $T1[rsp+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [r11-120], rax
	add	rdx, 16
	lea	rcx, QWORD PTR [r11-112]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rdi
	call	?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ; Client::UDPSendMessageToServer
	jmp	SHORT $LN59@MakeServer
$LN3@MakeServer:
	mov	DWORD PTR $T2[rsp], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR $T2[rsp+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR $T2[rsp+8], rax
	add	rdx, 16
	lea	rcx, QWORD PTR $T2[rsp+16]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rdi
	call	?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ; Client::TCPSendMessageToServer
$LN59@MakeServer:
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN36@MakeServer

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN50@MakeServer

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN47@MakeServer

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN50@MakeServer:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN36@MakeServer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 118  : 	return udp ? UDPSendMessageToServer(request) : TCPSendMessageToServer(request);

	mov	eax, edi

; 119  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+192]
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
$LN47@MakeServer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN58@MakeServer:
?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z ENDP ; Client::MakeServerRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 88
request$GSCopy$ = 136
__$ArrayPad$ = 144
this$ = 176
request$ = 184
udp$ = 192
?dtor$0@?0??MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z@4HA PROC ; `Client::MakeServerRequest'::`1'::dtor$0
	mov	rcx, QWORD PTR request$GSCopy$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$0@?0??MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z@4HA ENDP ; `Client::MakeServerRequest'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?Disconnect@Client@@QEAAHXZ
_TEXT	SEGMENT
this$ = 48
?Disconnect@Client@@QEAAHXZ PROC			; Client::Disconnect, COMDAT

; 121  : BOOL Client::Disconnect() {

$LN14:
	sub	rsp, 40					; 00000028H

; 13   : 		socketReady = this->TCPSocket != INVALID_SOCKET;

	mov	rcx, QWORD PTR [rcx+76]

; 14   : 		break;
; 15   : 	}
; 16   : 
; 17   : 	return socketReady == TRUE;

	cmp	rcx, -1

; 122  : 	if ( !SocketReady(TCP) )

	je	SHORT $LN11@Disconnect

; 123  : 		return FALSE;
; 124  : 
; 125  : 	int status = CloseSocket(this->TCPSocket);

	mov	rax, QWORD PTR ?CloseSocket@@3P6AH_K@ZEA ; CloseSocket
	call	rax

; 126  : 	if ( status == SOCKET_ERROR ) {

	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	eax, ecx

; 128  : 	}
; 129  : 
; 130  : 	return TRUE;
; 131  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN11@Disconnect:

; 127  : 		return FALSE;

	xor	eax, eax

; 128  : 	}
; 129  : 
; 130  : 	return TRUE;
; 131  : }

	add	rsp, 40					; 00000028H
	ret	0
?Disconnect@Client@@QEAAHXZ ENDP			; Client::Disconnect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,-4509840863236766927,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 49			; 00000031H
	xor	BYTE PTR [rcx+1], 67			; 00000043H
	xor	BYTE PTR [rcx+2], 59			; 0000003bH
	xor	BYTE PTR [rcx+3], 9
	xor	BYTE PTR [rcx+4], -95			; ffffffffffffffa1H
	xor	BYTE PTR [rcx+5], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+6], 105			; 00000069H
	xor	BYTE PTR [rcx+7], -63			; ffffffffffffffc1H
	xor	BYTE PTR [rcx+8], 49			; 00000031H
	xor	BYTE PTR [rcx+9], 67			; 00000043H
	xor	BYTE PTR [rcx+10], 59			; 0000003bH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,-4509840863236766927,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,-4509840863236766927,char>::~obfuscated_data<11,-4509840863236766927,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,-4509840863236766927,char>::~obfuscated_data<11,-4509840863236766927,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@1@@Z PROC ; ay::obfuscated_data<11,-4509840863236766927,char>::obfuscated_data<11,-4509840863236766927,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@1@@Z ENDP ; ay::obfuscated_data<11,-4509840863236766927,char>::obfuscated_data<11,-4509840863236766927,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<13,6339698204315287977,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@57fb21ed7b6501a957fb21ed7b6501a9
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, 6339698204315287977			; 57fb21ed7b6501a9H
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<13,6339698204315287977,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<13,6339698204315287977,char>::~obfuscated_data<13,6339698204315287977,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<13,6339698204315287977,char>::~obfuscated_data<13,6339698204315287977,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0FHPLCBONHLGFABKJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0FHPLCBONHLGFABKJ@D@1@@Z PROC ; ay::obfuscated_data<13,6339698204315287977,char>::obfuscated_data<13,6339698204315287977,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+13], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0FHPLCBONHLGFABKJ@D@1@@Z ENDP ; ay::obfuscated_data<13,6339698204315287977,char>::obfuscated_data<13,6339698204315287977,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<10,-2048805790205510789,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+10], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@e3912dfd25097b7be3912dfd25097b7b
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, -2048805790205510789		; e3912dfd25097b7bH
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 10
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+10], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<10,-2048805790205510789,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<10,-2048805790205510789,char>::~obfuscated_data<10,-2048805790205510789,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<10,-2048805790205510789,char>::~obfuscated_data<10,-2048805790205510789,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$09$0?BMGONCACNKPGIEIF@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$09$0?BMGONCACNKPGIEIF@D@1@@Z PROC ; ay::obfuscated_data<10,-2048805790205510789,char>::obfuscated_data<10,-2048805790205510789,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+10], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$09$0?BMGONCACNKPGIEIF@D@1@@Z ENDP ; ay::obfuscated_data<10,-2048805790205510789,char>::obfuscated_data<10,-2048805790205510789,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<13,8022544353138530575,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@6f55cd957ba3590f6f55cd957ba3590f
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, 8022544353138530575			; 6f55cd957ba3590fH
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<13,8022544353138530575,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<13,8022544353138530575,char>::~obfuscated_data<13,8022544353138530575,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<13,8022544353138530575,char>::~obfuscated_data<13,8022544353138530575,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0GPFFMNJFHLKDFJAP@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0GPFFMNJFHLKDFJAP@D@1@@Z PROC ; ay::obfuscated_data<13,8022544353138530575,char>::obfuscated_data<13,8022544353138530575,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+13], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0GPFFMNJFHLKDFJAP@D@1@@Z ENDP ; ay::obfuscated_data<13,8022544353138530575,char>::obfuscated_data<13,8022544353138530575,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?decrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z
_TEXT	SEGMENT
this$ = 8
block$ = 16
?decrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z PROC	; Cipher::Aes<256>::decrypt_block, COMDAT

; 772  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 773  :             // load the current block & current round key into the registers
; 774  :             __m128i* xmm_round_keys = ( __m128i* ) round_keys;
; 775  :             __m128i state = _mm_loadu_si128(( __m128i* ) & block[0]);
; 776  : 
; 777  :             // first round
; 778  :             state = _mm_xor_si128(state, xmm_round_keys[Nr]);

	movdqu	xmm0, XMMWORD PTR [rdx]
	lea	rax, QWORD PTR [rcx+208]
	mov	r8d, 6
	movdqu	xmm2, XMMWORD PTR [rcx+224]
	xorps	xmm2, xmm0
	npad	4
$LL4@decrypt_bl:

; 779  : 
; 780  :             // usual rounds
; 781  :             for ( size_t i = Nr - 1; i > 1; i -= 2 ) {
; 782  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i]));

	aesimc	xmm0, XMMWORD PTR [rax]

; 783  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i - 1]));

	aesimc	xmm1, XMMWORD PTR [rax-16]
	lea	rax, QWORD PTR [rax-32]
	aesdec	xmm2, xmm0
	aesdec	xmm2, xmm1
	sub	r8, 1
	jne	SHORT $LL4@decrypt_bl

; 784  :             }
; 785  : 
; 786  :             // last round
; 787  :             state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[1]));

	aesimc	xmm0, XMMWORD PTR [rcx+16]
	aesdec	xmm2, xmm0

; 788  :             state = _mm_aesdeclast_si128(state, xmm_round_keys[0]);

	aesdeclast xmm2, XMMWORD PTR [rcx]

; 789  : 
; 790  :             // store from register to array
; 791  :             _mm_storeu_si128(( __m128i* ) block, state);

	movdqu	XMMWORD PTR [rdx], xmm2

; 792  : #elif defined(HARDWARE_ACCELERATION_ARM_NEON_AES)
; 793  :             uint8x16_t* neon_round_keys = ( uint8x16_t* ) round_keys;
; 794  :             uint8x16_t state = vld1q_u8(block);
; 795  : 
; 796  :             // Initial round
; 797  :             state = vaesimcq_u8(vaesdq_u8(state, neon_round_keys[Nr]));
; 798  : 
; 799  :             // 8 main rounds
; 800  :             for ( size_t i = Nr - 1; i > 1; i -= 2 ) {
; 801  :                 state = vaesimcq_u8(vaesdq_u8(state, vaesimcq_u8(neon_round_keys[i])));
; 802  :                 state = vaesimcq_u8(vaesdq_u8(state, vaesimcq_u8(neon_round_keys[i - 1])));
; 803  :             }
; 804  : 
; 805  :             // final 2 rounds
; 806  :             state = vaesdq_u8(state, vaesimcq_u8(neon_round_keys[1]));
; 807  :             state = veorq_u8(state, neon_round_keys[0]);
; 808  : 
; 809  :             // store the result to recover
; 810  :             vst1q_u8(block, state);
; 811  : #else
; 812  :             state_transpose(block);
; 813  : 
; 814  :             add_round_key(block, &round_keys[Nb * Nr * 4]);
; 815  : 
; 816  :             for ( size_t round = Nr - 1; round > 0; --round ) {
; 817  :                 inverse_sub_bytes(block);
; 818  :                 inverse_shift_rows(block);
; 819  :                 add_round_key(block, &round_keys[round * Nb * 4]);
; 820  :                 inverse_mix_columns(block);
; 821  :             }
; 822  : 
; 823  :             inverse_sub_bytes(block);
; 824  :             inverse_shift_rows(block);
; 825  :             add_round_key(block, &round_keys[0]);
; 826  : 
; 827  :             state_transpose(block);
; 828  : #endif
; 829  :         }

	ret	0
?decrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z ENDP	; Cipher::Aes<256>::decrypt_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ??1?$Aes@$0BAA@@Cipher@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$Aes@$0BAA@@Cipher@@QEAA@XZ PROC			; Cipher::Aes<256>::~Aes<256>, COMDAT

; 698  :             std::memset(round_keys, 0x00, round_keys_size);

	xor	edx, edx
	mov	r8d, 240				; 000000f0H
	jmp	memset
??1?$Aes@$0BAA@@Cipher@@QEAA@XZ ENDP			; Cipher::Aes<256>::~Aes<256>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z
_TEXT	SEGMENT
this$ = 48
key$ = 56
??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z PROC		; Cipher::Aes<256>::Aes<256>, COMDAT

; 608  :         Aes(unsigned char key[key_bits]) : round_keys() {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	r8d, 240				; 000000f0H
	xor	edx, edx
	mov	rdi, rcx
	call	memset

; 609  :             constexpr bool invalid_aes_key_bit_size = key_bits == 128 || key_bits == 192 || key_bits == 256;
; 610  :             static_assert( invalid_aes_key_bit_size, "The valid values are only: 128, 192 & 256" );
; 611  : 
; 612  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 613  :             if constexpr ( key_bits == 128 ) {
; 614  :                 AES_128_Key_Expansion(key, round_keys);
; 615  :             }
; 616  :             else if constexpr ( key_bits == 192 ) {
; 617  :                 AES_192_Key_Expansion(key, round_keys);
; 618  :             }
; 619  :             else if constexpr ( key_bits == 256 ) {
; 620  :                 AES_256_Key_Expansion(key, round_keys);

	mov	r8, rdi
	mov	rdx, rbx
	call	?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ; Cipher::Aes<256>::AES_256_Key_Expansion

; 621  :             }
; 622  : #elif defined(HARDWARE_ACCELERATION_ARM_NEON_AES)
; 623  :             // key expansion
; 624  :             unsigned char temp[4];
; 625  :             unsigned char rcon[4];
; 626  : 
; 627  :             size_t i = 0;
; 628  : 
; 629  :             while ( i < Nk * 4 ) {
; 630  :                 round_keys[i] = key[i];
; 631  :                 round_keys[i + 1] = key[i + 1];
; 632  :                 i += 2;
; 633  :             }
; 634  : 
; 635  :             while ( i < round_keys_size ) {
; 636  :                 temp[0] = round_keys[i - 4];
; 637  :                 temp[1] = round_keys[i - 4 + 1];
; 638  :                 temp[2] = round_keys[i - 4 + 2];
; 639  :                 temp[3] = round_keys[i - 4 + 3];
; 640  : 
; 641  :                 if ( i / 4 % Nk == 0 ) {
; 642  :                     rot_dword(temp);
; 643  :                     sub_dword(temp);
; 644  :                     rcon_n(rcon, i / ( Nk * 4 ));
; 645  :                     xor_dword(temp, rcon, temp);
; 646  :                 }
; 647  :                 else if ( Nk > 6 && i / 4 % Nk == 4 ) {
; 648  :                     sub_dword(temp);
; 649  :                 }
; 650  : 
; 651  :                 round_keys[i + 0] = round_keys[i - 4 * Nk] ^ temp[0];
; 652  :                 round_keys[i + 1] = round_keys[i + 1 - 4 * Nk] ^ temp[1];
; 653  :                 round_keys[i + 2] = round_keys[i + 2 - 4 * Nk] ^ temp[2];
; 654  :                 round_keys[i + 3] = round_keys[i + 3 - 4 * Nk] ^ temp[3];
; 655  : 
; 656  :                 i += 4;
; 657  :             }
; 658  : #else
; 659  :             // key expansion
; 660  :             unsigned char temp[4];
; 661  :             unsigned char rcon[4];
; 662  : 
; 663  :             size_t i = 0;
; 664  : 
; 665  :             while ( i < Nk * 4 ) {
; 666  :                 round_keys[i] = key[i];
; 667  :                 round_keys[i + 1] = key[i + 1];
; 668  :                 i += 2;
; 669  :             }
; 670  : 
; 671  :             while ( i < round_keys_size ) {
; 672  :                 temp[0] = round_keys[i - 4];
; 673  :                 temp[1] = round_keys[i - 4 + 1];
; 674  :                 temp[2] = round_keys[i - 4 + 2];
; 675  :                 temp[3] = round_keys[i - 4 + 3];
; 676  : 
; 677  :                 if ( i / 4 % Nk == 0 ) {
; 678  :                     rot_dword(temp);
; 679  :                     sub_dword(temp);
; 680  :                     rcon_n(rcon, i / ( Nk * 4 ));
; 681  :                     xor_dword(temp, rcon, temp);
; 682  :                 }
; 683  :                 else if ( Nk > 6 && i / 4 % Nk == 4 ) {
; 684  :                     sub_dword(temp);
; 685  :                 }
; 686  : 
; 687  :                 round_keys[i + 0] = round_keys[i - 4 * Nk] ^ temp[0];
; 688  :                 round_keys[i + 1] = round_keys[i + 1 - 4 * Nk] ^ temp[1];
; 689  :                 round_keys[i + 2] = round_keys[i + 2 - 4 * Nk] ^ temp[2];
; 690  :                 round_keys[i + 3] = round_keys[i + 3 - 4 * Nk] ^ temp[3];
; 691  : 
; 692  :                 i += 4;
; 693  :             }
; 694  : #endif
; 695  :         }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z ENDP		; Cipher::Aes<256>::Aes<256>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT

; 1872 :         auto& _My_data = _Mypair._Myval2;
; 1873 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]

; 1874 :     }

	ret	0
?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::data, COMDAT

; 1791 :         return _STD _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx]

; 1792 :     }

	ret	0
?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT

; 1584 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN40:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1551 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1584 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rbx, rdx

; 1551 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]

; 1584 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rdi, rcx

; 1551 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, rsi
	sub	rcx, rdx

; 1552 :         if (_Newsize < _Oldsize) { // trim

	cmp	rbx, rcx
	jae	SHORT $LN4@resize

; 1553 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rbx]

; 1554 :             _Orphan_range(_Newlast, _Mylast);
; 1555 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1556 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1557 :             _Mylast = _Newlast;
; 1558 :             return;

	jmp	SHORT $LN37@resize
$LN4@resize:

; 1559 :         }
; 1560 : 
; 1561 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1562 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rdx

; 1563 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rbx, rax
	jbe	SHORT $LN6@resize

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rbx
	mov	rcx, rdi

; 1587 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1565 :                 return;
; 1566 :             }
; 1567 : 
; 1568 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1569 :             const pointer _Oldlast = _Mylast;
; 1570 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1571 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1572 :             } else {
; 1573 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1574 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	mov	rcx, rsi
	call	memset

; 2014 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
$LN37@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1587 :     }

	mov	QWORD PTR [rdi+8], rax
$LN5@resize:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back, COMDAT

; 866  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	r8, rdx

; 775  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;
; 800  :         ++_Mylast;

	inc	QWORD PTR [rcx+8]

; 867  :         _Emplace_one_at_back(_Val);
; 868  :     }

	ret	0
$LN4@push_back:

; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 760  :     _CONSTEXPR20 ~vector() noexcept {

$LN35:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN5@vector

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@vector

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@vector

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@vector:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN5@vector:

; 766  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN32@vector:
??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 695  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 696  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 697  :     }

	mov	rax, rcx

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 695  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 696  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 697  :     }

	ret	0
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 677  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN111:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 677  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	r14, rdx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 677  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rsi, rcx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 678  :         const auto& _Right_data = _Right._Mypair._Myval2;
; 679  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]

; 2069 :         if (_Count != 0) {

	je	SHORT $LN72@vector

; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbx, rax
	ja	SHORT $LN108@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN25@vector

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN109@vector

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN35@vector

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN22@vector
$LN25@vector:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN22@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rsi], rdi

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rdi+rbx]
	mov	QWORD PTR [rsi+8], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	mov	QWORD PTR [rsi+16], rax

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1804 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rcx
$LN72@vector:

; 681  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN35@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN108@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN109@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN106@vector:
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 602  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 603  :     }

	mov	rax, rcx
	ret	0
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rdx, rcx

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN5@Unchecked_

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rcx]
$LN5@Unchecked_:

; 3987 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]
	add	rax, rdx

; 3988 :     }

	ret	0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN11@Unchecked_

; 3979 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3980 :     }

	ret	0
$LN11@Unchecked_:

; 3979 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 3980 :     }

	ret	0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3179 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 3179 :     _CONSTEXPR20 ~basic_string() noexcept {

	mov	rbx, rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN16@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN30@basic_stri

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN27@basic_stri

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN30@basic_stri:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN16@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 3187 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN27@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN39@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2559 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN117:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	esi, esi
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rsi

; 2559 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	r14, rdx

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rsi

; 2559 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	rdi, rcx

; 398  :             return __builtin_strlen(_First);

	mov	rbx, -1
	npad	1
$LL103@basic_stri:
	inc	rbx
	cmp	BYTE PTR [rdx+rbx], sil
	jne	SHORT $LL103@basic_stri

; 2672 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbx, rbp
	ja	$LN114@basic_stri

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	rbx, 15
	ja	SHORT $LN21@basic_stri

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rdi+rbx], sil

; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();
; 2699 :             return;

	jmp	$LN19@basic_stri
$LN21@basic_stri:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rbx
	or	rax, 15
	cmp	rax, rbp

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN31@basic_stri

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN62@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN61@basic_stri

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rsi, QWORD PTR [rax+39]
	and	rsi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rsi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN48@basic_stri
$LN31@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN48@basic_stri

; 197  :         return nullptr;
; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN51@basic_stri

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN115@basic_stri
	jmp	SHORT $LN62@basic_stri
$LN51@basic_stri:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
$LN48@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rdi], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rdi+16], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rsi

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2713 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rsi+rbx], 0
$LN19@basic_stri:

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2561 :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN61@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN115@basic_stri:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN114@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN112@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN123:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	r14, rdx

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rbx, rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN17@basic_stri

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdx]
$LN17@basic_stri:

; 2672 :         if (_Count > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rdi
	ja	$LN120@basic_stri

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	rsi, 15
	ja	SHORT $LN25@basic_stri

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rsi

; 2510 :     }

	mov	rax, rbx

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0

; 2510 :     }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN25@basic_stri:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rcx, rsi
	or	rcx, 15
	cmp	rcx, rdi

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN35@basic_stri

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN66@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN65@basic_stri

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN52@basic_stri
$LN35@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	edx, 22
	mov	rdi, rcx
	cmp	rcx, rdx
	cmovb	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rdi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN52@basic_stri

; 197  :         return nullptr;
; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN55@basic_stri

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN121@basic_stri
	jmp	SHORT $LN66@basic_stri
$LN55@basic_stri:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN52@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]
	mov	QWORD PTR [rbx], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2510 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN65@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN121@basic_stri:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN120@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN118@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2499 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	xorps	xmm0, xmm0

; 2500 :         _Construct_empty();
; 2501 :     }

	mov	rax, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 2500 :         _Construct_empty();
; 2501 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,-4509840863236766927,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 49			; 00000031H
	xor	BYTE PTR [rcx+1], 67			; 00000043H
	xor	BYTE PTR [rcx+2], 59			; 0000003bH
	xor	BYTE PTR [rcx+3], 9
	xor	BYTE PTR [rcx+4], -95			; ffffffffffffffa1H
	xor	BYTE PTR [rcx+5], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+6], 105			; 00000069H
	xor	BYTE PTR [rcx+7], -63			; ffffffffffffffc1H
	xor	BYTE PTR [rcx+8], 49			; 00000031H
	xor	BYTE PTR [rcx+9], 67			; 00000043H
	xor	BYTE PTR [rcx+10], 59			; 0000003bH

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,-4509840863236766927,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,-4509840863236766927,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,-4509840863236766927,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<13,6339698204315287977,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@57fb21ed7b6501a957fb21ed7b6501a9
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, 6339698204315287977			; 57fb21ed7b6501a9H
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<13,6339698204315287977,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<13,6339698204315287977,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0N@$0FHPLCBONHLGFABKJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<13,6339698204315287977,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<10,-2048805790205510789,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+10], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@e3912dfd25097b7be3912dfd25097b7b
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, -2048805790205510789		; e3912dfd25097b7bH
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 10
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+10], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<10,-2048805790205510789,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$09$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$09$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<10,-2048805790205510789,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$09$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<10,-2048805790205510789,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<13,8022544353138530575,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@6f55cd957ba3590f6f55cd957ba3590f
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, 8022544353138530575			; 6f55cd957ba3590fH
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<13,8022544353138530575,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<13,8022544353138530575,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<13,8022544353138530575,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z
_TEXT	SEGMENT
this$dead$ = 8
user_key$ = 16
key$ = 24
?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z PROC ; Cipher::Aes<256>::AES_256_Key_Expansion, COMDAT

; 218  :             __m128i tmp1, tmp2, tmp3;
; 219  :             __m128i* key_sched = ( __m128i* ) key;
; 220  :             tmp1 = _mm_loadu_si128(( __m128i* ) user_key);
; 221  :             tmp3 = _mm_loadu_si128(( __m128i* ) ( user_key + 16 ));

	movdqu	xmm3, XMMWORD PTR [rdx+16]
	movdqu	xmm0, XMMWORD PTR [rdx]

; 223  :             key_sched[1] = tmp3;

	movdqu	XMMWORD PTR [r8+16], xmm3

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm2, xmm0

; 222  :             key_sched[0] = tmp1;

	movdqu	XMMWORD PTR [r8], xmm0

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	pslldq	xmm2, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm1, xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm2, 4
	xorps	xmm1, xmm0

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm4, xmm2
	xorps	xmm4, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm2, 4

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm4, xmm2

; 224  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x01);

	aeskeygenassist xmm0, xmm3, 1

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm4, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm3
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 225  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 226  :             key_sched[2] = tmp1;

	movdqu	XMMWORD PTR [r8+32], xmm4

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm4, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm4
	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 227  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 228  :             key_sched[3] = tmp3;

	movdqu	XMMWORD PTR [r8+48], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm4

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm3, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm3, xmm1

; 229  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x02);

	aeskeygenassist xmm0, xmm2, 2

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm3, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 230  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 231  :             key_sched[4] = tmp1;

	movdqu	XMMWORD PTR [r8+64], xmm3

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm0, xmm2

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm3, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm3
	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 232  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 233  :             key_sched[5] = tmp3;

	movdqu	XMMWORD PTR [r8+80], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm3, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm3, xmm1

; 234  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x04);

	aeskeygenassist xmm0, xmm2, 4

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm3, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 235  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 236  :             key_sched[6] = tmp1;

	movdqu	XMMWORD PTR [r8+96], xmm3

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm0, xmm2

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm3, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm3

; 237  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 238  :             key_sched[7] = tmp3;

	movdqu	XMMWORD PTR [r8+112], xmm2

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm3, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm3, xmm1

; 239  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x08);

	aeskeygenassist xmm0, xmm2, 8

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm3, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 240  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 241  :             key_sched[8] = tmp1;

	movdqu	XMMWORD PTR [r8+128], xmm3

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm2

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm3, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm3
	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 242  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 243  :             key_sched[9] = tmp3;

	movdqu	XMMWORD PTR [r8+144], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm3, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm3, xmm1

; 244  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x10);

	aeskeygenassist xmm0, xmm2, 16

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm3, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 245  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 246  :             key_sched[10] = tmp1;

	movdqu	XMMWORD PTR [r8+160], xmm3

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm2

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm3, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm3
	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 247  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 248  :             key_sched[11] = tmp3;

	movdqu	XMMWORD PTR [r8+176], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm4, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm4, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm4, xmm1

; 249  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x20);

	aeskeygenassist xmm0, xmm2, 32			; 00000020H

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm4, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 250  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 251  :             key_sched[12] = tmp1;

	movdqu	XMMWORD PTR [r8+192], xmm4

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm2

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm3, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm3, xmm1
	aeskeygenassist xmm0, xmm4, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm3, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm4
	pslldq	xmm1, 4

; 252  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 253  :             key_sched[13] = tmp3;

	movdqu	XMMWORD PTR [r8+208], xmm3

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm2, xmm1
	xorps	xmm0, xmm4
	xorps	xmm2, xmm0

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm2, xmm1

; 254  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x40);

	aeskeygenassist xmm0, xmm3, 64			; 00000040H

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm2, xmm1

; 255  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 256  :             key_sched[14] = tmp1;

	movdqu	XMMWORD PTR [r8+224], xmm2

; 257  :         }

	ret	0
?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ENDP ; Cipher::Aes<256>::AES_256_Key_Expansion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT

; 2189 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2190 :     }

	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT

; 2039 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2040 :         auto& _Al         = _Getal();
; 2041 :         auto& _My_data    = _Mypair._Myval2;
; 2042 :         pointer& _Myfirst = _My_data._Myfirst;
; 2043 :         pointer& _Mylast  = _My_data._Mylast;
; 2044 :         pointer& _Myend   = _My_data._Myend;
; 2045 : 
; 2046 :         _My_data._Orphan_all();
; 2047 : 
; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN21@Tidy

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN18@Tidy

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN21@Tidy:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2057 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN28@Tidy:
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction, COMDAT

; 718  :         return _Al;

	mov	rax, rcx

; 719  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4896 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4897 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4892 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4893 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 4865 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 4865 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	mov	rbx, rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 4866 :         auto& _My_data = _Mypair._Myval2;
; 4867 :         _My_data._Orphan_all();
; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN13@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Tidy_deall

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@Tidy_deall

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@Tidy_deall:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 4879 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN35@Tidy_deall:
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 2647 :         auto& _My_data = _Mypair._Myval2;
; 2648 :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2649 : 
; 2650 :         // initialize basic_string data members
; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 2657 :     }

	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2235 :         const value_type* _Result = _Bx._Buf;
; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@Myptr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2241 :     }

	ret	0
$LN8@Myptr:

; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

	mov	rax, rcx

; 2241 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2226 :         value_type* _Result = _Bx._Buf;
; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@Myptr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2232 :     }

	ret	0
$LN8@Myptr:

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, rcx

; 2232 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 718  :         return _Al;

	mov	rax, rcx

; 719  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 386  :         // find length of null-terminated string
; 387  : #if _HAS_CXX17
; 388  : #ifdef __cpp_char8_t
; 389  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 390  : #if _HAS_U8_INTRINSICS
; 391  :             return __builtin_u8strlen(_First);
; 392  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 393  :             return _Primary_char_traits::length(_First);
; 394  : #endif // ^^^ no u8 intrinsics ^^^
; 395  :         } else
; 396  : #endif // defined(__cpp_char8_t)
; 397  :         {
; 398  :             return __builtin_strlen(_First);

	mov	rax, -1
$LL4@length:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL4@length

; 399  :         }
; 400  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 401  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 402  : #endif // ^^^ !_HAS_CXX17 ^^^
; 403  :     }

	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 73   :     // return larger of _Left and _Right
; 74   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 75   : }

	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?KEY_256_ASSIST_2@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
tmp1$ = 16
tmp3$ = 24
?KEY_256_ASSIST_2@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z PROC ; Cipher::Aes<256>::KEY_256_ASSIST_2, COMDAT

; 205  :             __m128i tmp2, tmp4;
; 206  :             tmp4 = _mm_aeskeygenassist_si128(*tmp1, 0x0);
; 207  :             tmp2 = _mm_shuffle_epi32(tmp4, 0xaa);
; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqu	xmm2, XMMWORD PTR [r8]
	movdqa	xmm0, xmm2
	pslldq	xmm0, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm0

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm0, 4

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm0

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm0, 4

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm0
	aeskeygenassist xmm0, XMMWORD PTR [rdx], 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1
	movdqu	XMMWORD PTR [r8], xmm2

; 215  :         }

	ret	0
?KEY_256_ASSIST_2@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z ENDP ; Cipher::Aes<256>::KEY_256_ASSIST_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?KEY_256_ASSIST_1@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
tmp1$ = 16
tmp2$ = 24
?KEY_256_ASSIST_1@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z PROC ; Cipher::Aes<256>::KEY_256_ASSIST_1, COMDAT

; 193  :             __m128i tmp4;
; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);
; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqu	xmm1, XMMWORD PTR [rdx]
	pshufd	xmm2, XMMWORD PTR [r8], 255		; 000000ffH
	movdqa	xmm0, xmm1
	pslldq	xmm0, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm1, xmm0
	movdqu	XMMWORD PTR [r8], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm0, 4

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm1, xmm0

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm0, 4

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm1, xmm0

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm1, xmm2
	movdqu	XMMWORD PTR [rdx], xmm1

; 202  :         }

	ret	0
?KEY_256_ASSIST_1@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z ENDP ; Cipher::Aes<256>::KEY_256_ASSIST_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z PROC	; std::allocator<unsigned char>::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 951  :     }

	add	rsp, 40					; 00000028H

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ENDP	; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 2641 :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN27:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 2642 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r8+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN17@Deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN20@Deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2644 :     }

	add	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN17@Deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN24@Deallocate:
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }

	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15
	seta	al

; 2245 :     }

	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             return _Primary_char_traits::assign(_Left, _Right);
; 442  :         }
; 443  : #endif // _HAS_CXX20
; 444  :         _Left = _Right;
; 445  :     }

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	rax, rbx

; 68   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 951  :     }

	add	rsp, 40					; 00000028H

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 181  : #if _HAS_CXX20
; 182  :         if (_STD is_constant_evaluated()) {
; 183  :             _STD construct_at(_STD addressof(_Left), _Right);
; 184  :         } else
; 185  : #endif // _HAS_CXX20
; 186  :         {
; 187  :             _Left = _Right;
; 188  :         }
; 189  :     }

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	ret	0
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 56
string$GSCopy$ = 88
aesKey$GSCopy$ = 96
__$ArrayPad$ = 104
__$ReturnUdt$ = 160
string$ = 168
aesKey$ = 176
??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; NetCommon::DecryptInternetData<ServerCommand>, COMDAT

; 93   :     inline Data DecryptInternetData(BYTESTRING string, std::string aesKey) {

$LN85:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	r14, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR string$GSCopy$[rsp], rdx
	mov	QWORD PTR aesKey$GSCopy$[rsp], r8
	xor	ebp, ebp

; 94   :         DecryptByteString(string, aesKey);

	mov	rdx, r8
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rsi
	call	?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptByteString

; 95   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rbx, QWORD PTR [rsi]
	movzx	eax, BYTE PTR [rbx]
	mov	BYTE PTR [r14], al
	mov	eax, DWORD PTR [rbx+8]
	mov	DWORD PTR [r14+8], eax
	mov	eax, DWORD PTR [rbx+12]
	mov	DWORD PTR [r14+12], eax
	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR [r14+16], eax
	lea	rcx, QWORD PTR [r14+24]
	lea	rdx, QWORD PTR [rbx+24]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [r14+56]
	lea	rdx, QWORD PTR [rbx+56]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [r14+88]
	lea	rdx, QWORD PTR [rbx+88]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rbx+120]
	mov	DWORD PTR [r14+120], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN20@DecryptInt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN39@DecryptInt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN36@DecryptInt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN39@DecryptInt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [rsi], rbp

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rbp

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rbp
$LN20@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN62@DecryptInt

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN76@DecryptInt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN73@DecryptInt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN76@DecryptInt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN62@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbp

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 95   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rax, r14

; 96   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN36@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN73@DecryptInt:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN82@DecryptInt:
??$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; NetCommon::DecryptInternetData<ServerCommand>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 56
string$GSCopy$ = 88
aesKey$GSCopy$ = 96
__$ArrayPad$ = 104
__$ReturnUdt$ = 160
string$ = 168
aesKey$ = 176
?dtor$0@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<ServerCommand>'::`1'::dtor$0
	mov	rcx, QWORD PTR aesKey$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<ServerCommand>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 56
string$GSCopy$ = 88
aesKey$GSCopy$ = 96
__$ArrayPad$ = 104
__$ReturnUdt$ = 160
string$ = 168
aesKey$ = 176
?dtor$1@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<ServerCommand>'::`1'::dtor$1
	mov	rcx, QWORD PTR string$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<ServerCommand>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 56
string$GSCopy$ = 88
aesKey$GSCopy$ = 96
__$ArrayPad$ = 104
__$ReturnUdt$ = 160
string$ = 168
aesKey$ = 176
?dtor$4@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<ServerCommand>'::`1'::dtor$4
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rdx]
	add	rcx, 8
	jmp	??1ProcessInformation@@QEAA@XZ
?dtor$4@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<ServerCommand>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 56
string$GSCopy$ = 88
aesKey$GSCopy$ = 96
__$ArrayPad$ = 104
__$ReturnUdt$ = 160
string$ = 168
aesKey$ = 176
?dtor$5@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<ServerCommand>'::`1'::dtor$5
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???$DecryptInternetData@UServerCommand@@@NetCommon@@YA?AUServerCommand@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<ServerCommand>'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
_TEXT	SEGMENT
$T1 = 40
string$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnAddress$ = 128
string$ = 136
aesKey$ = 144
??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; NetCommon::DecryptInternetData<UDPResponse>, COMDAT

; 93   :     inline Data DecryptInternetData(BYTESTRING string, std::string aesKey) {

$LN75:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx
	mov	QWORD PTR string$GSCopy$[rsp], rdx
	mov	QWORD PTR aesKey$GSCopy$[rsp], rbx

; 94   :         DecryptByteString(string, aesKey);

	mov	rdx, r8
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rdi
	call	?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptByteString

; 95   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rcx, QWORD PTR [rdi]
	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rsi], xmm0
	movups	xmm1, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR [rsi+16], xmm1
	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [rsi+32], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	xor	ebp, ebp
	test	rcx, rcx
	je	SHORT $LN10@DecryptInt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN29@DecryptInt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN26@DecryptInt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN29@DecryptInt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [rdi], rbp

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rbp

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rbp
$LN10@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN52@DecryptInt

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN66@DecryptInt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN63@DecryptInt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN66@DecryptInt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN52@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rbp

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 95   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rax, rsi

; 96   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN26@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN63@DecryptInt:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN72@DecryptInt:
??$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; NetCommon::DecryptInternetData<UDPResponse>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
string$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnAddress$ = 128
string$ = 136
aesKey$ = 144
?dtor$0@?0???$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<UDPResponse>'::`1'::dtor$0
	mov	rcx, QWORD PTR aesKey$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<UDPResponse>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
string$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnAddress$ = 128
string$ = 136
aesKey$ = 144
?dtor$1@?0???$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<UDPResponse>'::`1'::dtor$1
	mov	rcx, QWORD PTR string$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???$DecryptInternetData@UUDPResponse@@@NetCommon@@YA?AUUDPResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<UDPResponse>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z PROC		; std::_Unfancy_maybe_null<unsigned char>, COMDAT

; 47   :     return _Ptr;

	mov	rax, rcx

; 48   : }

	ret	0
??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z ENDP		; std::_Unfancy_maybe_null<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>, COMDAT

; 1545 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1546 :         // trim or append elements, provide strong guarantee
; 1547 :         auto& _Al           = _Getal();
; 1548 :         auto& _My_data      = _Mypair._Myval2;
; 1549 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1550 :         pointer& _Mylast    = _My_data._Mylast;
; 1551 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rbx, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rdi, rcx
	mov	rcx, rsi
	sub	rcx, rdx

; 1552 :         if (_Newsize < _Oldsize) { // trim

	cmp	rbx, rcx
	jae	SHORT $LN2@Resize

; 1553 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rbx]

; 1554 :             _Orphan_range(_Newlast, _Mylast);
; 1555 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1556 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1557 :             _Mylast = _Newlast;
; 1558 :             return;

	jmp	SHORT $LN35@Resize
$LN2@Resize:

; 1559 :         }
; 1560 : 
; 1561 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1562 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rdx

; 1563 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rbx, rax
	jbe	SHORT $LN4@Resize

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rbx
	mov	rcx, rdi

; 1581 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1565 :                 return;
; 1566 :             }
; 1567 : 
; 1568 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1569 :             const pointer _Oldlast = _Mylast;
; 1570 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1571 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1572 :             } else {
; 1573 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1574 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	mov	rcx, rsi
	call	memset

; 2014 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
$LN35@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1581 :     }

	mov	QWORD PTR [rdi+8], rax
$LN3@Resize:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>, COMDAT

; 770  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	r8, rdx

; 771  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 772  :         auto& _My_data   = _Mypair._Myval2;
; 773  :         pointer& _Mylast = _My_data._Mylast;
; 774  : 
; 775  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 800  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rcx+8], rdx

; 780  :     }

	ret	0
$LN2@Emplace_on:

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z PROC ; std::move<std::allocator<unsigned char> &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ENDP ; std::move<std::allocator<unsigned char> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z PROC	; std::exchange<unsigned char *,std::nullptr_t>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ENDP	; std::exchange<unsigned char *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>, COMDAT

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char * const &,unsigned char * const &>, COMDAT

; 2060 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN104:

; 2061 :         // Dispatches between the three sized constructions.
; 2062 :         // 1-arg -> value-construction, e.g. vector(5)
; 2063 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2064 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2065 :         auto& _Al       = _Getal();
; 2066 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2067 :         auto& _My_data  = _Mypair._Myval2;
; 2068 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2069 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN99@Construct_
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 2060 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r15, r9
	mov	r14, r8
	mov	rbx, rdx
	mov	rsi, rcx

; 2010 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN101@Construct_
	mov	QWORD PTR [rsp+32], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@Construct_

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN102@Construct_

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Construct_

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN14@Construct_
$LN17@Construct_:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN14@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rsi], rdi

; 1995 :         _Mylast               = _Newvec;
; 1996 :         _Myend                = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rdi]
	mov	QWORD PTR [rsi+8], rdi
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1804 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rbx+rdi]
	mov	rdi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rax

; 2087 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
$LN99@Construct_:
	ret	0
$LN27@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN101@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN102@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN98@Construct_:
??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char * const &,unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1086 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1087 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1088 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1089 : 
; 1090 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1091 :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 1092 :             _Xlength_error("size is too long for _Size_type");
; 1093 :         }
; 1094 :     }
; 1095 : 
; 1096 :     return static_cast<_Size_type>(_Len);

	mov	rax, rcx

; 1097 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
this$ = 80
_Arg$ = 88
_Count$ = 96
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 2662 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN97:
	push	rbx
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 40					; 00000028H

; 2663 :         auto& _My_data = _Mypair._Myval2;
; 2664 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2665 : 
; 2666 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2667 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2668 :         } else {
; 2669 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2670 :         }
; 2671 : 
; 2672 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	mov	rbx, r8
	mov	r14, rdx
	mov	rsi, rcx
	cmp	r8, rbp
	ja	$LN94@Construct

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	rbx, 15
	ja	SHORT $LN3@Construct

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2683 : 
; 2684 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2685 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2688 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rbx+rsi], 0

; 2714 :         } else { // _Strat == _Construct_strategy::_From_string
; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN3@Construct:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rbx
	mov	QWORD PTR [rsp+32], rdi
	or	rax, 15
	cmp	rax, rbp

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN13@Construct

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN44@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN43@Construct

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN30@Construct
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN31@Construct

; 197  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN30@Construct
$LN31@Construct:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN33@Construct

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN95@Construct
	jmp	SHORT $LN44@Construct
$LN33@Construct:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN30@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();
; 2699 :             return;
; 2700 :         }
; 2701 : 
; 2702 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());
; 2703 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2705 : 
; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rdi

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2708 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2711 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2713 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0
	mov	rdi, QWORD PTR [rsp+32]

; 2714 :         } else { // _Strat == _Construct_strategy::_From_string
; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN43@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN95@Construct:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN94@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN92@Construct:
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
this$ = 64
_Arg$ = 72
_Count$ = 80
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 2662 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN99:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2663 :         auto& _My_data = _Mypair._Myval2;
; 2664 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2665 : 
; 2666 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2667 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2668 :         } else {
; 2669 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2670 :         }
; 2671 : 
; 2672 :         if (_Count > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rsi, r8
	mov	rbp, rdx
	mov	rdi, rcx
	cmp	r8, rbx
	ja	$LN96@Construct

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	r8, 15
	ja	SHORT $LN3@Construct

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rsi
	or	rax, 15
	cmp	rax, rbx

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN13@Construct

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN44@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN43@Construct

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN30@Construct
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbx, rax
	cmp	rax, rcx
	cmovb	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN31@Construct

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN30@Construct
$LN31@Construct:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN33@Construct

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN97@Construct
	jmp	SHORT $LN44@Construct
$LN33@Construct:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN30@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]
	mov	QWORD PTR [rdi], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbp

; 2683 : 
; 2684 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2685 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2688 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();
; 2699 :             return;
; 2700 :         }
; 2701 : 
; 2702 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());
; 2703 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 2705 : 
; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rdi+16], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx

; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
$LN43@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN97@Construct:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN96@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN94@Construct:
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 1064 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1065 :     using _Ty = typename _Alloc::value_type;
; 1066 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1067 :         for (; _First != _Last; ++_First) {
; 1068 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1069 :         }
; 1070 :     }
; 1071 : }

	ret	0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 36   :     return _Ptr;

	mov	rax, rcx

; 37   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 230  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN20:
	sub	rsp, 40					; 00000028H

; 231  :     // deallocate storage allocated by _Allocate
; 232  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         ::operator delete(_Ptr);
; 235  :         return;
; 236  :     }
; 237  : #endif // _HAS_CXX20
; 238  : 
; 239  : #ifdef __cpp_aligned_new
; 240  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 241  :         size_t _Passed_align = _Align;
; 242  : #if defined(_M_IX86) || defined(_M_X64)
; 243  :         if (_Bytes >= _Big_allocation_threshold) {
; 244  :             // boost the alignment of big allocations to help autovectorization
; 245  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 246  :         }
; 247  : #endif // defined(_M_IX86) || defined(_M_X64)
; 248  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 249  :     } else
; 250  : #endif // defined(__cpp_aligned_new)
; 251  :     {
; 252  : #if defined(_M_IX86) || defined(_M_X64)
; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@Deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN12@Deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN15@Deallocate:

; 259  :     }
; 260  : }

	add	rsp, 40					; 00000028H

; 254  :             // boost the alignment of big allocations to help autovectorization
; 255  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 256  :         }
; 257  : #endif // defined(_M_IX86) || defined(_M_X64)
; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@Deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN17@Deallocate:
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 290  :     if constexpr (is_array_v<_Ty>) {
; 291  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 292  :     } else {
; 293  :         _Obj.~_Ty();
; 294  :     }
; 295  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z PROC	; std::construct_at<char,char const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z ENDP	; std::construct_at<char,char const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >, COMDAT

; 53   :     _CONSTEXPR20 ~_Tidy_guard() {

$LN37:
	push	rbx
	sub	rsp, 32					; 00000020H

; 54   :         if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN6@Tidy_guard
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN6@Tidy_guard

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@Tidy_guard

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@Tidy_guard

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@Tidy_guard:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN6@Tidy_guard:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 57   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@Tidy_guard:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN34@Tidy_guard:
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT

; 2181 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero, COMDAT

; 1999 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2000 :         // allocate array with _Newcapacity elements
; 2001 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2002 :         auto& _My_data    = _Mypair._Myval2;
; 2003 :         pointer& _Myfirst = _My_data._Myfirst;
; 2004 :         pointer& _Mylast  = _My_data._Mylast;
; 2005 :         pointer& _Myend   = _My_data._Myend;
; 2006 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2007 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2008 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2009 : 
; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN44@Buy_nonzer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN11@Buy_nonzer

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN10@Buy_nonzer
$LN11@Buy_nonzer:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN13@Buy_nonzer

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN45@Buy_nonzer

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN23@Buy_nonzer

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN10@Buy_nonzer
$LN13@Buy_nonzer:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN10@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rax, rbx

; 2015 :     }

	mov	rbx, QWORD PTR [rsp+64]

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rax

; 2015 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN44@Buy_nonzer:

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN45@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN23@Buy_nonzer:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN42@Buy_nonzer:
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@E@std@@QEAA@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT

; 939  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@E@std@@QEAA@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Requested$ = 8
_Old$ = 16
_Max$ = 24
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rcx, 15
	cmp	rcx, r8

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN9@Calculate_

; 4765 :             return _Max;
; 4766 :         }
; 4767 : 
; 4768 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r9, rdx
	mov	rax, r8
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN9@Calculate_

; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r9+rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rax
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	rax, rcx

; 4773 :     }

	ret	0
$LN9@Calculate_:

; 4769 :             return _Max;

	mov	rax, r8

; 4773 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 4171 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 4172 :         const size_type _Storage_max = // can always store small string
; 4173 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4174 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 4175 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4176 :         );
; 4177 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 939  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 2141 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2142 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlength:
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw, COMDAT

; 1983 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN8@Buy_raw

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN7@Buy_raw
$LN8@Buy_raw:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN10@Buy_raw

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN39@Buy_raw

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@Buy_raw

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN7@Buy_raw
$LN10@Buy_raw:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN7@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rax, rbx

; 1997 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN39@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN20@Buy_raw:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN37@Buy_raw:
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT

; 1877 :         return (_STD min)(

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1878 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1879 :     }

	ret	0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	xorps	xmm0, xmm0
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBD@std@@YAAEBDAEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBD@std@@YAAEBDAEBD@Z PROC			; std::forward<char const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBD@std@@YAAEBDAEBD@Z ENDP			; std::forward<char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 96   :     // return smaller of _Left and _Right
; 97   :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rdx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 98   : }

	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 80
_Newsize$ = 88
_Val$dead$ = 96
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1505 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN108:
	push	rbx
	push	rbp
	push	r14
	sub	rsp, 48					; 00000030H

; 1506 :         if (_Newsize > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rbp, rdx
	mov	r14, rcx
	cmp	rdx, rbx
	ja	$LN105@Resize_rea
	mov	QWORD PTR [rsp+96], rsi

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], r15

; 1508 :         }
; 1509 : 
; 1510 :         auto& _Al         = _Getal();
; 1511 :         auto& _My_data    = _Mypair._Myval2;
; 1512 :         pointer& _Myfirst = _My_data._Myfirst;
; 1513 :         pointer& _Mylast  = _My_data._Mylast;
; 1514 : 
; 1515 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r15, QWORD PTR [rcx+8]
	sub	r15, QWORD PTR [rcx]

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [r14]

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN10@Resize_rea

; 1971 :             return _Max; // geometric growth would overflow

	mov	rcx, -9223372036854775770		; 8000000000000026H
$LN34@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN33@Resize_rea

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN20@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1975 : 
; 1976 :         if (_Geometric < _Newsize) {

	cmp	rbx, rbp
	cmovb	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rbx, rbx
	jne	SHORT $LN21@Resize_rea

; 197  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN20@Resize_rea
$LN21@Resize_rea:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN23@Resize_rea

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN106@Resize_rea
	jmp	SHORT $LN34@Resize_rea
$LN23@Resize_rea:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN20@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1527 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r8, rbp
	lea	rcx, QWORD PTR [rdi+r15]
	sub	r8, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1531 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1910 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1541 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rbp
	mov	rdx, rdi
	mov	rcx, r14
	mov	rdi, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+32]

; 1542 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rbp
	pop	rbx

; 1541 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
$LN33@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN106@Resize_rea:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN105@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1507 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN103@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >, COMDAT

; 2004 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN29:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	xor	edx, edx

; 2004 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	mov	rbx, rcx

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	memset

; 2005 :     // value-initialize _Count objects to raw _First, using _Al
; 2006 :     using _Ptrty = typename _Alloc::value_type*;
; 2007 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2008 : #if _HAS_CXX20
; 2009 :         if (!_STD is_constant_evaluated())
; 2010 : #endif // _HAS_CXX20
; 2011 :         {
; 2012 :             auto _PFirst = _Unfancy(_First);
; 2013 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2014 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]

; 2015 :         }
; 2016 :     }
; 2017 : 
; 2018 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2019 :     for (; 0 < _Count; --_Count) {
; 2020 :         _Backout._Emplace_back();
; 2021 :     }
; 2022 : 
; 2023 :     return _Backout._Release();
; 2024 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBE@std@@YAAEBEAEBE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBE@std@@YAAEBEAEBE@Z PROC			; std::forward<unsigned char const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBE@std@@YAAEBEAEBE@Z ENDP			; std::forward<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>, COMDAT

; 784  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 785  :         auto& _My_data   = _Mypair._Myval2;
; 786  :         pointer& _Mylast = _My_data._Mylast;
; 787  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 788  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 789  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 790  :             _ASAN_VECTOR_MODIFY(1);
; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [rdx]
	mov	r8, QWORD PTR [rcx+8]
	mov	BYTE PTR [r8], al

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 800  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rcx+8], rdx

; 801  : 
; 802  :         return _Result;
; 803  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
_TEXT	SEGMENT
this$ = 96
_Whereptr$ = 104
<_Val_0>$ = 112
??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>, COMDAT

; 806  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN128:
	push	rbp
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 807  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 808  :         _Alty& _Al        = _Getal();
; 809  :         auto& _My_data    = _Mypair._Myval2;
; 810  :         pointer& _Myfirst = _My_data._Myfirst;
; 811  :         pointer& _Mylast  = _My_data._Mylast;
; 812  : 
; 813  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 814  : 
; 815  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 816  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	r15, rbp
	sub	r15, rdx
	sub	rax, rdx

; 817  : 
; 818  :         if (_Oldsize == max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	mov	r13, r8
	mov	r14, rcx
	cmp	rax, rdi
	je	$LN125@Emplace_re

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+40], rsi

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	QWORD PTR [rsp+32], r12

; 820  :         }
; 821  : 
; 822  :         const size_type _Newsize = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rdi
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN12@Emplace_re

; 1971 :             return _Max; // geometric growth would overflow

	mov	rcx, -9223372036854775770		; 8000000000000026H
$LN36@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN35@Emplace_re

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN22@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	mov	rdi, r12
	cmp	rax, r12
	cmovae	rdi, rax
	test	rdi, rdi
	jne	SHORT $LN23@Emplace_re

; 197  :         return nullptr;

	xor	ebx, ebx
	jmp	SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN25@Emplace_re

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN126@Emplace_re
	jmp	SHORT $LN36@Emplace_re
$LN25@Emplace_re:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN22@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 830  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	movzx	ecx, BYTE PTR [r13]
	lea	rsi, QWORD PTR [rbx+r15]
	mov	BYTE PTR [rsi], cl

; 831  :         _Constructed_first = _Newvec + _Whereoff;
; 832  : 
; 833  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [r14+8]
	mov	rdx, QWORD PTR [r14]
	cmp	rbp, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 839  :         } else { // provide basic guarantee

	jmp	SHORT $LN123@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rbp
	sub	r8, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1910 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	rcx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rbp

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbp
$LN123@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	call	memmove

; 843  :         }
; 844  :         _CATCH_ALL
; 845  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 846  :         _Al.deallocate(_Newvec, _Newcapacity);
; 847  :         _RERAISE;
; 848  :         _CATCH_END
; 849  : 
; 850  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rdi
	mov	r8, r12
	mov	rdx, rbx
	mov	rcx, r14
	call	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
	mov	rbx, QWORD PTR [rsp+112]

; 851  :         return _Newvec + _Whereoff;

	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+32]

; 852  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
$LN35@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN126@Emplace_re:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN125@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 819  :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN122@Emplace_re:
??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z PROC ; std::forward<std::allocator<unsigned char> >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ENDP ; std::forward<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z PROC		; std::forward<unsigned char *>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z ENDP		; std::forward<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z PROC		; std::forward<unsigned char * const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z ENDP		; std::forward<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z PROC ; std::ranges::_Unwrap_iter<unsigned char *,unsigned char *>, COMDAT

; 2640 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2641 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2642 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2643 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2644 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2645 :         } else {
; 2646 :             return static_cast<_Iter&&>(_It);
; 2647 :         }
; 2648 :     }

	ret	0
??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ENDP ; std::ranges::_Unwrap_iter<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z PROC ; std::ranges::_Unwrap_sent<unsigned char *,unsigned char *>, COMDAT

; 2653 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2654 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2655 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2656 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2657 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2658 :         } else {
; 2659 :             return static_cast<_Sent&&>(_Se);
; 2660 :         }
; 2661 :     }

	ret	0
??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ENDP ; std::ranges::_Unwrap_sent<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1797 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN24:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1797 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1828 :             return _Dest;

	sub	rsi, rbx
	lea	rax, QWORD PTR [rdi+rsi]

; 1829 :         }
; 1830 :     }
; 1831 : 
; 1832 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1833 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1834 :         _Backout._Emplace_back(*_UFirst);
; 1835 :     }
; 1836 : 
; 1837 :     return _Backout._Release();
; 1838 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z PROC		; std::_To_address<unsigned char *>, COMDAT

; 4482 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4483 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4484 : }

	ret	0
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ENDP		; std::_To_address<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Capacity$ = 56
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 2614 :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN52:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2615 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2616 :         ++_Capacity; // Take null terminator into consideration

	add	QWORD PTR [rdx], 1
	mov	rbx, rdx
	mov	rcx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	jne	SHORT $LN12@Allocate_f

; 197  :         return nullptr;

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2636 :         --_Capacity;

	dec	QWORD PTR [rdx]

; 2638 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN12@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN14@Allocate_f

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN50@Allocate_f

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN24@Allocate_f

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2636 :         --_Capacity;

	dec	QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2638 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN14@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2636 :         --_Capacity;

	dec	QWORD PTR [rbx]

; 2638 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN50@Allocate_f:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN48@Allocate_f:
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN33:
	sub	rsp, 40					; 00000028H

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN6@Allocate_a

; 197  :         return nullptr;

	xor	eax, eax

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Allocate_a:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@Allocate_a

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN32@Allocate_a

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@Allocate_a

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@Allocate_a:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN32@Allocate_a:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN18@Allocate_a:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN30@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release, COMDAT

; 1785 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1786 :         return _Last;
; 1787 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1775 :         _STD _Destroy_range(_First, _Last, _Al);
; 1776 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1769 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT

; 2017 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2018 :         // orphan all iterators, discard old array, acquire new array
; 2019 :         auto& _Al         = _Getal();
; 2020 :         auto& _My_data    = _Mypair._Myval2;
; 2021 :         pointer& _Myfirst = _My_data._Myfirst;
; 2022 :         pointer& _Mylast  = _My_data._Mylast;
; 2023 :         pointer& _Myend   = _My_data._Myend;
; 2024 : 
; 2025 :         _My_data._Orphan_all();
; 2026 : 
; 2027 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN6@Change_arr

; 2028 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2029 :             _ASAN_VECTOR_REMOVE;
; 2030 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2034 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp]
	mov	QWORD PTR [rbx], rdi

; 2037 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi]
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();
; 1968 :         const auto _Max              = max_size();
; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();
; 1968 :         const auto _Max              = max_size();
; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax
	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1971 :             return _Max; // geometric growth would overflow
; 1972 :         }
; 1973 : 
; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1975 : 
; 1976 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1977 :             return _Newsize; // geometric growth would be insufficient
; 1978 :         }
; 1979 : 
; 1980 :         return _Geometric; // geometric growth is sufficient
; 1981 :     }

	ret	0
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 196  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 197  :         return nullptr;

	xor	eax, eax

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@allocate:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN29@allocate

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@allocate:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN29@allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN16@allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN27@allocate:
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT

; 1882 :         auto& _My_data = _Mypair._Myval2;
; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]

; 1884 :     }

	ret	0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z PROC	; std::_Get_unwrapped<unsigned char * const &>, COMDAT

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	ret	0
??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z ENDP	; std::_Get_unwrapped<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1905 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN24:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1905 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1918 :             return _Dest + (_ULast - _UFirst);

	sub	rsi, rbx
	lea	rax, QWORD PTR [rdi+rsi]

; 1919 :         }
; 1920 :     }
; 1921 : 
; 1922 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1923 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1924 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1925 :     }
; 1926 : 
; 1927 :     return _Backout._Release();
; 1928 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@E@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@E@std@@YAPEAEPEAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT

; 36   :     return _Ptr;

	mov	rax, rcx

; 37   : }

	ret	0
??$_Unfancy@E@std@@YAPEAEPEAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 1995 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1996 :     char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));
; 1997 :     char* const _Last_ch  = reinterpret_cast<char*>(_STD _To_address(_Last));
; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	mov	rbx, rdx
	sub	r8, rcx
	xor	edx, edx
	call	memset

; 1999 :     return _Last;

	mov	rax, rbx

; 2000 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	BYTE PTR [rax], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1781 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1782 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z PROC	; std::_Construct_in_place<unsigned char,unsigned char const &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	ret	0
??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z ENDP	; std::_Construct_in_place<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z PROC		; std::move<unsigned char * &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z ENDP		; std::move<unsigned char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$to_address@E@std@@YAPEAEQEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@E@std@@YAPEAEQEAE@Z PROC			; std::to_address<unsigned char>, COMDAT

; 453  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 454  :     return _Val;

	mov	rax, rcx

; 455  : }

	ret	0
??$to_address@E@std@@YAPEAEQEAE@Z ENDP			; std::to_address<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z PROC	; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4613 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4614 :     auto _FirstPtr              = _STD _To_address(_First);
; 4615 :     auto _LastPtr               = _STD _To_address(_Last);
; 4616 :     auto _DestPtr               = _STD _To_address(_Dest);
; 4617 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4618 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4619 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4624 :     } else {
; 4625 :         return _Dest + (_LastPtr - _FirstPtr);
; 4626 :     }
; 4627 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z ENDP	; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char &>, COMDAT

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 1781 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1782 :     }

	ret	0
??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN33:
	sub	rsp, 40					; 00000028H

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN6@Allocate_a

; 197  :         return nullptr;

	xor	eax, eax

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Allocate_a:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@Allocate_a

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN32@Allocate_a

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@Allocate_a

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@Allocate_a:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN32@Allocate_a:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN18@Allocate_a:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN30@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z PROC		; std::construct_at<char,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z ENDP		; std::construct_at<char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {
; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	mov	rax, rcx

; 90   : }

	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 194  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN27:
	sub	rsp, 40					; 00000028H

; 195  :     // allocate _Bytes
; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN2@Allocate

; 197  :         return nullptr;

	xor	eax, eax

; 221  :             // boost the alignment of big allocations to help autovectorization
; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 223  :         }
; 224  : #endif // defined(_M_IX86) || defined(_M_X64)
; 225  :         return _Traits::_Allocate(_Bytes);
; 226  :     }
; 227  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@Allocate:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN26@Allocate

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN14@Allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 221  :             // boost the alignment of big allocations to help autovectorization
; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 223  :         }
; 224  : #endif // defined(_M_IX86) || defined(_M_X64)
; 225  :         return _Traits::_Allocate(_Bytes);
; 226  :     }
; 227  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Allocate:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN26@Allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN14@Allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN24@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 196  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 197  :         return nullptr;

	xor	eax, eax

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@allocate:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN29@allocate

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@allocate:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN29@allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN16@allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN27@allocate:
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAE@std@@YA$$QEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAE@std@@YA$$QEAEAEAE@Z PROC			; std::move<unsigned char &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAE@std@@YA$$QEAEAEAE@Z ENDP			; std::move<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>, COMDAT

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 1781 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1782 :     }

	ret	0
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@E@std@@YAPEAEAEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@E@std@@YAPEAEAEAE@Z PROC			; std::addressof<unsigned char>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@E@std@@YAPEAEAEAE@Z ENDP			; std::addressof<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z PROC	; std::construct_at<unsigned char,unsigned char const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z ENDP	; std::construct_at<unsigned char,unsigned char const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEAE@std@@YAAEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAE@std@@YAAEAEAEAE@Z PROC			; std::forward<unsigned char &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEAE@std@@YAAEAEAEAE@Z ENDP			; std::forward<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 151  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN17:
	sub	rsp, 40					; 00000028H

; 152  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN16@Allocate_m

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN7@Allocate_m

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 162  : 
; 163  : #ifdef _DEBUG
; 164  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 165  : #endif // defined(_DEBUG)
; 166  :     return _Ptr;
; 167  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Allocate_m:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN16@Allocate_m:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@E@std@@YA$$QEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@E@std@@YA$$QEAEAEAE@Z PROC			; std::forward<unsigned char>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@E@std@@YA$$QEAEAEAE@Z ENDP			; std::forward<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z PROC		; std::construct_at<unsigned char,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z ENDP		; std::construct_at<unsigned char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z PROC	; std::construct_at<unsigned char,unsigned char &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z ENDP	; std::construct_at<unsigned char,unsigned char &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z PROC	; std::construct_at<unsigned char,unsigned char,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z ENDP	; std::construct_at<unsigned char,unsigned char,0>
_TEXT	ENDS
END
