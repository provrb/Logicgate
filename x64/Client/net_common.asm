; Listing generated by Microsoft (R) Optimizing Compiler Version 19.40.33811.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?StartWSA@@3P6AHGPEAUWSAData@@@ZEA		; StartWSA
PUBLIC	?WSAInitialized@NetCommon@@3HA			; NetCommon::WSAInitialized
;	COMDAT ?StartWSA@@3P6AHGPEAUWSAData@@@ZEA
_BSS	SEGMENT
?StartWSA@@3P6AHGPEAUWSAData@@@ZEA DQ 01H DUP (?)	; StartWSA
_BSS	ENDS
;	COMDAT ?WSAInitialized@NetCommon@@3HA
_BSS	SEGMENT
?WSAInitialized@NetCommon@@3HA DD 01H DUP (?)		; NetCommon::WSAInitialized
_BSS	ENDS
PUBLIC	??$to_address@D@std@@YAPEADQEAD@Z		; std::to_address<char>
PUBLIC	??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z ; std::_Refancy_maybe_null<unsigned char *,0>
PUBLIC	??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z	; std::_To_address<char *>
PUBLIC	??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z ; std::_Copy_memmove<char *,unsigned char *>
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
PUBLIC	??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z ; std::_Copy_unchecked<char *,char *,unsigned char *>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &,__int64>
PUBLIC	??$_Idl_distance@PEADPEAD@std@@YA?A_PAEBQEAD0@Z	; std::_Idl_distance<char *,char *>
PUBLIC	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z	; std::_Get_unwrapped<char * &>
PUBLIC	??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z ; std::copy<char *,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
PUBLIC	??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>
PUBLIC	??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>
PUBLIC	??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
PUBLIC	??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>
PUBLIC	??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>
PUBLIC	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
PUBLIC	?data@?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEBAPEBDXZ ; ay::obfuscator<13,-8505844796237434571,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ ; ay::obfuscated_data<13,-8505844796237434571,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,-4962681195322312931,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,-4962681195322312931,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,-1502061074894816457,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,-1502061074894816457,char>::decrypt
PUBLIC	?data@?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@ay@@QEBAPEBDXZ ; ay::obfuscator<5,-769018879138130635,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAXXZ ; ay::obfuscated_data<5,-769018879138130635,char>::decrypt
PUBLIC	?data@?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEBAPEBDXZ ; ay::obfuscator<12,-17003346941488231,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ ; ay::obfuscated_data<12,-17003346941488231,char>::decrypt
PUBLIC	?data@?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<7,-7217698246706230297,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<7,-7217698246706230297,char>::decrypt
PUBLIC	?data@?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@ay@@QEBAPEBDXZ ; ay::obfuscator<5,4171390554486297459,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAXXZ ; ay::obfuscated_data<5,4171390554486297459,char>::decrypt
PUBLIC	?data@?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<7,-7558938099074472137,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<7,-7558938099074472137,char>::decrypt
PUBLIC	?data@?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEBAPEBDXZ ; ay::obfuscator<9,-4071404544105560167,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ ; ay::obfuscated_data<9,-4071404544105560167,char>::decrypt
PUBLIC	?data@?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<5,-3929642162503730297,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<5,-3929642162503730297,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,9007561748555066333,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,9007561748555066333,char>::decrypt
PUBLIC	?data@?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@ay@@QEBAPEBDXZ ; ay::obfuscator<8,-8716755408375925265,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ ; ay::obfuscated_data<8,-8716755408375925265,char>::decrypt
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
PUBLIC	?encrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z	; Cipher::Aes<256>::encrypt_block
PUBLIC	??0?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@1@@Z ; ay::obfuscated_data<13,-8505844796237434571,char>::obfuscated_data<13,-8505844796237434571,char>
PUBLIC	??1?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@XZ ; ay::obfuscated_data<13,-8505844796237434571,char>::~obfuscated_data<13,-8505844796237434571,char>
PUBLIC	??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<13,-8505844796237434571,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@1@@Z ; ay::obfuscated_data<11,-4962681195322312931,char>::obfuscated_data<11,-4962681195322312931,char>
PUBLIC	??1?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,-4962681195322312931,char>::~obfuscated_data<11,-4962681195322312931,char>
PUBLIC	??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,-4962681195322312931,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@1@@Z ; ay::obfuscated_data<11,-1502061074894816457,char>::obfuscated_data<11,-1502061074894816457,char>
PUBLIC	??1?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,-1502061074894816457,char>::~obfuscated_data<11,-1502061074894816457,char>
PUBLIC	??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,-1502061074894816457,char>::operator char *
PUBLIC	??0?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@AEBV?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@1@@Z ; ay::obfuscated_data<5,-769018879138130635,char>::obfuscated_data<5,-769018879138130635,char>
PUBLIC	??1?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@XZ ; ay::obfuscated_data<5,-769018879138130635,char>::~obfuscated_data<5,-769018879138130635,char>
PUBLIC	??B?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<5,-769018879138130635,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@1@@Z ; ay::obfuscated_data<12,-17003346941488231,char>::obfuscated_data<12,-17003346941488231,char>
PUBLIC	??1?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@XZ ; ay::obfuscated_data<12,-17003346941488231,char>::~obfuscated_data<12,-17003346941488231,char>
PUBLIC	??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<12,-17003346941488231,char>::operator char *
PUBLIC	??0?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@1@@Z ; ay::obfuscated_data<7,-7217698246706230297,char>::obfuscated_data<7,-7217698246706230297,char>
PUBLIC	??1?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<7,-7217698246706230297,char>::~obfuscated_data<7,-7217698246706230297,char>
PUBLIC	??B?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<7,-7217698246706230297,char>::operator char *
PUBLIC	??0?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@AEBV?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@1@@Z ; ay::obfuscated_data<5,4171390554486297459,char>::obfuscated_data<5,4171390554486297459,char>
PUBLIC	??1?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@XZ ; ay::obfuscated_data<5,4171390554486297459,char>::~obfuscated_data<5,4171390554486297459,char>
PUBLIC	??B?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<5,4171390554486297459,char>::operator char *
PUBLIC	??0?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@1@@Z ; ay::obfuscated_data<7,-7558938099074472137,char>::obfuscated_data<7,-7558938099074472137,char>
PUBLIC	??1?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<7,-7558938099074472137,char>::~obfuscated_data<7,-7558938099074472137,char>
PUBLIC	??B?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<7,-7558938099074472137,char>::operator char *
PUBLIC	??0?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@AEBV?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@1@@Z ; ay::obfuscated_data<9,-4071404544105560167,char>::obfuscated_data<9,-4071404544105560167,char>
PUBLIC	??1?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@XZ ; ay::obfuscated_data<9,-4071404544105560167,char>::~obfuscated_data<9,-4071404544105560167,char>
PUBLIC	??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<9,-4071404544105560167,char>::operator char *
PUBLIC	??0?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@1@@Z ; ay::obfuscated_data<5,-3929642162503730297,char>::obfuscated_data<5,-3929642162503730297,char>
PUBLIC	??1?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<5,-3929642162503730297,char>::~obfuscated_data<5,-3929642162503730297,char>
PUBLIC	??B?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<5,-3929642162503730297,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@1@@Z ; ay::obfuscated_data<11,9007561748555066333,char>::obfuscated_data<11,9007561748555066333,char>
PUBLIC	??1?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,9007561748555066333,char>::~obfuscated_data<11,9007561748555066333,char>
PUBLIC	??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,9007561748555066333,char>::operator char *
PUBLIC	??0?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@1@@Z ; ay::obfuscated_data<8,-8716755408375925265,char>::obfuscated_data<8,-8716755408375925265,char>
PUBLIC	??1?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@XZ ; ay::obfuscated_data<8,-8716755408375925265,char>::~obfuscated_data<8,-8716755408375925265,char>
PUBLIC	??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<8,-8716755408375925265,char>::operator char *
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z	; NetCommon::IsBlobValid
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z ; NetCommon::AESEncryptBlob
PUBLIC	?LoadWSAFunctions@NetCommon@@YAXXZ		; NetCommon::LoadWSAFunctions
;	COMDAT ?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A DQ 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A DB 0cH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A DB 06H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A DB 06H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A DB 0bH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A DB 06H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A DB 09H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A DB 0cH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A DB 0aH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A DB 0cH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A DQ 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A DB 0dH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::obfuscated_data
?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::kernel32
?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::ntdll
?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::advapi32
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z DD imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DD imagerel ??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
	DD	imagerel ??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ+107
	DD	imagerel $unwind$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DD imagerel ??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
	DD	imagerel ??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ+105
	DD	imagerel $unwind$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DD imagerel ??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
	DD	imagerel ??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ+97
	DD	imagerel $unwind$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DD imagerel ??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
	DD	imagerel ??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ+104
	DD	imagerel $unwind$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DD imagerel ??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
	DD	imagerel ??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ+98
	DD	imagerel $unwind$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DD imagerel ??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
	DD	imagerel ??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ+97
	DD	imagerel $unwind$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DD imagerel ??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
	DD	imagerel ??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ+98
	DD	imagerel $unwind$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DD imagerel ??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
	DD	imagerel ??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ+114
	DD	imagerel $unwind$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DD imagerel ??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
	DD	imagerel ??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ+97
	DD	imagerel $unwind$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DD imagerel ??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ+105
	DD	imagerel $unwind$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DD imagerel ??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ+105
	DD	imagerel $unwind$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DD imagerel ??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DD imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ+108
	DD	imagerel $unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z DD imagerel $LN14
	DD	imagerel $LN14+69
	DD	imagerel $unwind$?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DD imagerel $LN328
	DD	imagerel $LN328+662
	DD	imagerel $unwind$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LoadWSAFunctions@NetCommon@@YAXXZ DD imagerel $LN953
	DD	imagerel $LN953+3474
	DD	imagerel $unwind$?LoadWSAFunctions@NetCommon@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$13@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$13@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$13@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$19@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$19@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$19@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$23@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$23@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$23@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$23@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$28@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$28@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$28@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$28@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$32@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$32@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$32@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$32@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$40@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$40@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$40@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$40@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$44@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$44@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$44@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$44@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$52@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$52@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$52@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$52@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$52@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$44@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$40@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$32@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$28@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$23@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?LoadWSAFunctions@NetCommon@@YAXXZ DB 'J'
	DB	0a8H
	DB	00H
	DB	'|'
	DB	02H
	DB	'N'
	DB	00H
	DB	'q', 04H
	DB	04H
	DB	'6'
	DB	00H
	DB	0feH
	DB	06H
	DB	092H
	DB	00H
	DB	'&'
	DB	08H
	DB	')', 02H
	DB	0aH
	DB	092H
	DB	00H
	DB	'*'
	DB	0cH
	DB	'E', 02H
	DB	0eH
	DB	'b'
	DB	00H
	DB	'N'
	DB	010H
	DB	'\'
	DB	00H
	DB	'm', 04H
	DB	0cH
	DB	'6'
	DB	00H
	DB	0feH
	DB	012H
	DB	'r'
	DB	00H
	DB	'*'
	DB	0cH
	DB	'E', 02H
	DB	014H
	DB	'b'
	DB	00H
	DB	'*'
	DB	0cH
	DB	'%', 02H
	DB	016H
	DB	'r'
	DB	00H
	DB	'*'
	DB	0cH
	DB	'a', 02H
	DB	018H
	DB	082H
	DB	00H
	DB	'*'
	DB	0cH
	DB	'E', 02H
	DB	01aH
	DB	'b'
	DB	00H
	DB	'*'
	DB	0cH
	DB	'e', 02H
	DB	01cH
	DB	092H
	DB	00H
	DB	'*'
	DB	0cH
	DB	'm', 02H
	DB	01eH
	DB	01dH, 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?LoadWSAFunctions@NetCommon@@YAXXZ DB 01eH
	DB	0eH
	DD	imagerel ?dtor$13@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	066H
	DD	imagerel ?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	08aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	0beH
	DD	imagerel ?dtor$19@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0e4H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
	DB	02dH
	DB	02H
	DD	imagerel ?dtor$23@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	08dH
	DB	02H
	DD	imagerel ?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0edH
	DB	02H
	DD	imagerel ?dtor$28@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	04dH
	DB	03H
	DD	imagerel ?dtor$32@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0adH
	DB	03H
	DD	imagerel ?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0dH
	DB	04H
	DD	imagerel ?dtor$40@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	06dH
	DB	04H
	DD	imagerel ?dtor$44@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0cdH
	DB	04H
	DD	imagerel ?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	02dH
	DB	05H
	DD	imagerel ?dtor$52@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?LoadWSAFunctions@NetCommon@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?LoadWSAFunctions@NetCommon@@YAXXZ
	DD	imagerel $ip2state$?LoadWSAFunctions@NetCommon@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LoadWSAFunctions@NetCommon@@YAXXZ DD 0f3b19H
	DD	024682aH
	DD	051c426H
	DD	0507426H
	DD	04f6426H
	DD	04e3426H
	DD	04a0126H
	DD	0e016f018H
	DD	05014H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?LoadWSAFunctions@NetCommon@@YAXXZ
	DD	0232H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DB 08H
	DB	08aH
	DB	02H
	DB	0beH
	DB	04H
	DB	0c9H, 05H
	DB	02H
	DB	0aeH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1NET_BLOB@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
	DD	imagerel $ip2state$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DD 092e19H
	DD	03b641dH
	DD	03a341dH
	DD	034011dH
	DD	0700ce00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
	DD	0192H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0a6H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a2H
	DB	02H
	DB	'i', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DB 02H
	DB	0a0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DB 02H
	DB	0a0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DB 02H
	DB	090H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DB 02H
	DB	0b2H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DB 02H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DB 02H
	DB	090H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DB 02H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DB 02H
	DB	09eH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DB 02H
	DB	090H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DB 02H
	DB	0a0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DB 02H
	DB	0a4H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
?kernel32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::kernel32$initializer$
?ntdll$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::ntdll$initializer$
?advapi32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::advapi32$initializer$
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ?LoadWSAFunctions@NetCommon@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?LoadWSAFunctions@NetCommon@@YAXXZ PROC			; NetCommon::LoadWSAFunctions, COMDAT

; 7    : void NetCommon::LoadWSAFunctions() {

$LN953:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax+32], r12
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-360]
	sub	rsp, 592				; 00000250H
	movaps	XMMWORD PTR [rax-40], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 8    :     if ( WSAInitialized )

	cmp	DWORD PTR ?WSAInitialized@NetCommon@@3HA, 0 ; NetCommon::WSAInitialized
	jne	$LN3@LoadWSAFun

; 9    :         return;
; 10   : 
; 11   :     HMODULE kernel32 = ProcessUtilities::GetModHandle(ProcessUtilities::freqDLLS::kernel32); // load winsock

	lea	rdx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T31[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetModHandle
	mov	r14, rax

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	mov	edx, DWORD PTR _tls_index
	mov	rcx, QWORD PTR gs:88
	mov	rdi, QWORD PTR [rcx+rdx*8]
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	ecx, DWORD PTR [rax+rdi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A
	add	rbx, rdi
	test	cl, 1
	jne	SHORT $LN899@LoadWSAFun
	or	ecx, 1
	mov	DWORD PTR [rax+rdi], ecx
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 20514000		; 013904d0H
	mov	DWORD PTR [rbx], 566812281		; 21c8de79H
	mov	DWORD PTR [rbx+4], -73973131		; fb974275H
	mov	WORD PTR [rbx+8], 50004			; 0000c354H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN899@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	xor	esi, esi
	mov	r12d, DWORD PTR __isa_available
	movdqa	xmm6, XMMWORD PTR __xmm@00000000000008000000000000000800
	cmp	BYTE PTR [rbx+13], sil
	je	$LN30@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, esi
	cmp	r12d, 5
	jl	$LN946@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm2, XMMWORD PTR __xmm@89f52b3945a9b13589f52b3945a9b135
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	edx, 8
$LN946@LoadWSAFun:
	mov	r9, -8505844796237434571		; 89f52b3945a9b135H
	npad	3
$LL943@LoadWSAFun:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, dl
	and	cl, 7
	shl	cl, 3
	mov	r8, r9
	shr	r8, cl
	xor	BYTE PTR [rdx+rbx], r8b

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	rdx
	cmp	rdx, 13
	jb	SHORT $LL943@LoadWSAFun

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], sil
$LN30@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T29[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T9[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN58@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN72@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN69@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN72@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN58@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN900@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 21830513		; 014d1b71H
	mov	DWORD PTR [rbx], 1417610314		; 547f044aH
	mov	DWORD PTR [rbx+4], -552652404		; df0f318cH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN81@LoadWSAFun
$LN900@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN81@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN92@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 29
	xor	BYTE PTR [rbx+1], 119			; 00000077H
	xor	BYTE PTR [rbx+2], 77			; 0000004dH
	xor	BYTE PTR [rbx+3], 11
	xor	BYTE PTR [rbx+4], -65			; ffffffffffffffbfH
	xor	BYTE PTR [rbx+5], 3
	xor	BYTE PTR [rbx+6], 33			; 00000021H
	xor	BYTE PTR [rbx+7], -69			; ffffffffffffffbbH
	xor	BYTE PTR [rbx+8], 29
	xor	BYTE PTR [rbx+9], 119			; 00000077H
	xor	BYTE PTR [rbx+10], 77			; 0000004dH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN92@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN103@LoadWSAFun

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN103@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	mov	rcx, rax
	call	r14
	mov	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T30[rbp-232]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN126@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T30[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN140@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN951@LoadWSAFun
$LN140@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN126@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T30[rbp-240], xmm0

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T30[rsp], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN902@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 32738114		; 01f38b42H
	mov	DWORD PTR [rbx], 1286776928		; 4cb2a860H
	mov	DWORD PTR [rbx+4], -1621755363		; 9f55fa1dH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN147@LoadWSAFun
$LN902@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN147@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN158@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 55			; 00000037H
	xor	BYTE PTR [rbx+1], -5
	xor	BYTE PTR [rbx+2], -13
	xor	BYTE PTR [rbx+3], 31
	xor	BYTE PTR [rbx+4], 105			; 00000069H
	xor	BYTE PTR [rbx+5], -101			; ffffffffffffff9bH
	xor	BYTE PTR [rbx+6], 39			; 00000027H
	xor	BYTE PTR [rbx+7], -21
	xor	BYTE PTR [rbx+8], 55			; 00000037H
	xor	BYTE PTR [rbx+9], -5
	xor	BYTE PTR [rbx+10], -13

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN158@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T8[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T28[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r15, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN186@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN200@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN197@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN200@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN186@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	mov	QWORD PTR ?StartWSA@@3P6AHGPEAUWSAData@@@ZEA, r15 ; StartWSA

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN904@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 23529225		; 01670709H
	mov	WORD PTR [rbx], 31831			; 00007c57H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN208@LoadWSAFun
$LN904@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN208@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+5], 0
	je	SHORT $LN219@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 53			; 00000035H
	xor	BYTE PTR [rbx+1], 21
	xor	BYTE PTR [rbx+2], 103			; 00000067H
	xor	BYTE PTR [rbx+3], 99			; 00000063H
	xor	BYTE PTR [rbx+4], 103			; 00000067H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+5], 0
$LN219@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN906@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+11], 457			; 000001c9H
	mov	DWORD PTR [rbx], -1159708678		; bae03ffaH
	mov	DWORD PTR [rbx+4], -1666390802		; 9cace4eeH
	mov	WORD PTR [rbx+8], 14066			; 000036f2H
	mov	BYTE PTR [rbx+10], -5
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN227@LoadWSAFun
$LN906@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN227@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+12], 0
	je	$LN238@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	rdx, rsi
	cmp	r12d, 5
	jl	$LN947@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm2, XMMWORD PTR __xmm@ffc3978bc98f5399ffc3978bc98f5399
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	edx, 8
$LN947@LoadWSAFun:
	mov	r9, -17003346941488231			; ffc3978bc98f5399H
	npad	12
$LL944@LoadWSAFun:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, dl
	and	cl, 7
	shl	cl, 3
	mov	r8, r9
	shr	r8, cl
	xor	BYTE PTR [rdx+rbx], r8b

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	rdx
	cmp	rdx, 12
	jb	SHORT $LL944@LoadWSAFun

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+12], 0
$LN238@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T18[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T7[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r15, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN266@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN280@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN277@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN280@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN266@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	mov	QWORD PTR ?CloseSocket@@3P6AH_K@ZEA, r15 ; CloseSocket

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN907@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 30794186		; 01d5e1caH
	mov	DWORD PTR [rbx], -293673836		; ee7ee494H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN288@LoadWSAFun
$LN907@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN288@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+7], 0
	je	SHORT $LN299@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -25
	xor	BYTE PTR [rbx+1], -117			; ffffffffffffff8bH
	xor	BYTE PTR [rbx+2], 29
	xor	BYTE PTR [rbx+3], -123			; ffffffffffffff85H
	xor	BYTE PTR [rbx+4], -81			; ffffffffffffffafH
	xor	BYTE PTR [rbx+5], -107			; ffffffffffffff95H
	xor	BYTE PTR [rbx+6], -43			; ffffffffffffffd5H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+7], 0
$LN299@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T6[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r15, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN327@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN341@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN338@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN341@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN327@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	mov	QWORD PTR ?CreateSocket@@3P6A_KHHH@ZEA, r15 ; CreateSocket

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN909@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 26988016		; 019bcdf0H
	mov	WORD PTR [rbx], 13825			; 00003601H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN349@LoadWSAFun
$LN909@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN349@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+5], 0
	je	SHORT $LN360@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 115			; 00000073H
	xor	BYTE PTR [rbx+1], 83			; 00000053H
	xor	BYTE PTR [rbx+2], -109			; ffffffffffffff93H
	xor	BYTE PTR [rbx+3], -69			; ffffffffffffffbbH
	xor	BYTE PTR [rbx+4], -101			; ffffffffffffff9bH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+5], 0
$LN360@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T5[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN388@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN402@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN399@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN402@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN388@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN911@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 18427565		; 01192eadH
	mov	DWORD PTR [rbx], 1762755140		; 69118244H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN410@LoadWSAFun
$LN911@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN410@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+7], 0
	je	SHORT $LN421@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 55			; 00000037H
	xor	BYTE PTR [rbx+1], -25
	xor	BYTE PTR [rbx+2], 127			; 0000007fH
	xor	BYTE PTR [rbx+3], 13
	xor	BYTE PTR [rbx+4], -39			; ffffffffffffffd9H
	xor	BYTE PTR [rbx+5], 65			; 00000041H
	xor	BYTE PTR [rbx+6], 25

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+7], 0
$LN421@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T4[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r15, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN449@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN463@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN460@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN463@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN449@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	mov	QWORD PTR ?SendTo@@3P6AH_KPEBDHHPEBUsockaddr@@H@ZEA, r15 ; SendTo

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN913@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+6], 26847760		; 0199aa10H
	mov	DWORD PTR [rbx], 500048619		; 1dce22ebH
	mov	WORD PTR [rbx+4], 1349			; 00000545H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN471@LoadWSAFun
$LN913@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN471@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+9], 0
	je	SHORT $LN482@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -103			; ffffffffffffff99H
	xor	BYTE PTR [rbx+1], 71			; 00000047H
	xor	BYTE PTR [rbx+2], -83			; ffffffffffffffadH
	xor	BYTE PTR [rbx+3], 107			; 0000006bH
	xor	BYTE PTR [rbx+4], 35			; 00000023H
	xor	BYTE PTR [rbx+5], 119			; 00000077H
	xor	BYTE PTR [rbx+6], 127			; 0000007fH
	xor	BYTE PTR [rbx+7], -57			; ffffffffffffffc7H
	xor	BYTE PTR [rbx+8], -103			; ffffffffffffff99H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+9], 0
$LN482@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T3[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r15, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN510@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN524@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN521@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN524@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN510@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	mov	QWORD PTR ?ReceiveFrom@@3P6AH_KPEADHHPEAUsockaddr@@PEAH@ZEA, r15 ; ReceiveFrom

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN915@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 21339647		; 01459dffH
	mov	WORD PTR [rbx], 24308			; 00005ef4H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN532@LoadWSAFun
$LN915@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN532@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+5], 0
	je	SHORT $LN543@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -121			; ffffffffffffff87H
	xor	BYTE PTR [rbx+1], 59			; 0000003bH
	xor	BYTE PTR [rbx+2], -111			; ffffffffffffff91H
	xor	BYTE PTR [rbx+3], -7
	xor	BYTE PTR [rbx+4], 69			; 00000045H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+5], 0
$LN543@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T2[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r15, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN571@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN585@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN582@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN585@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN571@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	mov	QWORD PTR ?Send@@3P6AH_KPEBDHH@ZEA, r15	; Send

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN917@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 17111976		; 01051ba8H
	mov	DWORD PTR [rbx], -398182262		; e844388aH
	mov	DWORD PTR [rbx+4], 325070019		; 13602cc3H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN593@LoadWSAFun
$LN917@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN593@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN604@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -35			; ffffffffffffffddH
	xor	BYTE PTR [rbx+1], 107			; 0000006bH
	xor	BYTE PTR [rbx+2], 5
	xor	BYTE PTR [rbx+3], -85			; ffffffffffffffabH
	xor	BYTE PTR [rbx+4], -81			; ffffffffffffffafH
	xor	BYTE PTR [rbx+5], 73			; 00000049H
	xor	BYTE PTR [rbx+6], 1
	xor	BYTE PTR [rbx+7], 125			; 0000007dH
	xor	BYTE PTR [rbx+8], -35			; ffffffffffffffddH
	xor	BYTE PTR [rbx+9], 107			; 0000006bH
	xor	BYTE PTR [rbx+10], 5

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN604@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T1[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r15, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN632@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN646@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN643@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN646@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN632@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	mov	QWORD PTR ?CleanWSA@@3P6AHXZEA, r15	; CleanWSA

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN919@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+7], 391			; 00000187H
	mov	DWORD PTR [rbx], -542647668		; dfa7da8cH
	mov	WORD PTR [rbx+4], 48710			; 0000be46H
	mov	BYTE PTR [rbx+6], 115			; 00000073H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN654@LoadWSAFun
$LN919@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN654@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+8], 0
	je	$LN665@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	cmp	r12d, 5
	jl	$LN948@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm2, XMMWORD PTR __xmm@8707dd23b1c9b5ef8707dd23b1c9b5ef
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax
	jmp	SHORT $LN669@LoadWSAFun
$LN948@LoadWSAFun:
	mov	rdx, -8716755408375925265		; 8707dd23b1c9b5efH
	npad	4
$LL945@LoadWSAFun:
	movzx	ecx, sil
	and	cl, 7
	shl	cl, 3
	mov	r8, rdx
	shr	r8, cl
	xor	BYTE PTR [rbx+rsi], r8b

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	rsi
	cmp	rsi, 8
	jb	SHORT $LL945@LoadWSAFun
$LN669@LoadWSAFun:

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+8], 0
$LN665@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
	mov	QWORD PTR ?ConnectSocket@@3P6AH_KPEBUsockaddr@@H@ZEA, rax ; ConnectSocket

; 27   :     
; 28   :     WORD version = MAKEWORD(2, 2);
; 29   :     WSAData data = { 0 };

	xor	edx, edx
	mov	r8d, 408				; 00000198H
	lea	rcx, QWORD PTR data$[rbp-256]
	call	memset

; 30   : 
; 31   :     if ( StartWSA(version, &data) == 0 )

	mov	rax, QWORD PTR ?StartWSA@@3P6AHGPEAUWSAData@@@ZEA ; StartWSA
	mov	ecx, 514				; 00000202H
	lea	rdx, QWORD PTR data$[rbp-256]
	call	rax
	test	eax, eax
	jne	SHORT $LN3@LoadWSAFun

; 32   :         WSAInitialized = TRUE;

	mov	DWORD PTR ?WSAInitialized@NetCommon@@3HA, 1 ; NetCommon::WSAInitialized
$LN3@LoadWSAFun:

; 33   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+592]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	mov	r12, QWORD PTR [r11+56]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN643@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN69@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN951@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN197@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN277@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN338@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN399@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN460@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN521@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN582@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN949@LoadWSAFun:
?LoadWSAFunctions@NetCommon@@YAXXZ ENDP			; NetCommon::LoadWSAFunctions
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$13@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$13
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$13@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$14
	mov	rcx, QWORD PTR $T9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$17
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$2@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$2
	lea	rcx, QWORD PTR $T30[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$19@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$19
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$19@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$20
	mov	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$23@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$23
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$23@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$24
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$25@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$25
	mov	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$25@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$28@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$28
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$28@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$29@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$29
	mov	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$29@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$29
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$32@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$32
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$32@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$33
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$33
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$36
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$36
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$37@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$37
	mov	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$37@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$37
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$40@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$40
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$40@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$40
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$41@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$41
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$41@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$41
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$44@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$44
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$44@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$44
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$45
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$45
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$48
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$48
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$49@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$49
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$49@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$49
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 40
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 112
$T31 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$52@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$52
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$52@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$52
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
_TEXT	SEGMENT
$T4 = 48
data$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
req$ = 88
key$ = 112
aes$ = 144
$T5 = 144
__$ArrayPad$ = 400
__$ReturnUdt$ = 448
data$ = 456
?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z PROC ; NetCommon::AESEncryptBlob, COMDAT

; 43   : BYTESTRING NetCommon::AESEncryptBlob(NET_BLOB data) {

$LN328:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-160]
	sub	rsp, 416				; 000001a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR data$GSCopy$[rsp], rdx
	xor	r14d, r14d

; 44   :     if ( IsBlobValid(data) == FALSE )

	lea	rcx, QWORD PTR $T5[rbp-256]
	call	??0NET_BLOB@@QEAA@AEBU0@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4279 :         return _Mypair._Myval2._Mysize == 0;

	cmp	QWORD PTR [rax+232], r14
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 103  :         return !b.aesKey.empty() && b.cr.valid || b.sr.valid || b.udp.isValid;

	je	SHORT $LN19@AESEncrypt
	cmp	DWORD PTR [rax], r14d
	jne	SHORT $LN20@AESEncrypt
$LN19@AESEncrypt:
	cmp	BYTE PTR [rax+48], 0
	jne	SHORT $LN20@AESEncrypt
	cmp	DWORD PTR [rax+212], 0
	jne	SHORT $LN20@AESEncrypt
	mov	rcx, rax
	call	??1NET_BLOB@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdi], r14
	mov	QWORD PTR [rdi+8], r14
	mov	QWORD PTR [rdi+16], r14
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 45   :         return {};

	jmp	$LN110@AESEncrypt
$LN20@AESEncrypt:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 103  :         return !b.aesKey.empty() && b.cr.valid || b.sr.valid || b.udp.isValid;

	mov	rcx, rax
	call	??1NET_BLOB@@QEAA@XZ
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR req$[rsp], xmm1
	mov	QWORD PTR req$[rsp+16], r14
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 49   :     if ( data.cr.valid ) {

	cmp	DWORD PTR [rbx], 0
	je	SHORT $LN3@AESEncrypt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	edx, 48					; 00000030H
	lea	rcx, QWORD PTR req$[rsp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 48					; 00000030H
	mov	rdx, rbx
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 53   :     }

	jmp	SHORT $LN323@AESEncrypt
$LN3@AESEncrypt:

; 54   :     else if ( data.sr.valid ) {

	cmp	BYTE PTR [rbx+48], 0
	je	SHORT $LN5@AESEncrypt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	edx, 128				; 00000080H
	lea	rcx, QWORD PTR req$[rsp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 128				; 00000080H
	lea	rdx, QWORD PTR [rbx+48]
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 58   :     }

	jmp	SHORT $LN323@AESEncrypt
$LN5@AESEncrypt:

; 59   :     else if ( data.udp.isValid ) {

	cmp	DWORD PTR [rbx+212], 0
	je	SHORT $LN278@AESEncrypt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	edx, 40					; 00000028H
	lea	rcx, QWORD PTR req$[rsp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 61   :         char* bytes = reinterpret_cast< char* >( &data.udp );

	lea	rdx, QWORD PTR [rbx+176]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 40					; 00000028H
$LN323@AESEncrypt:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 65   :     BYTESTRING key = NetCommon::SerializeString(data.aesKey);

	mov	rcx, QWORD PTR req$[rsp]
	call	memmove
$LN278@AESEncrypt:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR key$[rsp], xmm0
	mov	QWORD PTR key$[rbp-240], rax
	lea	rdx, QWORD PTR [rbx+216]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR key$[rsp]
	call	?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::SerializeString
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 608  :         Aes(unsigned char key[key_bits]) : round_keys() {

	xor	edx, edx
	mov	r8d, 240				; 000000f0H
	lea	rcx, QWORD PTR aes$[rbp-256]
	call	memset

; 609  :             constexpr bool invalid_aes_key_bit_size = key_bits == 128 || key_bits == 192 || key_bits == 256;
; 610  :             static_assert( invalid_aes_key_bit_size, "The valid values are only: 128, 192 & 256" );
; 611  : 
; 612  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 613  :             if constexpr ( key_bits == 128 ) {
; 614  :                 AES_128_Key_Expansion(key, round_keys);
; 615  :             }
; 616  :             else if constexpr ( key_bits == 192 ) {
; 617  :                 AES_192_Key_Expansion(key, round_keys);
; 618  :             }
; 619  :             else if constexpr ( key_bits == 256 ) {
; 620  :                 AES_256_Key_Expansion(key, round_keys);

	lea	r8, QWORD PTR aes$[rbp-256]
	mov	rdx, QWORD PTR key$[rsp]
	call	?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ; Cipher::Aes<256>::AES_256_Key_Expansion

; 713  :             state = _mm_xor_si128(state, xmm_round_keys[0]);

	mov	rdx, QWORD PTR req$[rsp]
	movdqu	xmm5, XMMWORD PTR [rdx]
	movdqu	xmm0, XMMWORD PTR aes$[rbp-256]
	xorps	xmm0, xmm5
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 65   :     BYTESTRING key = NetCommon::SerializeString(data.aesKey);

	lea	rax, QWORD PTR aes$[rbp-240]
	mov	ecx, 6
	npad	7
$LL54@AESEncrypt:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 717  :                 state = _mm_aesenc_si128(state, xmm_round_keys[i]);

	aesenc	xmm0, XMMWORD PTR [rax]

; 718  :                 state = _mm_aesenc_si128(state, xmm_round_keys[i + 1]);

	aesenc	xmm0, XMMWORD PTR [rax+16]

; 714  : 
; 715  :             // perform usual rounds
; 716  :             for ( size_t i = 1; i < Nr - 1; i += 2 ) {

	lea	rax, QWORD PTR [rax+32]
	sub	rcx, 1
	jne	SHORT $LL54@AESEncrypt

; 719  :             }
; 720  : 
; 721  :             // last round
; 722  :             state = _mm_aesenc_si128(state, xmm_round_keys[Nr - 1]);

	aesenc	xmm0, XMMWORD PTR aes$[rbp-48]

; 723  :             state = _mm_aesenclast_si128(state, xmm_round_keys[Nr]);

	aesenclast xmm0, XMMWORD PTR aes$[rbp-32]

; 724  : 
; 725  :             // store from register to array
; 726  :             _mm_storeu_si128(( __m128i* ) ( block ), state);

	movdqu	XMMWORD PTR [rdx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR req$[rsp+16]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	r9, r14
	mov	QWORD PTR req$[rsp+16], r14

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR req$[rsp+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR req$[rsp+8], r14

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR req$[rsp]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	r8, r14
	mov	QWORD PTR req$[rsp], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [rdi+8], rcx
	mov	QWORD PTR [rdi+16], rdx

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR key$[rsp]
	test	rcx, rcx
	je	SHORT $LN81@AESEncrypt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR key$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN100@AESEncrypt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN325@AESEncrypt
$LN100@AESEncrypt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR key$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR key$[rbp-240], r14
	mov	r9, QWORD PTR req$[rsp+16]
	mov	r8, QWORD PTR req$[rsp]
$LN81@AESEncrypt:

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	test	r8, r8
	je	SHORT $LN110@AESEncrypt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	r9, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r9, 4096				; 00001000H
	jb	SHORT $LN129@AESEncrypt

; 171  :     _Bytes += _Non_user_size;

	add	r9, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [r8-8]
	sub	rax, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN326@AESEncrypt
$LN129@AESEncrypt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r9
	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR req$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR req$[rsp+16], r14
$LN110@AESEncrypt:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 71   : }

	mov	rcx, rbx
	call	??1NET_BLOB@@QEAA@XZ
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+416]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
$LN326@AESEncrypt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN325@AESEncrypt:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN322@AESEncrypt:
?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z ENDP ; NetCommon::AESEncryptBlob
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 48
data$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
req$ = 88
key$ = 112
aes$ = 144
$T5 = 144
__$ArrayPad$ = 400
__$ReturnUdt$ = 448
data$ = 456
?dtor$0@?0??AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z@4HA PROC ; `NetCommon::AESEncryptBlob'::`1'::dtor$0
	mov	rcx, QWORD PTR data$GSCopy$[rdx]
	jmp	??1NET_BLOB@@QEAA@XZ
?dtor$0@?0??AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z@4HA ENDP ; `NetCommon::AESEncryptBlob'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 48
data$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
req$ = 88
key$ = 112
aes$ = 144
$T5 = 144
__$ArrayPad$ = 400
__$ReturnUdt$ = 448
data$ = 456
?dtor$3@?0??AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z@4HA PROC ; `NetCommon::AESEncryptBlob'::`1'::dtor$3
	lea	rcx, QWORD PTR req$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$3@?0??AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z@4HA ENDP ; `NetCommon::AESEncryptBlob'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1156 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z
_TEXT	SEGMENT
b$ = 48
?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z PROC		; NetCommon::IsBlobValid, COMDAT

; 102  :     inline BOOL IsBlobValid(NET_BLOB b) {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4279 :         return _Mypair._Myval2._Mysize == 0;

	cmp	QWORD PTR [rcx+232], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 103  :         return !b.aesKey.empty() && b.cr.valid || b.sr.valid || b.udp.isValid;

	je	SHORT $LN3@IsBlobVali
	cmp	DWORD PTR [rcx], 0
	jne	SHORT $LN4@IsBlobVali
$LN3@IsBlobVali:
	cmp	BYTE PTR [rcx+48], 0
	jne	SHORT $LN4@IsBlobVali
	cmp	DWORD PTR [rcx+212], 0
	jne	SHORT $LN4@IsBlobVali
	xor	ebx, ebx
	call	??1NET_BLOB@@QEAA@XZ
	mov	eax, ebx

; 104  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@IsBlobVali:

; 103  :         return !b.aesKey.empty() && b.cr.valid || b.sr.valid || b.udp.isValid;

	mov	ebx, 1
	call	??1NET_BLOB@@QEAA@XZ
	mov	eax, ebx

; 104  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z ENDP		; NetCommon::IsBlobValid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_1>::operator(), COMDAT

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 26548175		; 019517cfH
	mov	DWORD PTR [rbx], 366034020		; 15d13c64H
	mov	DWORD PTR [rbx+4], 1567007216		; 5d66a1f0H
	mov	WORD PTR [rbx+8], 15649			; 00003d21H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'', COMDAT

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 26548175		; 019517cfH
	mov	DWORD PTR [rbx], 366034020		; 15d13c64H
	mov	DWORD PTR [rbx+4], 1567007216		; 5d66a1f0H
	mov	WORD PTR [rbx+8], 15649			; 00003d21H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@6f55cd957ba3590f6f55cd957ba3590f
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, 8022544353138530575			; 6f55cd957ba3590fH
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_2>::operator(), COMDAT

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN21@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 379			; 0000017bH
	mov	DWORD PTR [rbx], 1231884053		; 496d0f15H
	mov	DWORD PTR [rbx+4], -1879768175		; 8ff50391H
	mov	BYTE PTR [rbx+8], 23
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'', COMDAT

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN42@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 379			; 0000017bH
	mov	DWORD PTR [rbx], 1231884053		; 496d0f15H
	mov	DWORD PTR [rbx+4], -1879768175		; 8ff50391H
	mov	BYTE PTR [rbx+8], 23
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN42@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+10], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN51@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@e3912dfd25097b7be3912dfd25097b7b
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN51@dynamic:
	mov	r9, -2048805790205510789		; e3912dfd25097b7bH
	npad	9
$LL50@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 10
	jb	SHORT $LL50@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+10], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_3>::operator(), COMDAT

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32315145		; 01ed1709H
	mov	DWORD PTR [rbx], 437478856		; 1a1365c8H
	mov	DWORD PTR [rbx+4], 1707624605		; 65c8489dH
	mov	WORD PTR [rbx+8], 25991			; 00006587H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'', COMDAT

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32315145		; 01ed1709H
	mov	DWORD PTR [rbx], 437478856		; 1a1365c8H
	mov	DWORD PTR [rbx+4], 1707624605		; 65c8489dH
	mov	WORD PTR [rbx+8], 25991			; 00006587H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@57fb21ed7b6501a957fb21ed7b6501a9
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, 6339698204315287977			; 57fb21ed7b6501a9H
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator(), COMDAT

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 20514000		; 013904d0H
	mov	DWORD PTR [rbx], 566812281		; 21c8de79H
	mov	DWORD PTR [rbx+4], -73973131		; fb974275H
	mov	WORD PTR [rbx+8], 50004			; 0000c354H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator(), COMDAT

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 21830513		; 014d1b71H
	mov	DWORD PTR [rbx], 1417610314		; 547f044aH
	mov	DWORD PTR [rbx+4], -552652404		; df0f318cH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator(), COMDAT

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 32738114		; 01f38b42H
	mov	DWORD PTR [rbx], 1286776928		; 4cb2a860H
	mov	DWORD PTR [rbx+4], -1621755363		; 9f55fa1dH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator(), COMDAT

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN16@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 23529225		; 01670709H
	mov	WORD PTR [rbx], 31831			; 00007c57H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator(), COMDAT

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN25@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+11], 457			; 000001c9H
	mov	DWORD PTR [rbx], -1159708678		; bae03ffaH
	mov	DWORD PTR [rbx+4], -1666390802		; 9cace4eeH
	mov	WORD PTR [rbx+8], 14066			; 000036f2H
	mov	BYTE PTR [rbx+10], -5
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN25@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator(), COMDAT

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN18@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 30794186		; 01d5e1caH
	mov	DWORD PTR [rbx], -293673836		; ee7ee494H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator(), COMDAT

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN16@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 26988016		; 019bcdf0H
	mov	WORD PTR [rbx], 13825			; 00003601H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator(), COMDAT

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN18@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 18427565		; 01192eadH
	mov	DWORD PTR [rbx], 1762755140		; 69118244H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator(), COMDAT

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN20@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+6], 26847760		; 0199aa10H
	mov	DWORD PTR [rbx], 500048619		; 1dce22ebH
	mov	WORD PTR [rbx+4], 1349			; 00000545H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN20@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator(), COMDAT

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN16@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 21339647		; 01459dffH
	mov	WORD PTR [rbx], 24308			; 00005ef4H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator(), COMDAT

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 17111976		; 01051ba8H
	mov	DWORD PTR [rbx], -398182262		; e844388aH
	mov	DWORD PTR [rbx+4], 325070019		; 13602cc3H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator(), COMDAT

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN19@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+7], 391			; 00000187H
	mov	DWORD PTR [rbx], -542647668		; dfa7da8cH
	mov	WORD PTR [rbx+4], 48710			; 0000be46H
	mov	BYTE PTR [rbx+6], 115			; 00000073H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	mov	BYTE PTR [rax+rdx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	BYTE PTR [rax+rdx+4], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	BYTE PTR [rax+rdx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+4], 0
	mov	BYTE PTR [rax+rdx+6], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	BYTE PTR [rax+rdx+4], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+4], 0
	mov	BYTE PTR [rax+rdx+6], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	ret	0
??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	BYTE PTR [rax+rdx+4], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	mov	BYTE PTR [rax+rdx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	mov	BYTE PTR [rax+rdx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<8,-8716755408375925265,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+8], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@8707dd23b1c9b5ef8707dd23b1c9b5ef
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, rcx

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+8], 0

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
$LN28@operator:
	mov	r9, -8716755408375925265		; 8707dd23b1c9b5efH
	npad	12
$LL27@operator:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 8
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+8], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<8,-8716755408375925265,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<8,-8716755408375925265,char>::~obfuscated_data<8,-8716755408375925265,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<8,-8716755408375925265,char>::~obfuscated_data<8,-8716755408375925265,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@1@@Z PROC ; ay::obfuscated_data<8,-8716755408375925265,char>::obfuscated_data<8,-8716755408375925265,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+8], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@1@@Z ENDP ; ay::obfuscated_data<8,-8716755408375925265,char>::obfuscated_data<8,-8716755408375925265,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,9007561748555066333,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -35			; ffffffffffffffddH
	xor	BYTE PTR [rcx+1], 107			; 0000006bH
	xor	BYTE PTR [rcx+2], 5
	xor	BYTE PTR [rcx+3], -85			; ffffffffffffffabH
	xor	BYTE PTR [rcx+4], -81			; ffffffffffffffafH
	xor	BYTE PTR [rcx+5], 73			; 00000049H
	xor	BYTE PTR [rcx+6], 1
	xor	BYTE PTR [rcx+7], 125			; 0000007dH
	xor	BYTE PTR [rcx+8], -35			; ffffffffffffffddH
	xor	BYTE PTR [rcx+9], 107			; 0000006bH
	xor	BYTE PTR [rcx+10], 5

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,9007561748555066333,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,9007561748555066333,char>::~obfuscated_data<11,9007561748555066333,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,9007561748555066333,char>::~obfuscated_data<11,9007561748555066333,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@1@@Z PROC ; ay::obfuscated_data<11,9007561748555066333,char>::obfuscated_data<11,9007561748555066333,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@1@@Z ENDP ; ay::obfuscated_data<11,9007561748555066333,char>::obfuscated_data<11,9007561748555066333,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<5,-3929642162503730297,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -121			; ffffffffffffff87H
	xor	BYTE PTR [rcx+1], 59			; 0000003bH
	xor	BYTE PTR [rcx+2], -111			; ffffffffffffff91H
	xor	BYTE PTR [rcx+3], -7
	xor	BYTE PTR [rcx+4], 69			; 00000045H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<5,-3929642162503730297,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<5,-3929642162503730297,char>::~obfuscated_data<5,-3929642162503730297,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<5,-3929642162503730297,char>::~obfuscated_data<5,-3929642162503730297,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@1@@Z PROC ; ay::obfuscated_data<5,-3929642162503730297,char>::obfuscated_data<5,-3929642162503730297,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+5], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@1@@Z ENDP ; ay::obfuscated_data<5,-3929642162503730297,char>::obfuscated_data<5,-3929642162503730297,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<9,-4071404544105560167,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+9], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -103			; ffffffffffffff99H
	xor	BYTE PTR [rcx+1], 71			; 00000047H
	xor	BYTE PTR [rcx+2], -83			; ffffffffffffffadH
	xor	BYTE PTR [rcx+3], 107			; 0000006bH
	xor	BYTE PTR [rcx+4], 35			; 00000023H
	xor	BYTE PTR [rcx+5], 119			; 00000077H
	xor	BYTE PTR [rcx+6], 127			; 0000007fH
	xor	BYTE PTR [rcx+7], -57			; ffffffffffffffc7H
	xor	BYTE PTR [rcx+8], -103			; ffffffffffffff99H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+9], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<9,-4071404544105560167,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<9,-4071404544105560167,char>::~obfuscated_data<9,-4071404544105560167,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+8], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<9,-4071404544105560167,char>::~obfuscated_data<9,-4071404544105560167,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@AEBV?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@AEBV?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@1@@Z PROC ; ay::obfuscated_data<9,-4071404544105560167,char>::obfuscated_data<9,-4071404544105560167,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+9], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@AEBV?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@1@@Z ENDP ; ay::obfuscated_data<9,-4071404544105560167,char>::obfuscated_data<9,-4071404544105560167,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<7,-7558938099074472137,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 55			; 00000037H
	xor	BYTE PTR [rcx+1], -25
	xor	BYTE PTR [rcx+2], 127			; 0000007fH
	xor	BYTE PTR [rcx+3], 13
	xor	BYTE PTR [rcx+4], -39			; ffffffffffffffd9H
	xor	BYTE PTR [rcx+5], 65			; 00000041H
	xor	BYTE PTR [rcx+6], 25

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<7,-7558938099074472137,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<7,-7558938099074472137,char>::~obfuscated_data<7,-7558938099074472137,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	WORD PTR [rcx+4], 0
	mov	BYTE PTR [rcx+6], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<7,-7558938099074472137,char>::~obfuscated_data<7,-7558938099074472137,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@1@@Z PROC ; ay::obfuscated_data<7,-7558938099074472137,char>::obfuscated_data<7,-7558938099074472137,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+7], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@1@@Z ENDP ; ay::obfuscated_data<7,-7558938099074472137,char>::obfuscated_data<7,-7558938099074472137,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<5,4171390554486297459,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 115			; 00000073H
	xor	BYTE PTR [rcx+1], 83			; 00000053H
	xor	BYTE PTR [rcx+2], -109			; ffffffffffffff93H
	xor	BYTE PTR [rcx+3], -69			; ffffffffffffffbbH
	xor	BYTE PTR [rcx+4], -101			; ffffffffffffff9bH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<5,4171390554486297459,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<5,4171390554486297459,char>::~obfuscated_data<5,4171390554486297459,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<5,4171390554486297459,char>::~obfuscated_data<5,4171390554486297459,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@AEBV?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@AEBV?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@1@@Z PROC ; ay::obfuscated_data<5,4171390554486297459,char>::obfuscated_data<5,4171390554486297459,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+5], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@AEBV?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@1@@Z ENDP ; ay::obfuscated_data<5,4171390554486297459,char>::obfuscated_data<5,4171390554486297459,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<7,-7217698246706230297,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -25
	xor	BYTE PTR [rcx+1], -117			; ffffffffffffff8bH
	xor	BYTE PTR [rcx+2], 29
	xor	BYTE PTR [rcx+3], -123			; ffffffffffffff85H
	xor	BYTE PTR [rcx+4], -81			; ffffffffffffffafH
	xor	BYTE PTR [rcx+5], -107			; ffffffffffffff95H
	xor	BYTE PTR [rcx+6], -43			; ffffffffffffffd5H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<7,-7217698246706230297,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<7,-7217698246706230297,char>::~obfuscated_data<7,-7217698246706230297,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	WORD PTR [rcx+4], 0
	mov	BYTE PTR [rcx+6], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<7,-7217698246706230297,char>::~obfuscated_data<7,-7217698246706230297,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@1@@Z PROC ; ay::obfuscated_data<7,-7217698246706230297,char>::obfuscated_data<7,-7217698246706230297,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+7], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@1@@Z ENDP ; ay::obfuscated_data<7,-7217698246706230297,char>::obfuscated_data<7,-7217698246706230297,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<12,-17003346941488231,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+12], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@ffc3978bc98f5399ffc3978bc98f5399
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, -17003346941488231			; ffc3978bc98f5399H
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 12
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+12], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<12,-17003346941488231,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<12,-17003346941488231,char>::~obfuscated_data<12,-17003346941488231,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<12,-17003346941488231,char>::~obfuscated_data<12,-17003346941488231,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@1@@Z PROC ; ay::obfuscated_data<12,-17003346941488231,char>::obfuscated_data<12,-17003346941488231,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+12], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@1@@Z ENDP ; ay::obfuscated_data<12,-17003346941488231,char>::obfuscated_data<12,-17003346941488231,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<5,-769018879138130635,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 53			; 00000035H
	xor	BYTE PTR [rcx+1], 21
	xor	BYTE PTR [rcx+2], 103			; 00000067H
	xor	BYTE PTR [rcx+3], 99			; 00000063H
	xor	BYTE PTR [rcx+4], 103			; 00000067H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<5,-769018879138130635,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<5,-769018879138130635,char>::~obfuscated_data<5,-769018879138130635,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<5,-769018879138130635,char>::~obfuscated_data<5,-769018879138130635,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@AEBV?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@AEBV?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@1@@Z PROC ; ay::obfuscated_data<5,-769018879138130635,char>::obfuscated_data<5,-769018879138130635,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+5], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@AEBV?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@1@@Z ENDP ; ay::obfuscated_data<5,-769018879138130635,char>::obfuscated_data<5,-769018879138130635,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,-1502061074894816457,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 55			; 00000037H
	xor	BYTE PTR [rcx+1], -5
	xor	BYTE PTR [rcx+2], -13
	xor	BYTE PTR [rcx+3], 31
	xor	BYTE PTR [rcx+4], 105			; 00000069H
	xor	BYTE PTR [rcx+5], -101			; ffffffffffffff9bH
	xor	BYTE PTR [rcx+6], 39			; 00000027H
	xor	BYTE PTR [rcx+7], -21
	xor	BYTE PTR [rcx+8], 55			; 00000037H
	xor	BYTE PTR [rcx+9], -5
	xor	BYTE PTR [rcx+10], -13

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,-1502061074894816457,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,-1502061074894816457,char>::~obfuscated_data<11,-1502061074894816457,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,-1502061074894816457,char>::~obfuscated_data<11,-1502061074894816457,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@1@@Z PROC ; ay::obfuscated_data<11,-1502061074894816457,char>::obfuscated_data<11,-1502061074894816457,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@1@@Z ENDP ; ay::obfuscated_data<11,-1502061074894816457,char>::obfuscated_data<11,-1502061074894816457,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,-4962681195322312931,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 29
	xor	BYTE PTR [rcx+1], 119			; 00000077H
	xor	BYTE PTR [rcx+2], 77			; 0000004dH
	xor	BYTE PTR [rcx+3], 11
	xor	BYTE PTR [rcx+4], -65			; ffffffffffffffbfH
	xor	BYTE PTR [rcx+5], 3
	xor	BYTE PTR [rcx+6], 33			; 00000021H
	xor	BYTE PTR [rcx+7], -69			; ffffffffffffffbbH
	xor	BYTE PTR [rcx+8], 29
	xor	BYTE PTR [rcx+9], 119			; 00000077H
	xor	BYTE PTR [rcx+10], 77			; 0000004dH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,-4962681195322312931,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,-4962681195322312931,char>::~obfuscated_data<11,-4962681195322312931,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,-4962681195322312931,char>::~obfuscated_data<11,-4962681195322312931,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@1@@Z PROC ; ay::obfuscated_data<11,-4962681195322312931,char>::obfuscated_data<11,-4962681195322312931,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@1@@Z ENDP ; ay::obfuscated_data<11,-4962681195322312931,char>::obfuscated_data<11,-4962681195322312931,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<13,-8505844796237434571,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@89f52b3945a9b13589f52b3945a9b135
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, -8505844796237434571		; 89f52b3945a9b135H
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<13,-8505844796237434571,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<13,-8505844796237434571,char>::~obfuscated_data<13,-8505844796237434571,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<13,-8505844796237434571,char>::~obfuscated_data<13,-8505844796237434571,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@1@@Z PROC ; ay::obfuscated_data<13,-8505844796237434571,char>::obfuscated_data<13,-8505844796237434571,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+13], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@1@@Z ENDP ; ay::obfuscated_data<13,-8505844796237434571,char>::obfuscated_data<13,-8505844796237434571,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?encrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z
_TEXT	SEGMENT
this$ = 8
block$ = 16
?encrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z PROC	; Cipher::Aes<256>::encrypt_block, COMDAT

; 707  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 708  :             // load the current block & current round key into the registers
; 709  :             __m128i* xmm_round_keys = ( __m128i* ) round_keys;
; 710  :             __m128i state = _mm_loadu_si128(( __m128i* ) & block[0]);
; 711  : 
; 712  :             // original key
; 713  :             state = _mm_xor_si128(state, xmm_round_keys[0]);

	movdqu	xmm0, XMMWORD PTR [rdx]
	lea	rax, QWORD PTR [rcx+16]
	mov	r8d, 6
	xorps	xmm0, XMMWORD PTR [rcx]
$LL4@encrypt_bl:

; 714  : 
; 715  :             // perform usual rounds
; 716  :             for ( size_t i = 1; i < Nr - 1; i += 2 ) {
; 717  :                 state = _mm_aesenc_si128(state, xmm_round_keys[i]);

	aesenc	xmm0, XMMWORD PTR [rax]

; 718  :                 state = _mm_aesenc_si128(state, xmm_round_keys[i + 1]);

	aesenc	xmm0, XMMWORD PTR [rax+16]
	lea	rax, QWORD PTR [rax+32]
	sub	r8, 1
	jne	SHORT $LL4@encrypt_bl

; 719  :             }
; 720  : 
; 721  :             // last round
; 722  :             state = _mm_aesenc_si128(state, xmm_round_keys[Nr - 1]);

	aesenc	xmm0, XMMWORD PTR [rcx+208]

; 723  :             state = _mm_aesenclast_si128(state, xmm_round_keys[Nr]);

	aesenclast xmm0, XMMWORD PTR [rcx+224]

; 724  : 
; 725  :             // store from register to array
; 726  :             _mm_storeu_si128(( __m128i* ) ( block ), state);

	movdqu	XMMWORD PTR [rdx], xmm0

; 727  : #elif defined(HARDWARE_ACCELERATION_ARM_NEON_AES)
; 728  :             uint8x16_t* neon_round_keys = ( uint8x16_t* ) round_keys;
; 729  :             uint8x16_t state = vld1q_u8(block);
; 730  : 
; 731  :             // Initial round
; 732  :             state = vaesmcq_u8(vaeseq_u8(state, neon_round_keys[0]));
; 733  : 
; 734  :             // 8 main rounds
; 735  :             for ( size_t i = 1; i < Nr - 1; i += 2 ) {
; 736  :                 state = vaesmcq_u8(vaeseq_u8(state, neon_round_keys[i]));
; 737  :                 state = vaesmcq_u8(vaeseq_u8(state, neon_round_keys[i + 1]));
; 738  :             }
; 739  : 
; 740  :             // last 2 final round
; 741  :             state = vaeseq_u8(state, neon_round_keys[Nr - 1]);
; 742  :             state = veorq_u8(state, neon_round_keys[Nr]);
; 743  : 
; 744  :             // store the result to block
; 745  :             vst1q_u8(block, state);
; 746  : #else
; 747  :             state_transpose(block);
; 748  : 
; 749  :             add_round_key(block, &round_keys[0]);
; 750  : 
; 751  :             for ( size_t round = 1; round <= Nr - 1; ++round ) {
; 752  :                 sub_bytes(block);
; 753  :                 shift_rows(block);
; 754  :                 mix_columns(block);
; 755  :                 add_round_key(block, &round_keys[round * Nb * 4]);
; 756  :             }
; 757  : 
; 758  :             sub_bytes(block);
; 759  :             shift_rows(block);
; 760  :             add_round_key(block, &round_keys[Nb * Nr * 4]);
; 761  : 
; 762  :             state_transpose(block);
; 763  : #endif
; 764  :         }

	ret	0
?encrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z ENDP	; Cipher::Aes<256>::encrypt_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1799 :         auto& _My_data = _Mypair._Myval2;
; 1800 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rax, rdx

; 1801 :     }

	ret	0
?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT

; 4279 :         return _Mypair._Myval2._Mysize == 0;

	cmp	QWORD PTR [rcx+16], 0
	sete	al

; 4280 :     }

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN11@c_str

; 4149 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 4150 :     }

	ret	0
$LN11@c_str:

; 4149 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 4150 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 47   :         this->_Adopt(_Pvector);
; 48   :     }

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<8,-8716755408375925265,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+8], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@8707dd23b1c9b5ef8707dd23b1c9b5ef
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+8], 0

; 151  : 			}
; 152  : 		}

	ret	0
$LN26@decrypt:
	mov	r9, -8716755408375925265		; 8707dd23b1c9b5efH
$LL25@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 8
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+8], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<8,-8716755408375925265,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<8,-8716755408375925265,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<8,-8716755408375925265,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,9007561748555066333,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -35			; ffffffffffffffddH
	xor	BYTE PTR [rcx+1], 107			; 0000006bH
	xor	BYTE PTR [rcx+2], 5
	xor	BYTE PTR [rcx+3], -85			; ffffffffffffffabH
	xor	BYTE PTR [rcx+4], -81			; ffffffffffffffafH
	xor	BYTE PTR [rcx+5], 73			; 00000049H
	xor	BYTE PTR [rcx+6], 1
	xor	BYTE PTR [rcx+7], 125			; 0000007dH
	xor	BYTE PTR [rcx+8], -35			; ffffffffffffffddH
	xor	BYTE PTR [rcx+9], 107			; 0000006bH
	xor	BYTE PTR [rcx+10], 5

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,9007561748555066333,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,9007561748555066333,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,9007561748555066333,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<5,-3929642162503730297,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -121			; ffffffffffffff87H
	xor	BYTE PTR [rcx+1], 59			; 0000003bH
	xor	BYTE PTR [rcx+2], -111			; ffffffffffffff91H
	xor	BYTE PTR [rcx+3], -7
	xor	BYTE PTR [rcx+4], 69			; 00000045H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<5,-3929642162503730297,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<5,-3929642162503730297,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<5,-3929642162503730297,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<9,-4071404544105560167,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+9], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -103			; ffffffffffffff99H
	xor	BYTE PTR [rcx+1], 71			; 00000047H
	xor	BYTE PTR [rcx+2], -83			; ffffffffffffffadH
	xor	BYTE PTR [rcx+3], 107			; 0000006bH
	xor	BYTE PTR [rcx+4], 35			; 00000023H
	xor	BYTE PTR [rcx+5], 119			; 00000077H
	xor	BYTE PTR [rcx+6], 127			; 0000007fH
	xor	BYTE PTR [rcx+7], -57			; ffffffffffffffc7H
	xor	BYTE PTR [rcx+8], -103			; ffffffffffffff99H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+9], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<9,-4071404544105560167,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<9,-4071404544105560167,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<9,-4071404544105560167,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<7,-7558938099074472137,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 55			; 00000037H
	xor	BYTE PTR [rcx+1], -25
	xor	BYTE PTR [rcx+2], 127			; 0000007fH
	xor	BYTE PTR [rcx+3], 13
	xor	BYTE PTR [rcx+4], -39			; ffffffffffffffd9H
	xor	BYTE PTR [rcx+5], 65			; 00000041H
	xor	BYTE PTR [rcx+6], 25

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<7,-7558938099074472137,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<7,-7558938099074472137,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<7,-7558938099074472137,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<5,4171390554486297459,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 115			; 00000073H
	xor	BYTE PTR [rcx+1], 83			; 00000053H
	xor	BYTE PTR [rcx+2], -109			; ffffffffffffff93H
	xor	BYTE PTR [rcx+3], -69			; ffffffffffffffbbH
	xor	BYTE PTR [rcx+4], -101			; ffffffffffffff9bH

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<5,4171390554486297459,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<5,4171390554486297459,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<5,4171390554486297459,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<7,-7217698246706230297,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -25
	xor	BYTE PTR [rcx+1], -117			; ffffffffffffff8bH
	xor	BYTE PTR [rcx+2], 29
	xor	BYTE PTR [rcx+3], -123			; ffffffffffffff85H
	xor	BYTE PTR [rcx+4], -81			; ffffffffffffffafH
	xor	BYTE PTR [rcx+5], -107			; ffffffffffffff95H
	xor	BYTE PTR [rcx+6], -43			; ffffffffffffffd5H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<7,-7217698246706230297,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<7,-7217698246706230297,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<7,-7217698246706230297,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<12,-17003346941488231,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+12], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@ffc3978bc98f5399ffc3978bc98f5399
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, -17003346941488231			; ffc3978bc98f5399H
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 12
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+12], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<12,-17003346941488231,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<12,-17003346941488231,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<12,-17003346941488231,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<5,-769018879138130635,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 53			; 00000035H
	xor	BYTE PTR [rcx+1], 21
	xor	BYTE PTR [rcx+2], 103			; 00000067H
	xor	BYTE PTR [rcx+3], 99			; 00000063H
	xor	BYTE PTR [rcx+4], 103			; 00000067H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<5,-769018879138130635,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<5,-769018879138130635,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<5,-769018879138130635,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,-1502061074894816457,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 55			; 00000037H
	xor	BYTE PTR [rcx+1], -5
	xor	BYTE PTR [rcx+2], -13
	xor	BYTE PTR [rcx+3], 31
	xor	BYTE PTR [rcx+4], 105			; 00000069H
	xor	BYTE PTR [rcx+5], -101			; ffffffffffffff9bH
	xor	BYTE PTR [rcx+6], 39			; 00000027H
	xor	BYTE PTR [rcx+7], -21
	xor	BYTE PTR [rcx+8], 55			; 00000037H
	xor	BYTE PTR [rcx+9], -5
	xor	BYTE PTR [rcx+10], -13

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,-1502061074894816457,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,-1502061074894816457,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,-1502061074894816457,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,-4962681195322312931,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 29
	xor	BYTE PTR [rcx+1], 119			; 00000077H
	xor	BYTE PTR [rcx+2], 77			; 0000004dH
	xor	BYTE PTR [rcx+3], 11
	xor	BYTE PTR [rcx+4], -65			; ffffffffffffffbfH
	xor	BYTE PTR [rcx+5], 3
	xor	BYTE PTR [rcx+6], 33			; 00000021H
	xor	BYTE PTR [rcx+7], -69			; ffffffffffffffbbH
	xor	BYTE PTR [rcx+8], 29
	xor	BYTE PTR [rcx+9], 119			; 00000077H
	xor	BYTE PTR [rcx+10], 77			; 0000004dH

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,-4962681195322312931,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,-4962681195322312931,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,-4962681195322312931,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<13,-8505844796237434571,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@89f52b3945a9b13589f52b3945a9b135
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, -8505844796237434571		; 89f52b3945a9b135H
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<13,-8505844796237434571,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<13,-8505844796237434571,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<13,-8505844796237434571,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1278 :     // check that [_First, _Last) forms an iterator range
; 1279 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1280 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1281 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1282 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1283 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1284 :         _Verify_range(_First, _Last);
; 1285 :     }
; 1286 : }

	ret	0
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_First$ = 72
_Last$ = 80
_Dest$ = 88
??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z PROC ; std::copy<char *,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >, COMDAT

; 4719 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

$LN20:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rcx

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rsi, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	mov	r8, rsi

; 4719 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

	mov	rbx, r9

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rcx, QWORD PTR [rsi+rbx]

; 4720 :     _STD _Adl_verify_range(_First, _Last);
; 4721 :     const auto _UFirst = _STD _Get_unwrapped(_First);
; 4722 :     const auto _ULast  = _STD _Get_unwrapped(_Last);
; 4723 :     const auto _UDest  = _STD _Get_unwrapped_n(_Dest, _STD _Idl_distance<_InIt>(_UFirst, _ULast));
; 4724 :     _STD _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));
; 4725 :     return _Dest;

	mov	rax, rdi
	mov	QWORD PTR [rdi], rcx

; 4726 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z ENDP ; std::copy<char *,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z PROC	; std::_Get_unwrapped<char * &>, COMDAT

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	ret	0
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ENDP	; std::_Get_unwrapped<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Idl_distance@PEADPEAD@std@@YA?A_PAEBQEAD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEADPEAD@std@@YA?A_PAEBQEAD0@Z PROC	; std::_Idl_distance<char *,char *>, COMDAT

; 1466 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1467 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1468 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]

; 1469 :     } else {
; 1470 :         return _Distance_unknown{};
; 1471 :     }
; 1472 : }

	ret	0
??$_Idl_distance@PEADPEAD@std@@YA?A_PAEBQEAD0@Z ENDP	; std::_Idl_distance<char *,char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z
_TEXT	SEGMENT
_It$ = 8
_Off$dead$ = 16
??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z PROC ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &,__int64>, COMDAT

; 1371 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1372 :         return _It + 0;
; 1373 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1374 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1375 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1376 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1377 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1378 : 
; 1379 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1380 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1381 :             "integer overflow");
; 1382 :         (void) _COff;
; 1383 : 
; 1384 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1385 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1386 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1387 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1388 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1389 :     } else {
; 1390 :         // pass through iterator that doesn't participate in checking
; 1391 :         return static_cast<_Iter&&>(_It);
; 1392 :     }
; 1393 : }

	ret	0
??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z ENDP ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped, COMDAT

; 345  :         return _STD _Unfancy_maybe_null(this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 346  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z
_TEXT	SEGMENT
this$dead$ = 8
_Off$dead$ = 16
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset, COMDAT

; 111  : #if _ITERATOR_DEBUG_LEVEL == 0
; 112  :         (void) _Off;
; 113  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 114  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 115  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 116  :         _STL_VERIFY(_Off == 0 || _Mycont, "cannot seek invalidated vector iterator");
; 117  :         if (_Off < 0) {
; 118  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 119  :         }
; 120  : 
; 121  :         if (_Off > 0) {
; 122  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 123  :         }
; 124  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
; 125  :     }

	ret	0
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z PROC ; std::_Copy_unchecked<char *,char *,unsigned char *>, COMDAT

; 4688 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4689 :     // copy [_First, _Last) to [_Dest, ...)
; 4690 :     // note: _Copy_unchecked has callers other than the copy family
; 4691 :     if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
; 4692 :         return _STD _Copy_vbool(_First, _Last, _Dest);
; 4693 :     } else {
; 4694 :         if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {
; 4695 : #if _HAS_CXX20
; 4696 :             if (!_STD is_constant_evaluated())
; 4697 : #endif // _HAS_CXX20
; 4698 :             {
; 4699 : #if _HAS_CXX20
; 4700 :                 if constexpr (!is_same_v<_InIt, _Sent>) {
; 4701 :                     return _STD _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
; 4702 :                 } else
; 4703 : #endif // _HAS_CXX20
; 4704 :                 {
; 4705 :                     return _STD _Copy_memmove(_First, _Last, _Dest);
; 4706 :                 }
; 4707 :             }
; 4708 :         }
; 4709 : 
; 4710 :         for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4711 :             *_Dest = *_First;
; 4712 :         }
; 4713 : 
; 4714 :         return _Dest;
; 4715 :     }
; 4716 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z ENDP ; std::_Copy_unchecked<char *,char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>, COMDAT

; 1405 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1406 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1407 :     } else {
; 1408 :         _It = _STD forward<_UIter>(_UIt);
; 1409 :     }
; 1410 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z
_TEXT	SEGMENT
this$ = 8
_It$ = 16
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to, COMDAT

; 221  :         _Ptr = _STD _Refancy_maybe_null<_Tptr>(const_cast<value_type*>(_It));

	mov	QWORD PTR [rcx], rdx

; 222  :     }

	ret	0
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z PROC	; std::_Copy_memmove<char *,unsigned char *>, COMDAT

; 4613 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4614 :     auto _FirstPtr              = _STD _To_address(_First);
; 4615 :     auto _LastPtr               = _STD _To_address(_Last);
; 4616 :     auto _DestPtr               = _STD _To_address(_Dest);
; 4617 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4618 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4619 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4624 :     } else {
; 4625 :         return _Dest + (_LastPtr - _FirstPtr);
; 4626 :     }
; 4627 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z ENDP	; std::_Copy_memmove<char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z PROC		; std::_To_address<char *>, COMDAT

; 4482 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4483 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4484 : }

	ret	0
??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z ENDP		; std::_To_address<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z PROC	; std::_Refancy_maybe_null<unsigned char *,0>, COMDAT

; 282  :     return _Ptr;

	mov	rax, rcx

; 283  : }

	ret	0
??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z ENDP	; std::_Refancy_maybe_null<unsigned char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$to_address@D@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@D@std@@YAPEADQEAD@Z PROC			; std::to_address<char>, COMDAT

; 453  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 454  :     return _Val;

	mov	rax, rcx

; 455  : }

	ret	0
??$to_address@D@std@@YAPEADQEAD@Z ENDP			; std::to_address<char>
_TEXT	ENDS
END
