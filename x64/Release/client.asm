; Listing generated by Microsoft (R) Optimizing Compiler Version 19.40.33811.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
EXTRN	__tlregdtor:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__std_terminate:PROC
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	__std_exception_copy:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__std_exception_destroy:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__CxxFrameHandler4:PROC
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &,0>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z	; std::construct_at<char,0>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$?0AEAPEAD@?$_Compressed_pair@U?$default_delete@$$BY0A@D@std@@PEAD$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAD@Z ; std::_Compressed_pair<std::default_delete<char [0]>,char *,1>::_Compressed_pair<std::default_delete<char [0]>,char *,1><char * &>
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$?0PEADU?$default_delete@$$BY0A@D@std@@$0A@$0A@@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@PEAD@Z ; std::unique_ptr<char [0],std::default_delete<char [0]> >::unique_ptr<char [0],std::default_delete<char [0]> ><char *,std::default_delete<char [0]>,0,0>
PUBLIC	??$forward@AEBD@std@@YAAEBDAEBD@Z		; std::forward<char const &>
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z	; std::construct_at<char,char const &,0>
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?RD$0A@@?$default_delete@$$BY0A@D@std@@QEBAXPEAD@Z ; std::default_delete<char [0]>::operator()<char,0>
PUBLIC	??$make_unique@$$BY0A@D$0A@@std@@YA?AV?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@0@_K@Z ; std::make_unique<char [0],0>
PUBLIC	??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>
PUBLIC	??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>
PUBLIC	??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
PUBLIC	??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>
PUBLIC	?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?data@?$obfuscator@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEBAPEBDXZ ; ay::obfuscator<13,-3668875623370088579,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAAXXZ ; ay::obfuscated_data<13,-3668875623370088579,char>::decrypt
PUBLIC	?data@?$obfuscator@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ ; ay::obfuscator<10,8022544353138530575,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ ; ay::obfuscated_data<10,8022544353138530575,char>::decrypt
PUBLIC	?data@?$obfuscator@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ ; ay::obfuscator<13,-2048805790205510789,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ ; ay::obfuscated_data<13,-2048805790205510789,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,-7558938099074472137,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,-7558938099074472137,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,-4509840863236766927,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,-4509840863236766927,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,8022544353138530575,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,8022544353138530575,char>::decrypt
PUBLIC	?data@?$obfuscator@$04$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ ; ay::obfuscator<5,-2048805790205510789,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ ; ay::obfuscated_data<5,-2048805790205510789,char>::decrypt
PUBLIC	?data@?$obfuscator@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<12,6339698204315287977,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<12,6339698204315287977,char>::decrypt
PUBLIC	?data@?$obfuscator@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEBAPEBDXZ ; ay::obfuscator<7,-2638032247341472419,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAAXXZ ; ay::obfuscated_data<7,-2638032247341472419,char>::decrypt
PUBLIC	?data@?$obfuscator@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<5,6185075688865743849,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<5,6185075688865743849,char>::decrypt
PUBLIC	?data@?$obfuscator@$06$0?OLMMGBCGKAANADB@D@ay@@QEBAPEBDXZ ; ay::obfuscator<7,-1061941394542743601,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAAXXZ ; ay::obfuscated_data<7,-1061941394542743601,char>::decrypt
PUBLIC	?data@?$obfuscator@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEBAPEBDXZ ; ay::obfuscator<9,1947751379898066285,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAAXXZ ; ay::obfuscated_data<9,1947751379898066285,char>::decrypt
PUBLIC	?data@?$obfuscator@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<5,2983409589604555257,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<5,2983409589604555257,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0?CLAAOECFMICOACN@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,-193670462159642669,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,-193670462159642669,char>::decrypt
PUBLIC	?data@?$obfuscator@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEBAPEBDXZ ; ay::obfuscator<8,-9148647708104107571,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAAXXZ ; ay::obfuscated_data<8,-9148647708104107571,char>::decrypt
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@D@std@@PEAD$00@std@@QEAAAEAU?$default_delete@$$BY0A@D@2@XZ ; std::_Compressed_pair<std::default_delete<char [0]>,char *,1>::_Get_first
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?DCOKHGPAOABAGAID@D@1@@Z ; ay::obfuscated_data<13,-3668875623370088579,char>::obfuscated_data<13,-3668875623370088579,char>
PUBLIC	??1?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAA@XZ ; ay::obfuscated_data<13,-3668875623370088579,char>::~obfuscated_data<13,-3668875623370088579,char>
PUBLIC	??B?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<13,-3668875623370088579,char>::operator char *
PUBLIC	??0?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$09$0GPFFMNJFHLKDFJAP@D@1@@Z ; ay::obfuscated_data<10,8022544353138530575,char>::obfuscated_data<10,8022544353138530575,char>
PUBLIC	??1?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ ; ay::obfuscated_data<10,8022544353138530575,char>::~obfuscated_data<10,8022544353138530575,char>
PUBLIC	??B?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<10,8022544353138530575,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?BMGONCACNKPGIEIF@D@1@@Z ; ay::obfuscated_data<13,-2048805790205510789,char>::obfuscated_data<13,-2048805790205510789,char>
PUBLIC	??1?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ ; ay::obfuscated_data<13,-2048805790205510789,char>::~obfuscated_data<13,-2048805790205510789,char>
PUBLIC	??B?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<13,-2048805790205510789,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?GIOGLOCGPCIABIMJ@D@1@@Z ; ay::obfuscated_data<11,-7558938099074472137,char>::obfuscated_data<11,-7558938099074472137,char>
PUBLIC	??1?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,-7558938099074472137,char>::~obfuscated_data<11,-7558938099074472137,char>
PUBLIC	??B?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,-7558938099074472137,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@1@@Z ; ay::obfuscated_data<11,-4509840863236766927,char>::obfuscated_data<11,-4509840863236766927,char>
PUBLIC	??1?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,-4509840863236766927,char>::~obfuscated_data<11,-4509840863236766927,char>
PUBLIC	??B?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,-4509840863236766927,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0GPFFMNJFHLKDFJAP@D@1@@Z ; ay::obfuscated_data<11,8022544353138530575,char>::obfuscated_data<11,8022544353138530575,char>
PUBLIC	??1?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,8022544353138530575,char>::~obfuscated_data<11,8022544353138530575,char>
PUBLIC	??B?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,8022544353138530575,char>::operator char *
PUBLIC	??0?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$04$0?BMGONCACNKPGIEIF@D@1@@Z ; ay::obfuscated_data<5,-2048805790205510789,char>::obfuscated_data<5,-2048805790205510789,char>
PUBLIC	??1?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ ; ay::obfuscated_data<5,-2048805790205510789,char>::~obfuscated_data<5,-2048805790205510789,char>
PUBLIC	??B?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<5,-2048805790205510789,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0FHPLCBONHLGFABKJ@D@1@@Z ; ay::obfuscated_data<12,6339698204315287977,char>::obfuscated_data<12,6339698204315287977,char>
PUBLIC	??1?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<12,6339698204315287977,char>::~obfuscated_data<12,6339698204315287977,char>
PUBLIC	??B?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<12,6339698204315287977,char>::operator char *
PUBLIC	??0?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAA@AEBV?$obfuscator@$06$0?CEJMCMFKCANAFKKD@D@1@@Z ; ay::obfuscated_data<7,-2638032247341472419,char>::obfuscated_data<7,-2638032247341472419,char>
PUBLIC	??1?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAA@XZ ; ay::obfuscated_data<7,-2638032247341472419,char>::~obfuscated_data<7,-2638032247341472419,char>
PUBLIC	??B?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<7,-2638032247341472419,char>::operator char *
PUBLIC	??0?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0FFNFMNJBKPLPEDOJ@D@1@@Z ; ay::obfuscated_data<5,6185075688865743849,char>::obfuscated_data<5,6185075688865743849,char>
PUBLIC	??1?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<5,6185075688865743849,char>::~obfuscated_data<5,6185075688865743849,char>
PUBLIC	??B?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<5,6185075688865743849,char>::operator char *
PUBLIC	??0?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAA@AEBV?$obfuscator@$06$0?OLMMGBCGKAANADB@D@1@@Z ; ay::obfuscated_data<7,-1061941394542743601,char>::obfuscated_data<7,-1061941394542743601,char>
PUBLIC	??1?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAA@XZ ; ay::obfuscated_data<7,-1061941394542743601,char>::~obfuscated_data<7,-1061941394542743601,char>
PUBLIC	??B?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<7,-1061941394542743601,char>::operator char *
PUBLIC	??0?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAA@AEBV?$obfuscator@$08$0BLAHMNIPHFJJOFGN@D@1@@Z ; ay::obfuscated_data<9,1947751379898066285,char>::obfuscated_data<9,1947751379898066285,char>
PUBLIC	??1?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAA@XZ ; ay::obfuscated_data<9,1947751379898066285,char>::~obfuscated_data<9,1947751379898066285,char>
PUBLIC	??B?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<9,1947751379898066285,char>::operator char *
PUBLIC	??0?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0CJGHDDDHAHNPJJPJ@D@1@@Z ; ay::obfuscated_data<5,2983409589604555257,char>::obfuscated_data<5,2983409589604555257,char>
PUBLIC	??1?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<5,2983409589604555257,char>::~obfuscated_data<5,2983409589604555257,char>
PUBLIC	??B?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<5,2983409589604555257,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?CLAAOECFMICOACN@D@1@@Z ; ay::obfuscated_data<11,-193670462159642669,char>::obfuscated_data<11,-193670462159642669,char>
PUBLIC	??1?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,-193670462159642669,char>::~obfuscated_data<11,-193670462159642669,char>
PUBLIC	??B?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,-193670462159642669,char>::operator char *
PUBLIC	??0?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HOPGIGJOHALMKGDD@D@1@@Z ; ay::obfuscated_data<8,-9148647708104107571,char>::obfuscated_data<8,-9148647708104107571,char>
PUBLIC	??1?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAA@XZ ; ay::obfuscated_data<8,-9148647708104107571,char>::~obfuscated_data<8,-9148647708104107571,char>
PUBLIC	??B?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<8,-9148647708104107571,char>::operator char *
PUBLIC	??1?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@XZ ; std::unique_ptr<char [0],std::default_delete<char [0]> >::~unique_ptr<char [0],std::default_delete<char [0]> >
PUBLIC	?get@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEBAPEADXZ ; std::unique_ptr<char [0],std::default_delete<char [0]> >::get
PUBLIC	?Disconnect@Client@@QEAAHXZ			; Client::Disconnect
PUBLIC	?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z ; Client::MakeServerRequest
PUBLIC	?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ; Client::TCPSendMessageToServer
PUBLIC	?__autoclassinit2@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAAX_K@Z ; std::unique_ptr<char [0],std::default_delete<char [0]> >::__autoclassinit2
PUBLIC	?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ; Client::UDPSendMessageToServer
PUBLIC	?SocketReady@Client@@IEBAHW4SocketTypes@@@Z	; Client::SocketReady
PUBLIC	?Connect@Client@@QEAAHXZ			; Client::Connect
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	?LoadWSAFunctions@Client@@IEAAXXZ		; Client::LoadWSAFunctions
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??1Client@@QEAA@XZ				; Client::~Client
PUBLIC	??0Client@@QEAA@XZ				; Client::Client
PUBLIC	??$cipher@D@ay@@YAXPEAD_K1@Z			; ay::cipher<char>
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	__isa_available_default
PUBLIC	__real@5f000000
PUBLIC	__xmm@00000000000000010000000000000000
PUBLIC	__xmm@00000000000000030000000000000002
PUBLIC	__xmm@00000000000000050000000000000004
PUBLIC	__xmm@00000000000000070000000000000006
PUBLIC	__xmm@00000000000000070000000000000007
PUBLIC	__xmm@000000000000000f0000000000000000
PUBLIC	__xmm@00000000000008000000000000000800
PUBLIC	__xmm@01f3b16f0d3d333d01f3b16f0d3d333d
PUBLIC	__xmm@1b75bd1119a31f5d1b75bd1119a31f5d
PUBLIC	__xmm@23f641f88890a04725f266d29f96bc60
PUBLIC	__xmm@27cf676ff1953f9d27cf676ff1953f9d
PUBLIC	__xmm@434c2d63eef5f7881e2b387beaf8e9a4
PUBLIC	__xmm@579735abedf3c931579735abedf3c931
PUBLIC	__xmm@57fb21ed7b6501a957fb21ed7b6501a9
PUBLIC	__xmm@6f55cd957ba3590f6f55cd957ba3590f
PUBLIC	__xmm@717f5d0f8b9d9be7717f5d0f8b9d9be7
PUBLIC	__xmm@7d21cb4597bfa7d17d21cb4597bfa7d1
PUBLIC	__xmm@810979618f4359cd810979618f4359cd
PUBLIC	__xmm@8300095be457589db8010043f65659a7
PUBLIC	__xmm@8548e83236e44a0c8371da3524e45b20
PUBLIC	__xmm@96b046b2cf9ec9ac9db852afe68bd084
PUBLIC	__xmm@99c9b36339a1399199c9b36339a13991
PUBLIC	__xmm@ad7941110d6b2541ad7941110d6b2541
PUBLIC	__xmm@b4e9824d098f09bfaefb82435ecf50e1
PUBLIC	__xmm@bba969eff327f753bba969eff327f753
PUBLIC	__xmm@c80d32685e375636c21d2f785a371f02
PUBLIC	__xmm@cd15890f1fef9f7dcd15890f1fef9f7d
PUBLIC	__xmm@da590a3e2d0e5d24831d2c725159162c
PUBLIC	__xmm@e3912dfd25097b7be3912dfd25097b7b
PUBLIC	__xmm@e528cb6c095e11a3d60ccc7a185825c1
PUBLIC	__xmm@e57fbf1f7b375791e57fbf1f7b375791
PUBLIC	__xmm@ebe1417985296fdfebe1417985296fdf
PUBLIC	__xmm@f121bf4145812963f121bf4145812963
PUBLIC	__xmm@f165653785232bf3f165653785232bf3
PUBLIC	__xmm@f3d721dd83fbbdcdf3d721dd83fbbdcd
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_CxxThrowException:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	ceilf:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	__isa_available:DWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A DB 06H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4V45@A DB 06H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4V45@A DB 06H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A DB 0cH DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4V45@A DQ 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4V45@A DQ 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4V45@A DB 0cH DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V34@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V34@A DB 0cH DUP (?) ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A DB 0dH DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4V45@A DB 0aH DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A DB 0bH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@51 DD 01H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4V45@A DB 09H DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::obfuscated_data
?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::kernel32
?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::ntdll
?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::advapi32
_BSS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V45@A DB 0cH DUP (?) ; ``Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT __isa_available_default
_BSS	SEGMENT
__isa_available_default DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+58
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN27
	DD	imagerel $LN27+88
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN30
	DD	imagerel $LN30+88
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN33
	DD	imagerel $LN33+91
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN52
	DD	imagerel $LN52+110
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN20
	DD	imagerel $LN20+52
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN99
	DD	imagerel $LN99+242
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN97
	DD	imagerel $LN97+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN97+78
	DD	imagerel $LN97+233
	DD	imagerel $chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN97+233
	DD	imagerel $LN97+245
	DD	imagerel $chain$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN97+245
	DD	imagerel $LN97+251
	DD	imagerel $chain$3$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@$$BY0A@D$0A@@std@@YA?AV?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@0@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+52
	DD	imagerel $unwind$??$make_unique@$$BY0A@D$0A@@std@@YA?AV?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN23
	DD	imagerel $LN23+61
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN16
	DD	imagerel $LN16+23
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN27
	DD	imagerel $LN27+62
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN38
	DD	imagerel $LN38+94
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN123
	DD	imagerel $LN123+276
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN117
	DD	imagerel $LN117+285
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+94
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Disconnect@Client@@QEAAHXZ DD imagerel $LN16
	DD	imagerel $LN16+51
	DD	imagerel $unwind$?Disconnect@Client@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z DD imagerel $LN19
	DD	imagerel $LN19+100
	DD	imagerel $unwind$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DD imagerel $LN16
	DD	imagerel $LN16+60
	DD	imagerel $unwind$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DD imagerel $LN54
	DD	imagerel $LN54+234
	DD	imagerel $unwind$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Connect@Client@@QEAAHXZ DD imagerel $LN16
	DD	imagerel $LN16+177
	DD	imagerel $unwind$?Connect@Client@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ DD imagerel ??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ
	DD	imagerel ??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ+107
	DD	imagerel $unwind$??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ DD imagerel ??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ
	DD	imagerel ??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ+105
	DD	imagerel $unwind$??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ DD imagerel ??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ
	DD	imagerel ??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ+97
	DD	imagerel $unwind$??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ DD imagerel ??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ
	DD	imagerel ??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ+104
	DD	imagerel $unwind$??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ DD imagerel ??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ
	DD	imagerel ??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ+98
	DD	imagerel $unwind$??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ DD imagerel ??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ
	DD	imagerel ??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ+97
	DD	imagerel $unwind$??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ DD imagerel ??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ
	DD	imagerel ??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ+98
	DD	imagerel $unwind$??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD imagerel ??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel ??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ+114
	DD	imagerel $unwind$??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ DD imagerel ??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ+97
	DD	imagerel $unwind$??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD imagerel ??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ+105
	DD	imagerel $unwind$??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DD imagerel ??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ+105
	DD	imagerel $unwind$??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LoadWSAFunctions@Client@@IEAAXXZ DD imagerel $LN805
	DD	imagerel $LN805+2770
	DD	imagerel $unwind$?LoadWSAFunctions@Client@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$11@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$11@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$11@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$11@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$12@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$12@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$12@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$12@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$16@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$16@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$16@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$16@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$17@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$17@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$17@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$17@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$21@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$21@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$21@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$21@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$25@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$25@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$25@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$25@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$29@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$29@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$29@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$29@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$33@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$33@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$33@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$33@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$37@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$37@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$37@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$37@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$41@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$41@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$41@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$41@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$45@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD imagerel ?dtor$45@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DD	imagerel ?dtor$45@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$45@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DD imagerel ??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ+105
	DD	imagerel $unwind$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Client@@QEAA@XZ DD imagerel $LN102
	DD	imagerel $LN102+293
	DD	imagerel $unwind$??1Client@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Client@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+237
	DD	imagerel $unwind$??0Client@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DD imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ+108
	DD	imagerel $unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DD imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$cipher@D@ay@@YAXPEAD_K1@Z DD imagerel $LN29
	DD	imagerel $LN29+88
	DD	imagerel $unwind$??$cipher@D@ay@@YAXPEAD_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$cipher@D@ay@@YAXPEAD_K1@Z DD imagerel $LN29+88
	DD	imagerel $LN29+368
	DD	imagerel $chain$1$??$cipher@D@ay@@YAXPEAD_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$cipher@D@ay@@YAXPEAD_K1@Z DD imagerel $LN29+368
	DD	imagerel $LN29+400
	DD	imagerel $chain$2$??$cipher@D@ay@@YAXPEAD_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+42
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN9
	DD	imagerel $LN9+60
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN14
	DD	imagerel $LN14+60
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN22
	DD	imagerel $LN22+66
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+66
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kernel32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::kernel32$initializer$
;	COMDAT __xmm@f3d721dd83fbbdcdf3d721dd83fbbdcd
CONST	SEGMENT
__xmm@f3d721dd83fbbdcdf3d721dd83fbbdcd DB 0cdH, 0bdH, 0fbH, 083H, 0ddH, '!'
	DB	0d7H, 0f3H, 0cdH, 0bdH, 0fbH, 083H, 0ddH, '!', 0d7H, 0f3H
CONST	ENDS
;	COMDAT __xmm@f165653785232bf3f165653785232bf3
CONST	SEGMENT
__xmm@f165653785232bf3f165653785232bf3 DB 0f3H, '+#', 085H, '7ee', 0f1H, 0f3H
	DB	'+#', 085H, '7ee', 0f1H
CONST	ENDS
;	COMDAT __xmm@f121bf4145812963f121bf4145812963
CONST	SEGMENT
__xmm@f121bf4145812963f121bf4145812963 DB 'c)', 081H, 'EA', 0bfH, '!', 0f1H
	DB	'c)', 081H, 'EA', 0bfH, '!', 0f1H
CONST	ENDS
;	COMDAT __xmm@ebe1417985296fdfebe1417985296fdf
CONST	SEGMENT
__xmm@ebe1417985296fdfebe1417985296fdf DB 0dfH, 'o)', 085H, 'yA', 0e1H, 0ebH
	DB	0dfH, 'o)', 085H, 'yA', 0e1H, 0ebH
CONST	ENDS
;	COMDAT __xmm@e57fbf1f7b375791e57fbf1f7b375791
CONST	SEGMENT
__xmm@e57fbf1f7b375791e57fbf1f7b375791 DB 091H, 'W7{', 01fH, 0bfH, 07fH, 0e5H
	DB	091H, 'W7{', 01fH, 0bfH, 07fH, 0e5H
CONST	ENDS
;	COMDAT __xmm@e528cb6c095e11a3d60ccc7a185825c1
CONST	SEGMENT
__xmm@e528cb6c095e11a3d60ccc7a185825c1 DB 0c1H, '%X', 018H, 'z', 0ccH, 0cH
	DB	0d6H, 0a3H, 011H, '^', 09H, 'l', 0cbH, '(', 0e5H
CONST	ENDS
;	COMDAT __xmm@e3912dfd25097b7be3912dfd25097b7b
CONST	SEGMENT
__xmm@e3912dfd25097b7be3912dfd25097b7b DB '{{', 09H, '%', 0fdH, '-', 091H
	DB	0e3H, '{{', 09H, '%', 0fdH, '-', 091H, 0e3H
CONST	ENDS
;	COMDAT __xmm@da590a3e2d0e5d24831d2c725159162c
CONST	SEGMENT
__xmm@da590a3e2d0e5d24831d2c725159162c DB ',', 016H, 'YQr,', 01dH, 083H, '$'
	DB	']', 0eH, '->', 0aH, 'Y', 0daH
CONST	ENDS
;	COMDAT __xmm@cd15890f1fef9f7dcd15890f1fef9f7d
CONST	SEGMENT
__xmm@cd15890f1fef9f7dcd15890f1fef9f7d DB '}', 09fH, 0efH, 01fH, 0fH, 089H
	DB	015H, 0cdH, '}', 09fH, 0efH, 01fH, 0fH, 089H, 015H, 0cdH
CONST	ENDS
;	COMDAT __xmm@c80d32685e375636c21d2f785a371f02
CONST	SEGMENT
__xmm@c80d32685e375636c21d2f785a371f02 DB 02H, 01fH, '7Zx/', 01dH, 0c2H, '6'
	DB	'V7^h2', 0dH, 0c8H
CONST	ENDS
;	COMDAT __xmm@bba969eff327f753bba969eff327f753
CONST	SEGMENT
__xmm@bba969eff327f753bba969eff327f753 DB 'S', 0f7H, '''', 0f3H, 0efH, 'i'
	DB	0a9H, 0bbH, 'S', 0f7H, '''', 0f3H, 0efH, 'i', 0a9H, 0bbH
CONST	ENDS
;	COMDAT __xmm@b4e9824d098f09bfaefb82435ecf50e1
CONST	SEGMENT
__xmm@b4e9824d098f09bfaefb82435ecf50e1 DB 0e1H, 'P', 0cfH, '^C', 082H, 0fbH
	DB	0aeH, 0bfH, 09H, 08fH, 09H, 'M', 082H, 0e9H, 0b4H
CONST	ENDS
;	COMDAT __xmm@ad7941110d6b2541ad7941110d6b2541
CONST	SEGMENT
__xmm@ad7941110d6b2541ad7941110d6b2541 DB 'A%k', 0dH, 011H, 'Ay', 0adH, 'A'
	DB	'%k', 0dH, 011H, 'Ay', 0adH
CONST	ENDS
;	COMDAT __xmm@99c9b36339a1399199c9b36339a13991
CONST	SEGMENT
__xmm@99c9b36339a1399199c9b36339a13991 DB 091H, '9', 0a1H, '9c', 0b3H, 0c9H
	DB	099H, 091H, '9', 0a1H, '9c', 0b3H, 0c9H, 099H
CONST	ENDS
;	COMDAT __xmm@96b046b2cf9ec9ac9db852afe68bd084
CONST	SEGMENT
__xmm@96b046b2cf9ec9ac9db852afe68bd084 DB 084H, 0d0H, 08bH, 0e6H, 0afH, 'R'
	DB	0b8H, 09dH, 0acH, 0c9H, 09eH, 0cfH, 0b2H, 'F', 0b0H, 096H
CONST	ENDS
;	COMDAT __xmm@8548e83236e44a0c8371da3524e45b20
CONST	SEGMENT
__xmm@8548e83236e44a0c8371da3524e45b20 DB ' [', 0e4H, '$5', 0daH, 'q', 083H
	DB	0cH, 'J', 0e4H, '62', 0e8H, 'H', 085H
CONST	ENDS
;	COMDAT __xmm@8300095be457589db8010043f65659a7
CONST	SEGMENT
__xmm@8300095be457589db8010043f65659a7 DB 0a7H, 'YV', 0f6H, 'C', 00H, 01H
	DB	0b8H, 09dH, 'XW', 0e4H, '[', 09H, 00H, 083H
CONST	ENDS
;	COMDAT __xmm@810979618f4359cd810979618f4359cd
CONST	SEGMENT
__xmm@810979618f4359cd810979618f4359cd DB 0cdH, 'YC', 08fH, 'ay', 09H, 081H
	DB	0cdH, 'YC', 08fH, 'ay', 09H, 081H
CONST	ENDS
;	COMDAT __xmm@7d21cb4597bfa7d17d21cb4597bfa7d1
CONST	SEGMENT
__xmm@7d21cb4597bfa7d17d21cb4597bfa7d1 DB 0d1H, 0a7H, 0bfH, 097H, 'E', 0cbH
	DB	'!}', 0d1H, 0a7H, 0bfH, 097H, 'E', 0cbH, '!}'
CONST	ENDS
;	COMDAT __xmm@717f5d0f8b9d9be7717f5d0f8b9d9be7
CONST	SEGMENT
__xmm@717f5d0f8b9d9be7717f5d0f8b9d9be7 DB 0e7H, 09bH, 09dH, 08bH, 0fH, ']'
	DB	07fH, 'q', 0e7H, 09bH, 09dH, 08bH, 0fH, ']', 07fH, 'q'
CONST	ENDS
;	COMDAT __xmm@6f55cd957ba3590f6f55cd957ba3590f
CONST	SEGMENT
__xmm@6f55cd957ba3590f6f55cd957ba3590f DB 0fH, 'Y', 0a3H, '{', 095H, 0cdH
	DB	'Uo', 0fH, 'Y', 0a3H, '{', 095H, 0cdH, 'Uo'
CONST	ENDS
;	COMDAT __xmm@57fb21ed7b6501a957fb21ed7b6501a9
CONST	SEGMENT
__xmm@57fb21ed7b6501a957fb21ed7b6501a9 DB 0a9H, 01H, 'e{', 0edH, '!', 0fbH
	DB	'W', 0a9H, 01H, 'e{', 0edH, '!', 0fbH, 'W'
CONST	ENDS
;	COMDAT __xmm@579735abedf3c931579735abedf3c931
CONST	SEGMENT
__xmm@579735abedf3c931579735abedf3c931 DB '1', 0c9H, 0f3H, 0edH, 0abH, '5'
	DB	097H, 'W1', 0c9H, 0f3H, 0edH, 0abH, '5', 097H, 'W'
CONST	ENDS
;	COMDAT __xmm@434c2d63eef5f7881e2b387beaf8e9a4
CONST	SEGMENT
__xmm@434c2d63eef5f7881e2b387beaf8e9a4 DB 0a4H, 0e9H, 0f8H, 0eaH, '{8+', 01eH
	DB	088H, 0f7H, 0f5H, 0eeH, 'c-LC'
CONST	ENDS
;	COMDAT __xmm@27cf676ff1953f9d27cf676ff1953f9d
CONST	SEGMENT
__xmm@27cf676ff1953f9d27cf676ff1953f9d DB 09dH, '?', 095H, 0f1H, 'og', 0cfH
	DB	'''', 09dH, '?', 095H, 0f1H, 'og', 0cfH, ''''
CONST	ENDS
;	COMDAT __xmm@23f641f88890a04725f266d29f96bc60
CONST	SEGMENT
__xmm@23f641f88890a04725f266d29f96bc60 DB '`', 0bcH, 096H, 09fH, 0d2H, 'f'
	DB	0f2H, '%G', 0a0H, 090H, 088H, 0f8H, 'A', 0f6H, '#'
CONST	ENDS
;	COMDAT __xmm@1b75bd1119a31f5d1b75bd1119a31f5d
CONST	SEGMENT
__xmm@1b75bd1119a31f5d1b75bd1119a31f5d DB ']', 01fH, 0a3H, 019H, 011H, 0bdH
	DB	'u', 01bH, ']', 01fH, 0a3H, 019H, 011H, 0bdH, 'u', 01bH
CONST	ENDS
;	COMDAT __xmm@01f3b16f0d3d333d01f3b16f0d3d333d
CONST	SEGMENT
__xmm@01f3b16f0d3d333d01f3b16f0d3d333d DB '=3=', 0dH, 'o', 0b1H, 0f3H, 01H
	DB	'=3=', 0dH, 'o', 0b1H, 0f3H, 01H
CONST	ENDS
;	COMDAT __xmm@00000000000008000000000000000800
CONST	SEGMENT
__xmm@00000000000008000000000000000800 DB 00H, 08H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 08H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@000000000000000f0000000000000000
CONST	SEGMENT
__xmm@000000000000000f0000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 0fH, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000070000000000000007
CONST	SEGMENT
__xmm@00000000000000070000000000000007 DB 07H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000070000000000000006
CONST	SEGMENT
__xmm@00000000000000070000000000000006 DB 06H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000050000000000000004
CONST	SEGMENT
__xmm@00000000000000050000000000000004 DB 04H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 05H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000030000000000000002
CONST	SEGMENT
__xmm@00000000000000030000000000000002 DB 02H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 03H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000010000000000000000
CONST	SEGMENT
__xmm@00000000000000010000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@5f000000
CONST	SEGMENT
__real@5f000000 DD 05f000000r			; 9.22337e+18
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$cipher@D@ay@@YAXPEAD_K1@Z DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+88
	DD	imagerel $unwind$??$cipher@D@ay@@YAXPEAD_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$cipher@D@ay@@YAXPEAD_K1@Z DD 041021H
	DD	07410H
	DD	023405H
	DD	imagerel $LN29
	DD	imagerel $LN29+88
	DD	imagerel $unwind$??$cipher@D@ay@@YAXPEAD_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$cipher@D@ay@@YAXPEAD_K1@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0a6H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a2H
	DB	02H
	DB	'i', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Client@@QEAA@XZ DB 04H
	DB	'y', 02H
	DB	02H
	DB	'f'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Client@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0Client@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Client@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0Client@@QEAA@XZ
	DD	imagerel $ip2state$??0Client@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Client@@QEAA@XZ DD 031b19H
	DD	03c0109H
	DD	03002H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0Client@@QEAA@XZ
	DD	01d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1Client@@QEAA@XZ DB 02H
	DB	':'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1Client@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1Client@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Client@@QEAA@XZ DD 040a19H
	DD	0b340aH
	DD	07006720aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1Client@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DB 02H
	DB	0a0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$45@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$41@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$37@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$33@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$29@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$25@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$21@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$17@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$16@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$12@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$11@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?LoadWSAFunctions@Client@@IEAAXXZ DB '@'
	DB	0f8H
	DB	02H
	DB	084H
	DB	00H
	DB	'N'
	DB	04H
	DB	'J'
	DB	00H
	DB	09cH
	DB	06H
	DB	'4'
	DB	00H
	DB	0faH
	DB	08H
	DB	'`'
	DB	00H
	DB	'V'
	DB	0aH
	DB	'\'
	DB	00H
	DB	'q', 04H
	DB	0cH
	DB	'4'
	DB	00H
	DB	0f8H
	DB	0eH
	DB	'p'
	DB	00H
	DB	'&'
	DB	0cH
	DB	'5', 02H
	DB	010H
	DB	'`'
	DB	00H
	DB	'&'
	DB	0cH
	DB	'=', 02H
	DB	012H
	DB	'n'
	DB	00H
	DB	'&'
	DB	0cH
	DB	'U', 02H
	DB	014H
	DB	080H
	DB	00H
	DB	'&'
	DB	0cH
	DB	'9', 02H
	DB	016H
	DB	'`'
	DB	00H
	DB	'&'
	DB	0cH
	DB	'Y', 02H
	DB	018H
	DB	090H
	DB	00H
	DB	'&'
	DB	0cH
	DB	'a', 02H
	DB	01aH
	DB	'!', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?LoadWSAFunctions@Client@@IEAAXXZ DB 01aH
	DB	0eH
	DD	imagerel ?dtor$11@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	036H
	DD	imagerel ?dtor$12@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	05cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	08eH
	DD	imagerel ?dtor$16@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	0b6H
	DD	imagerel ?dtor$17@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	0dcH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
	DB	01dH
	DB	02H
	DD	imagerel ?dtor$21@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	07dH
	DB	02H
	DD	imagerel ?dtor$25@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	0ddH
	DB	02H
	DD	imagerel ?dtor$29@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	03dH
	DB	03H
	DD	imagerel ?dtor$33@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	09dH
	DB	03H
	DD	imagerel ?dtor$37@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	0fdH
	DB	03H
	DD	imagerel ?dtor$41@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
	DB	05dH
	DB	04H
	DD	imagerel ?dtor$45@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?LoadWSAFunctions@Client@@IEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?LoadWSAFunctions@Client@@IEAAXXZ
	DD	imagerel $ip2state$?LoadWSAFunctions@Client@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LoadWSAFunctions@Client@@IEAAXXZ DD 0f2711H
	DD	096827H
	DD	01d7423H
	DD	01c6423H
	DD	01b3423H
	DD	0140123H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?LoadWSAFunctions@Client@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DB 02H
	DB	0a0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0a0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	090H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	0b2H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ DB 02H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ DB 02H
	DB	090H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ DB 02H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ DB 02H
	DB	09eH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ DB 02H
	DB	090H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ DB 02H
	DB	0a0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ DB 02H
	DB	0a4H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Connect@Client@@QEAAHXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DB 06H
	DB	0a0H
	DB	00H
	DB	'R'
	DB	02H
	DB	08cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
	DD	imagerel $ip2state$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DD 061e19H
	DD	0d640fH
	DD	0c340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Disconnect@Client@@QEAAHXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@$$BY0A@D$0A@@std@@YA?AV?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@0@_K@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 021H
	DD	imagerel $LN97
	DD	imagerel $LN97+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 020021H
	DD	047400H
	DD	imagerel $LN97
	DD	imagerel $LN97+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 020521H
	DD	047405H
	DD	imagerel $LN97
	DD	imagerel $LN97+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 050a01H
	DD	0e006420aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 060c01H
	DD	0b340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
CRT$XCU	SEGMENT
?ntdll$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::ntdll$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?advapi32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::advapi32$initializer$
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 183  :     return __builtin_is_constant_evaluated();

	xor	al, al

; 184  : }

	ret	0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, rdx

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 636  :         return LLONG_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 637  :     }

	ret	0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 68   :         _Data._What = _Message;
; 69   :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0
	lea	rdx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx], rcx

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	__std_exception_copy

; 75   :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	jmp	__std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rdx, QWORD PTR [rcx+8]
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	test	rdx, rdx
	cmovne	rax, rdx

; 97   :     }

	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	__std_exception_destroy
	test	bl, 1
	je	SHORT $LN8@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@

; 66   :         : _Data()

	mov	QWORD PTR [rcx+16], 0

; 133  :     {

	mov	QWORD PTR [rcx], rax

; 134  :     }

	mov	rax, rcx

; 68   :         _Data._What = _Message;

	mov	QWORD PTR [rcx+8], rdx

; 134  :     }

	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	__std_exception_destroy
	test	bl, 1
	je	SHORT $LN13@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	jmp	__std_exception_destroy
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 68   :         _Data._What = _Message;

	lea	rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rax

; 144  :     {

	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rcx], rax

; 145  :     }

	mov	rax, rcx
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	__std_exception_destroy
	test	bl, 1
	je	SHORT $LN18@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN18@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	jmp	__std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 74   : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
	sub	rsp, 72					; 00000048H

; 75   :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 73   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 72   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]

; 73   :     {

	mov	QWORD PTR [rbx], rcx

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	__std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 73   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 72   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]

; 73   :     {

	mov	QWORD PTR [rbx], rcx

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	__std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 8
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 169  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN13:
	sub	rsp, 40					; 00000028H

; 170  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 171  :     _Bytes += _Non_user_size;

	add	QWORD PTR [rdx], 39			; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rdx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN7@Adjust_man

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	QWORD PTR [rcx], rdx

; 190  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Adjust_man:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN11@Adjust_man:
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1149 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1151 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1415 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	rax, rcx
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1418 :     _CONSTEXPR20 void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2326 : [[noreturn]] inline void _Xlen_string() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2327 :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlen_strin:
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??$cipher@D@ay@@YAXPEAD_K1@Z
_TEXT	SEGMENT
data$ = 16
size$ = 24
key$ = 32
??$cipher@D@ay@@YAXPEAD_K1@Z PROC			; ay::cipher<char>, COMDAT

; 66   : 	{

$LN29:
	sub	rsp, 8

; 67   : 		// Obfuscate with a simple XOR cipher based on key
; 68   : 		for ( size_type i = 0; i < size; i++ )

	xor	eax, eax
	movq	xmm2, r8
	punpcklqdq xmm2, xmm2
	mov	r9, rdx
	mov	r10, rcx
	test	rdx, rdx
	je	$LN3@cipher
	cmp	rdx, 8
	jb	$LL22@cipher
	cmp	DWORD PTR __isa_available, 5
	jl	$LL22@cipher
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000010000000000000000

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	mov	r11, rdx
	movdqa	xmm4, XMMWORD PTR __xmm@00000000000000070000000000000007
	lea	rdx, QWORD PTR [rcx+4]
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	and	r11, -8
	mov	QWORD PTR [rsp+16], rbx
	mov	rbx, -2
	mov	QWORD PTR [rsp], rdi
	sub	rbx, rcx
	mov	edi, 2
	sub	rdi, rcx
$LL4@cipher:
	movzx	ecx, WORD PTR [rdx-4]
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	add	rax, 8
	paddq	xmm0, xmm3
	andps	xmm0, xmm4
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-4], cx
	lea	rcx, QWORD PTR [rbx+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm3
	andps	xmm0, xmm4
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-2], cx
	mov	rcx, rdx
	sub	rcx, r10
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm3
	andps	xmm0, xmm4
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx], cx
	lea	rcx, QWORD PTR [rdi+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm3
	andps	xmm0, xmm4
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx+2], cx
	add	rdx, 8
	cmp	rax, r11
	jb	$LL4@cipher

; 67   : 		// Obfuscate with a simple XOR cipher based on key
; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	rdi, QWORD PTR [rsp]
	mov	rbx, QWORD PTR [rsp+16]
	cmp	rax, r9
	jae	SHORT $LN3@cipher
	npad	10
$LL22@cipher:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r8
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r10+rax], dl
	inc	rax
	cmp	rax, r9
	jb	SHORT $LL22@cipher
$LN3@cipher:

; 71   : 		}
; 72   : 	}

	add	rsp, 8
	ret	0
??$cipher@D@ay@@YAXPEAD_K1@Z ENDP			; ay::cipher<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_1>::operator(), COMDAT

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 17789827		; 010f7383H
	mov	DWORD PTR [rbx], 1906178582		; 719dfa16H
	mov	DWORD PTR [rbx+4], -14228118		; ff26e56aH
	mov	WORD PTR [rbx+8], 64339			; 0000fb53H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'', COMDAT

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 17789827		; 010f7383H
	mov	DWORD PTR [rbx], 1906178582		; 719dfa16H
	mov	DWORD PTR [rbx+4], -14228118		; ff26e56aH
	mov	WORD PTR [rbx+8], 64339			; 0000fb53H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@cd15890f1fef9f7dcd15890f1fef9f7d
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, -3668875623370088579		; cd15890f1fef9f7dH
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_2>::operator(), COMDAT

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN21@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 345			; 00000159H
	mov	DWORD PTR [rbx], 398929249		; 17c72d61H
	mov	DWORD PTR [rbx+4], 53601273		; 0331e3f9H
	mov	BYTE PTR [rbx+8], 99			; 00000063H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'', COMDAT

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN42@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 345			; 00000159H
	mov	DWORD PTR [rbx], 398929249		; 17c72d61H
	mov	DWORD PTR [rbx+4], 53601273		; 0331e3f9H
	mov	BYTE PTR [rbx+8], 99			; 00000063H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN42@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+10], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN51@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@6f55cd957ba3590f6f55cd957ba3590f
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN51@dynamic:
	mov	r9, 8022544353138530575			; 6f55cd957ba3590fH
	npad	9
$LL50@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 10
	jb	SHORT $LL50@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+10], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_3>::operator(), COMDAT

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 33376613		; 01fd4965H
	mov	DWORD PTR [rbx], 1149181722		; 447f1f1aH
	mov	DWORD PTR [rbx+4], -777894771		; d1a2448dH
	mov	WORD PTR [rbx+8], 8021			; 00001f55H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'', COMDAT

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 33376613		; 01fd4965H
	mov	DWORD PTR [rbx], 1149181722		; 447f1f1aH
	mov	DWORD PTR [rbx+4], -777894771		; d1a2448dH
	mov	WORD PTR [rbx+8], 8021			; 00001f55H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@e3912dfd25097b7be3912dfd25097b7b
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, -2048805790205510789		; e3912dfd25097b7bH
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??0Client@@QEAA@XZ
_TEXT	SEGMENT
this$GSCopy$ = 32
data$ = 48
__$ArrayPad$ = 464
this$ = 496
??0Client@@QEAA@XZ PROC					; Client::Client, COMDAT

; 7    : Client::Client() {

$LN28:
	push	rbx
	sub	rsp, 480				; 000001e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h

; 77   :     _socket       CreateSocket    = nullptr;

	xor	ecx, ecx
	mov	QWORD PTR [rbx], rcx

; 78   :     _WSAStartup   StartWSA        = nullptr;

	mov	QWORD PTR [rbx+8], rcx

; 79   :     _WSACleanup   CleanWSA        = nullptr;

	mov	QWORD PTR [rbx+16], rcx

; 80   :     _closesocket  CloseSocket     = nullptr;

	mov	QWORD PTR [rbx+24], rcx

; 81   :     _bind         BindSocket      = nullptr;

	mov	QWORD PTR [rbx+32], rcx

; 82   :     _sendto       SendTo          = nullptr; 

	mov	QWORD PTR [rbx+40], rcx

; 83   :     _send         Send            = nullptr;

	mov	QWORD PTR [rbx+48], rcx

; 84   :     _recv         Receive         = nullptr;

	mov	QWORD PTR [rbx+56], rcx

; 85   :     _recvfrom     ReceiveFrom     = nullptr;

	mov	QWORD PTR [rbx+64], rcx

; 86   :     _connect      ConnectSocket   = nullptr; 

	mov	QWORD PTR [rbx+72], rcx

; 87   : 
; 88   :     // Further details on client
; 89   :     BOOL          WSAInitialized  = FALSE;

	mov	DWORD PTR [rbx+80], ecx

; 90   :     SOCKET        UDPSocket       = INVALID_SOCKET;

	mov	QWORD PTR [rbx+88], -1

; 91   :     SOCKET        TCPSocket       = INVALID_SOCKET;

	mov	QWORD PTR [rbx+96], -1
	xorps	xmm0, xmm0

; 92   :     Server        ConnectedServer = { 0 };          // Information on the clients connected server

	xor	eax, eax
	movups	XMMWORD PTR [rbx+104], xmm0
	movups	XMMWORD PTR [rbx+120], xmm0
	mov	DWORD PTR [rbx+136], eax

; 93   :     long          ClientUID       = -1;             // UID is assigned by the server. Used to perform commands on one client

	mov	DWORD PTR [rbx+140], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+144], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+160], rcx

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+168], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+144], al
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 8    : 	LoadWSAFunctions();

	mov	rcx, rbx
	call	?LoadWSAFunctions@Client@@IEAAXXZ	; Client::LoadWSAFunctions

; 9    : 
; 10   : 	WORD version = MAKEWORD(2, 2);
; 11   : 	WSAData data = { 0 };

	xor	edx, edx
	mov	r8d, 408				; 00000198H
	lea	rcx, QWORD PTR data$[rsp]
	call	memset

; 12   : 	int success  = StartWSA(version, &data);

	mov	r8, QWORD PTR [rbx+8]
	mov	ecx, 514				; 00000202H
	lea	rdx, QWORD PTR data$[rsp]
	call	r8

; 13   : 
; 14   : 	if ( success == 0 )

	test	eax, eax
	jne	SHORT $LN25@Client

; 15   : 		WSAInitialized = TRUE;

	mov	DWORD PTR [rbx+80], 1
$LN25@Client:

; 16   : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 480				; 000001e0H
	pop	rbx
	ret	0
??0Client@@QEAA@XZ ENDP					; Client::Client
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
data$ = 48
__$ArrayPad$ = 464
this$ = 496
?dtor$0@?0???0Client@@QEAA@XZ@4HA PROC			; `Client::Client'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 144				; 00000090H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0Client@@QEAA@XZ@4HA ENDP			; `Client::Client'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??1Client@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 80
??1Client@@QEAA@XZ PROC					; Client::~Client, COMDAT

; 18   : Client::~Client() {

$LN102:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rcx

; 84   : 		socketReady = this->TCPSocket != INVALID_SOCKET;

	mov	rcx, QWORD PTR [rcx+96]

; 85   : 		break;
; 86   : 	}
; 87   : 
; 88   : 	return socketReady == TRUE && WSAInitialized;

	cmp	rcx, -1
	je	SHORT $LN6@Client
	cmp	DWORD PTR [rdi+80], 0
	je	SHORT $LN6@Client

; 136  : 	int status = CloseSocket(this->TCPSocket);

	call	QWORD PTR [rdi+24]
$LN6@Client:

; 19   : 	this->Disconnect(); // disconnect incase the socket is still connected
; 20   : 
; 21   : 	CleanWSA();

	call	QWORD PTR [rdi+16]

; 22   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V34@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN96@Client
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 25135963		; 017f8b5bH
	mov	DWORD PTR [rbx], 1380815968		; 524d9460H
	mov	DWORD PTR [rbx+4], -214469654		; f33773eaH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 22   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
$LN96@Client:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN27@Client

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 55			; 00000037H
	xor	BYTE PTR [rbx+1], -25
	xor	BYTE PTR [rbx+2], 127			; 0000007fH
	xor	BYTE PTR [rbx+3], 13
	xor	BYTE PTR [rbx+4], -39			; ffffffffffffffd9H
	xor	BYTE PTR [rbx+5], 65			; 00000041H
	xor	BYTE PTR [rbx+6], 25
	xor	BYTE PTR [rbx+7], -105			; ffffffffffffff97H
	xor	BYTE PTR [rbx+8], 55			; 00000037H
	xor	BYTE PTR [rbx+9], -25
	xor	BYTE PTR [rbx+10], 127			; 0000007fH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN27@Client:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 22   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::FreeUsedLibrary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+168]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN51@Client

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi+144]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN65@Client

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN62@Client

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN65@Client:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN51@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+160], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+168], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi+144], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 23   : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN62@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN99@Client:
??1Client@@QEAA@XZ ENDP					; Client::~Client
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ PROC ; `Client::~Client'::`2'::<lambda_1>::operator(), COMDAT

; 22   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V34@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 25135963		; 017f8b5bH
	mov	DWORD PTR [rbx], 1380815968		; 524d9460H
	mov	DWORD PTR [rbx+4], -214469654		; f33773eaH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 22   : 	ProcessUtilities::FreeUsedLibrary(winsock32);

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ ENDP ; `Client::~Client'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA PROC ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA ENDP ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ PROC ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V34@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	mov	BYTE PTR [rax+rdx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1???1Client@@QEAA@XZ@QEBAAEAV?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ENDP ; ``Client::~Client'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?LoadWSAFunctions@Client@@IEAAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?LoadWSAFunctions@Client@@IEAAXXZ PROC			; Client::LoadWSAFunctions, COMDAT

; 26   : VOID Client::LoadWSAFunctions() {

$LN805:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 160				; 000000a0H
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	r14, rcx

; 27   : 	if ( WSAInitialized )

	cmp	DWORD PTR [rcx+80], 0
	jne	$LN1@LoadWSAFun

; 30   : 	HMODULE WINSOCK = ProcessUtilities::GetModHandle(winsock32); // load winsock

	mov	edx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdi, QWORD PTR [rax+rdx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V45@A
	add	rbx, rdi
	test	al, 1
	jne	SHORT $LN763@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 20655965		; 013b2f5dH
	mov	DWORD PTR [rbx], 1443442790		; 56093066H
	mov	DWORD PTR [rbx+4], -1522015854		; a547e192H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 30   : 	HMODULE WINSOCK = ProcessUtilities::GetModHandle(winsock32); // load winsock

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN763@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN27@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 49			; 00000031H
	xor	BYTE PTR [rbx+1], 67			; 00000043H
	xor	BYTE PTR [rbx+2], 59			; 0000003bH
	xor	BYTE PTR [rbx+3], 9
	xor	BYTE PTR [rbx+4], -95			; ffffffffffffffa1H
	xor	BYTE PTR [rbx+5], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rbx+6], 105			; 00000069H
	xor	BYTE PTR [rbx+7], -63			; ffffffffffffffc1H
	xor	BYTE PTR [rbx+8], 49			; 00000031H
	xor	BYTE PTR [rbx+9], 67			; 00000043H
	xor	BYTE PTR [rbx+10], 59			; 0000003bH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN27@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 30   : 	HMODULE WINSOCK = ProcessUtilities::GetModHandle(winsock32); // load winsock

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T27[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetModHandle
	mov	r15, rax

; 33   : 	StartWSA	  = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN765@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 27470202		; 01a3297aH
	mov	DWORD PTR [rbx], 685902424		; 28e20a58H
	mov	DWORD PTR [rbx+4], 455584993		; 1b27ace1H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 33   : 	StartWSA	  = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN35@LoadWSAFun
$LN765@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN35@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN46@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 15
	xor	BYTE PTR [rbx+1], 89			; 00000059H
	xor	BYTE PTR [rbx+2], -93			; ffffffffffffffa3H
	xor	BYTE PTR [rbx+3], 123			; 0000007bH
	xor	BYTE PTR [rbx+4], -107			; ffffffffffffff95H
	xor	BYTE PTR [rbx+5], -51			; ffffffffffffffcdH
	xor	BYTE PTR [rbx+6], 85			; 00000055H
	xor	BYTE PTR [rbx+7], 111			; 0000006fH
	xor	BYTE PTR [rbx+8], 15
	xor	BYTE PTR [rbx+9], 89			; 00000059H
	xor	BYTE PTR [rbx+10], -93			; ffffffffffffffa3H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN46@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 33   : 	StartWSA	  = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T26[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T8[rbp-105], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r12, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN74@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN88@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN85@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN88@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN74@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	xor	esi, esi
	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], sil
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 33   : 	StartWSA	  = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	mov	QWORD PTR [r14+8], r12

; 34   : 	BindSocket    = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN767@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 33374567		; 01fd4167H
	mov	WORD PTR [rbx], 4633			; 00001219H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 34   : 	BindSocket    = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN97@LoadWSAFun
$LN767@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN97@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+5], 0
	je	SHORT $LN108@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 123			; 0000007bH
	xor	BYTE PTR [rbx+1], 123			; 0000007bH
	xor	BYTE PTR [rbx+2], 9
	xor	BYTE PTR [rbx+3], 37			; 00000025H
	xor	BYTE PTR [rbx+4], -3

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+5], 0
$LN108@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 34   : 	BindSocket    = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T18[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
	mov	QWORD PTR [r14+32], rax

; 35   : 	CloseSocket   = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN769@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+11], 379			; 0000017bH
	mov	DWORD PTR [rbx], 134901194		; 080a6dcaH
	mov	DWORD PTR [rbx+4], 882135688		; 34945288H
	mov	WORD PTR [rbx+8], 25794			; 000064c2H
	mov	BYTE PTR [rbx+10], 17
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 35   : 	CloseSocket   = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN116@LoadWSAFun
$LN769@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN116@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	mov	r13d, DWORD PTR __isa_available
	movdqa	xmm6, XMMWORD PTR __xmm@00000000000008000000000000000800
	cmp	BYTE PTR [rbx+12], 0
	je	$LN127@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	rdx, rsi
	cmp	r13d, 5
	jl	$LN800@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm2, XMMWORD PTR __xmm@57fb21ed7b6501a957fb21ed7b6501a9
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	edx, 8
$LN800@LoadWSAFun:
	mov	r9, 6339698204315287977			; 57fb21ed7b6501a9H
$LL798@LoadWSAFun:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, dl
	and	cl, 7
	shl	cl, 3
	mov	r8, r9
	shr	r8, cl
	xor	BYTE PTR [rbx+rdx], r8b

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	rdx
	cmp	rdx, 12
	jb	SHORT $LL798@LoadWSAFun

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+12], 0
$LN127@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 35   : 	CloseSocket   = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T17[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T7[rbp-105], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T25[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r12, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN155@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN169@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN166@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN169@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN155@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 35   : 	CloseSocket   = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	mov	QWORD PTR [r14+24], r12

; 36   : 	CreateSocket  = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN770@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 23308224		; 0163a7c0H
	mov	DWORD PTR [rbx], -1270035922		; b44cca2eH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 36   : 	CreateSocket  = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN177@LoadWSAFun
$LN770@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN177@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+7], 0
	je	SHORT $LN188@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 93			; 0000005dH
	xor	BYTE PTR [rbx+1], -91			; ffffffffffffffa5H
	xor	BYTE PTR [rbx+2], 47			; 0000002fH
	xor	BYTE PTR [rbx+3], -33			; ffffffffffffffdfH
	xor	BYTE PTR [rbx+4], -91			; ffffffffffffffa5H
	xor	BYTE PTR [rbx+5], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rbx+6], 99			; 00000063H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+7], 0
$LN188@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 36   : 	CreateSocket  = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T16[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T6[rbp-105], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T24[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r12, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN216@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN230@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN227@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN230@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN216@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 36   : 	CreateSocket  = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	mov	QWORD PTR [r14], r12

; 37   : 	Receive       = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN772@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 26335708		; 0191d9dcH
	mov	WORD PTR [rbx], 9883			; 0000269bH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 37   : 	Receive       = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN238@LoadWSAFun
$LN772@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN238@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+5], 0
	je	SHORT $LN249@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -23
	xor	BYTE PTR [rbx+1], 67			; 00000043H
	xor	BYTE PTR [rbx+2], -65			; ffffffffffffffbfH
	xor	BYTE PTR [rbx+3], -81			; ffffffffffffffafH
	xor	BYTE PTR [rbx+4], -111			; ffffffffffffff91H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+5], 0
$LN249@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 37   : 	Receive       = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T15[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T5[rbp-105], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T23[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r12, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN277@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN291@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN288@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN291@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN277@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 37   : 	Receive       = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	mov	QWORD PTR [r14+56], r12

; 38   : 	SendTo        = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN774@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 21190297		; 01435699H
	mov	DWORD PTR [rbx], -242136388		; f1914abcH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 38   : 	SendTo        = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN299@LoadWSAFun
$LN774@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN299@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+7], 0
	je	SHORT $LN310@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -49			; ffffffffffffffcfH
	xor	BYTE PTR [rbx+1], 47			; 0000002fH
	not	BYTE PTR [rbx+2]
	xor	BYTE PTR [rbx+3], -107			; ffffffffffffff95H
	xor	BYTE PTR [rbx+4], -19
	xor	BYTE PTR [rbx+5], 57			; 00000039H
	xor	BYTE PTR [rbx+6], 67			; 00000043H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+7], 0
$LN310@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 38   : 	SendTo        = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T14[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T4[rbp-105], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T22[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r12, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN338@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN352@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN349@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN352@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN338@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 38   : 	SendTo        = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	mov	QWORD PTR [r14+40], r12

; 39   : 	ReceiveFrom   = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN776@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+6], 23950952		; 016d7668H
	mov	DWORD PTR [rbx], 66748447		; 03fa801fH
	mov	WORD PTR [rbx+4], 49129			; 0000bfe9H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 39   : 	ReceiveFrom   = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN360@LoadWSAFun
$LN776@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN360@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+9], 0
	je	SHORT $LN371@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 109			; 0000006dH
	xor	BYTE PTR [rbx+1], -27
	xor	BYTE PTR [rbx+2], -103			; ffffffffffffff99H
	xor	BYTE PTR [rbx+3], 117			; 00000075H
	xor	BYTE PTR [rbx+4], -113			; ffffffffffffff8fH
	xor	BYTE PTR [rbx+5], -51			; ffffffffffffffcdH
	xor	BYTE PTR [rbx+6], 7
	xor	BYTE PTR [rbx+7], 27
	xor	BYTE PTR [rbx+8], 109			; 0000006dH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+9], 0
$LN371@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 39   : 	ReceiveFrom   = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T13[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T3[rbp-105], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T21[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r12, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN399@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN413@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN410@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN413@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN399@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 39   : 	ReceiveFrom   = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	mov	QWORD PTR [r14+64], r12

; 40   : 	Send          = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN778@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 20407217		; 013763b1H
	mov	WORD PTR [rbx], 64650			; 0000fc8aH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 40   : 	Send          = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN421@LoadWSAFun
$LN778@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN421@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+5], 0
	je	SHORT $LN432@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -7
	xor	BYTE PTR [rbx+1], -103			; ffffffffffffff99H
	xor	BYTE PTR [rbx+2], -33			; ffffffffffffffdfH
	xor	BYTE PTR [rbx+3], 7
	xor	BYTE PTR [rbx+4], 55			; 00000037H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+5], 0
$LN432@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 40   : 	Send          = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T12[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T2[rbp-105], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T20[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r12, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN460@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN474@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN471@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN474@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN460@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 40   : 	Send          = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	mov	QWORD PTR [r14+48], r12

; 41   : 	CleanWSA      = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN780@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 24997798		; 017d6fa6H
	mov	DWORD PTR [rbx], -532919164		; e03c4c84H
	mov	DWORD PTR [rbx+4], -1825663791		; 932e94d1H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 41   : 	CleanWSA      = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN482@LoadWSAFun
$LN780@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN482@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN493@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rbx+1], 31
	xor	BYTE PTR [rbx+2], 125			; 0000007dH
	xor	BYTE PTR [rbx+3], -93			; ffffffffffffffa3H
	xor	BYTE PTR [rbx+4], -67			; ffffffffffffffbdH
	xor	BYTE PTR [rbx+5], -15
	xor	BYTE PTR [rbx+6], 79			; 0000004fH
	xor	BYTE PTR [rbx+7], -3
	xor	BYTE PTR [rbx+8], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rbx+9], 31
	xor	BYTE PTR [rbx+10], 125			; 0000007dH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN493@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 41   : 	CleanWSA      = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T11[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T1[rbp-105], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T19[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r12, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN521@LoadWSAFun

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN535@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN532@LoadWSAFun

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN535@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN521@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 41   : 	CleanWSA      = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	mov	QWORD PTR [r14+16], r12

; 42   : 	ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN782@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+7], 385			; 00000181H
	mov	DWORD PTR [rbx], -517130578		; e12d36aeH
	mov	WORD PTR [rbx+4], 6660			; 00001a04H
	mov	BYTE PTR [rbx+6], 125			; 0000007dH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 42   : 	ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN543@LoadWSAFun
$LN782@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN543@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+8], 0
	je	$LN554@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	cmp	r13d, 5
	jl	$LN801@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm2, XMMWORD PTR __xmm@810979618f4359cd810979618f4359cd
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax
	jmp	SHORT $LN558@LoadWSAFun
$LN801@LoadWSAFun:
	mov	rdx, -9148647708104107571		; 810979618f4359cdH
	npad	6
$LL799@LoadWSAFun:
	movzx	ecx, sil
	and	cl, 7
	shl	cl, 3
	mov	r8, rdx
	shr	r8, cl
	xor	BYTE PTR [rbx+rsi], r8b

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	rsi
	cmp	rsi, 8
	jb	SHORT $LL799@LoadWSAFun
$LN558@LoadWSAFun:

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+8], 0
$LN554@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 42   : 	ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T10[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
	mov	QWORD PTR [r14+72], rax
$LN1@LoadWSAFun:

; 43   : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN532@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN85@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN166@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN227@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN288@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN349@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN410@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN471@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN802@LoadWSAFun:
?LoadWSAFunctions@Client@@IEAAXXZ ENDP			; Client::LoadWSAFunctions
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$11@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$11
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$11@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$12@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$12
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$12@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$13@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$13
	mov	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$13@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$16@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$16
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$16@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$17@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$17
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$17@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$18@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$18
	mov	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$18@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$21@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$21
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$21@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$22@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$22
	mov	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$22@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$25@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$25
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$25@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$26@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$26
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$26@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$29@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$29
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$29@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$29
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$30@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$30
	mov	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$30@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$33@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$33
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$33@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$33
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$34@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$34
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$34@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$34
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$37@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$37
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$37@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$37
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$38@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$38
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$38@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$38
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$41@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$41
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$41@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$41
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$42@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$42
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$42@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$42
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 112
this$ = 208
?dtor$45@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA PROC	; `Client::LoadWSAFunctions'::`1'::dtor$45
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$45@?0??LoadWSAFunctions@Client@@IEAAXXZ@4HA ENDP	; `Client::LoadWSAFunctions'::`1'::dtor$45
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_1>::operator(), COMDAT

; 30   : 	HMODULE WINSOCK = ProcessUtilities::GetModHandle(winsock32); // load winsock

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 20655965		; 013b2f5dH
	mov	DWORD PTR [rbx], 1443442790		; 56093066H
	mov	DWORD PTR [rbx+4], -1522015854		; a547e192H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 30   : 	HMODULE WINSOCK = ProcessUtilities::GetModHandle(winsock32); // load winsock

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_2>::operator(), COMDAT

; 33   : 	StartWSA	  = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 27470202		; 01a3297aH
	mov	DWORD PTR [rbx], 685902424		; 28e20a58H
	mov	DWORD PTR [rbx+4], 455584993		; 1b27ace1H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 33   : 	StartWSA	  = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_3>::operator(), COMDAT

; 34   : 	BindSocket    = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN16@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 33374567		; 01fd4167H
	mov	WORD PTR [rbx], 4633			; 00001219H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 34   : 	BindSocket    = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_4>::operator(), COMDAT

; 35   : 	CloseSocket   = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN25@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+11], 379			; 0000017bH
	mov	DWORD PTR [rbx], 134901194		; 080a6dcaH
	mov	DWORD PTR [rbx+4], 882135688		; 34945288H
	mov	WORD PTR [rbx+8], 25794			; 000064c2H
	mov	BYTE PTR [rbx+10], 17
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 35   : 	CloseSocket   = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN25@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_5>::operator(), COMDAT

; 36   : 	CreateSocket  = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN18@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 23308224		; 0163a7c0H
	mov	DWORD PTR [rbx], -1270035922		; b44cca2eH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 36   : 	CreateSocket  = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_6>::operator(), COMDAT

; 37   : 	Receive       = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN16@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 26335708		; 0191d9dcH
	mov	WORD PTR [rbx], 9883			; 0000269bH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 37   : 	Receive       = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_7>::operator(), COMDAT

; 38   : 	SendTo        = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN18@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 21190297		; 01435699H
	mov	DWORD PTR [rbx], -242136388		; f1914abcH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 38   : 	SendTo        = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_8>::operator(), COMDAT

; 39   : 	ReceiveFrom   = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN20@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+6], 23950952		; 016d7668H
	mov	DWORD PTR [rbx], 66748447		; 03fa801fH
	mov	WORD PTR [rbx+4], 49129			; 0000bfe9H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 39   : 	ReceiveFrom   = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN20@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_9>::operator(), COMDAT

; 40   : 	Send          = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN16@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 20407217		; 013763b1H
	mov	WORD PTR [rbx], 64650			; 0000fc8aH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 40   : 	Send          = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_10>::operator(), COMDAT

; 41   : 	CleanWSA      = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 24997798		; 017d6fa6H
	mov	DWORD PTR [rbx], -532919164		; e03c4c84H
	mov	DWORD PTR [rbx+4], -1825663791		; 932e94d1H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 41   : 	CleanWSA      = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ PROC ; `Client::LoadWSAFunctions'::`2'::<lambda_11>::operator(), COMDAT

; 42   : 	ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN19@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+7], 385			; 00000181H
	mov	DWORD PTR [rbx], -517130578		; e12d36aeH
	mov	WORD PTR [rbx+4], 6660			; 00001a04H
	mov	BYTE PTR [rbx+6], 125			; 0000007dH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 42   : 	ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@YAXXZ ; ``Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ ENDP ; `Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4HA PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4HA ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	mov	BYTE PTR [rax+rdx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	BYTE PTR [rax+rdx+4], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	BYTE PTR [rax+rdx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+4], 0
	mov	BYTE PTR [rax+rdx+6], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	BYTE PTR [rax+rdx+4], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+4], 0
	mov	BYTE PTR [rax+rdx+6], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	ret	0
??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rax+rdx], 0
	mov	BYTE PTR [rax+rdx+4], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	mov	BYTE PTR [rax+rdx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ PROC ; ``Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	mov	BYTE PTR [rax+rdx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@Client@@IEAAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@XZ@YAXXZ ENDP ; ``Client::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?Connect@Client@@QEAAHXZ
_TEXT	SEGMENT
$T1 = 32
request$ = 32
this$ = 64
?Connect@Client@@QEAAHXZ PROC				; Client::Connect, COMDAT

; 45   : BOOL Client::Connect() {

$LN16:
	push	rbx
	sub	rsp, 48					; 00000030H

; 46   : 
; 47   : 	// make request to udp server
; 48   : 	this->UDPSocket = CreateSocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	mov	rax, QWORD PTR [rcx]
	mov	edx, 2
	mov	rbx, rcx
	mov	r8d, 17
	mov	ecx, edx
	call	rax
	mov	QWORD PTR [rbx+88], rax

; 49   : 	if ( this->UDPSocket == INVALID_SOCKET )

	cmp	rax, -1
	je	$LN7@Connect

; 50   : 		return FALSE;
; 51   : 
; 52   : 	ClientRequest request = {};

	mov	DWORD PTR request$[rsp], 0

; 53   : 	request.action = ClientRequest::Action::CONNECT_CLIENT;
; 54   : 	request.client = reinterpret_cast< void* >( this );
; 55   : 
; 56   : 	BOOL validServerResponse = UDPSendMessageToServer(request);

	lea	rdx, QWORD PTR $T1[rsp]
	mov	DWORD PTR request$[rsp+4], 1048576	; 00100000H
	mov	rcx, rbx
	mov	QWORD PTR request$[rsp+8], rbx
	movaps	xmm0, XMMWORD PTR request$[rsp]
	movdqa	XMMWORD PTR $T1[rsp], xmm0
	call	?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ; Client::UDPSendMessageToServer

; 57   : 	if ( !validServerResponse )

	test	eax, eax
	je	SHORT $LN7@Connect

; 58   : 		return FALSE;  
; 59   : 
; 60   : 	// connect to tcp server
; 61   : 	this->TCPSocket = CreateSocket(AF_INET, SOCK_STREAM, 0);

	mov	rax, QWORD PTR [rbx]
	xor	r8d, r8d
	mov	edx, 1
	mov	ecx, 2
	call	rax
	mov	QWORD PTR [rbx+96], rax

; 62   : 	if ( this->TCPSocket == INVALID_SOCKET )

	cmp	rax, -1
	je	SHORT $LN7@Connect

; 63   : 		return FALSE;
; 64   : 
; 65   : 	int connect = ConnectSocket(this->TCPSocket, ( sockaddr* ) &this->ConnectedServer.addr, sizeof(this->ConnectedServer.addr));

	mov	r9, QWORD PTR [rbx+72]
	lea	rdx, QWORD PTR [rbx+124]
	mov	r8d, 16
	mov	rcx, rax
	call	r9

; 66   : 	if ( connect == SOCKET_ERROR )

	cmp	eax, -1
	je	SHORT $LN7@Connect

; 68   : 
; 69   : 	// set everything now that we are connected to tcp server
; 70   : 	CloseSocket(this->UDPSocket); // no longer needed

	mov	rcx, QWORD PTR [rbx+88]
	call	QWORD PTR [rbx+24]

; 71   : 	this->UDPSocket = INVALID_SOCKET;
; 72   : 
; 73   : 	return TRUE;

	mov	eax, 1
	mov	QWORD PTR [rbx+88], -1

; 74   : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN7@Connect:

; 67   : 		return FALSE;

	xor	eax, eax

; 74   : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?Connect@Client@@QEAAHXZ ENDP				; Client::Connect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?SocketReady@Client@@IEBAHW4SocketTypes@@@Z
_TEXT	SEGMENT
this$ = 8
type$ = 16
?SocketReady@Client@@IEBAHW4SocketTypes@@@Z PROC	; Client::SocketReady, COMDAT

; 77   : 	BOOL socketReady = FALSE;
; 78   : 
; 79   : 	switch ( type ) {

	sub	edx, 1
	je	SHORT $LN4@SocketRead
	cmp	edx, 1
	jne	SHORT $LN7@SocketRead

; 82   : 		break;
; 83   : 	case TCP:
; 84   : 		socketReady = this->TCPSocket != INVALID_SOCKET;

	xor	eax, eax
	cmp	QWORD PTR [rcx+96], -1
	jmp	SHORT $LN9@SocketRead
$LN4@SocketRead:

; 80   : 	case UDP:
; 81   : 		socketReady = this->UDPSocket != INVALID_SOCKET;

	xor	eax, eax
	cmp	QWORD PTR [rcx+88], -1
$LN9@SocketRead:

; 85   : 		break;
; 86   : 	}
; 87   : 
; 88   : 	return socketReady == TRUE && WSAInitialized;

	setne	al
	cmp	eax, 1
	jne	SHORT $LN7@SocketRead
	cmp	DWORD PTR [rcx+80], 0
	je	SHORT $LN7@SocketRead

; 89   : }

	ret	0
$LN7@SocketRead:

; 85   : 		break;
; 86   : 	}
; 87   : 
; 88   : 	return socketReady == TRUE && WSAInitialized;

	xor	eax, eax

; 89   : }

	ret	0
?SocketReady@Client@@IEBAHW4SocketTypes@@@Z ENDP	; Client::SocketReady
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
_TEXT	SEGMENT
udpResponseBuffer$ = 48
__$ArrayPad$ = 56
this$ = 80
message$ = 88
?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z PROC ; Client::UDPSendMessageToServer, COMDAT

; 91   : BOOL Client::UDPSendMessageToServer(ClientMessage message) {

$LN54:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rcx
	xor	esi, esi

; 81   : 		socketReady = this->UDPSocket != INVALID_SOCKET;

	mov	rcx, QWORD PTR [rcx+88]

; 82   : 		break;
; 83   : 	case TCP:
; 84   : 		socketReady = this->TCPSocket != INVALID_SOCKET;
; 85   : 		break;
; 86   : 	}
; 87   : 
; 88   : 	return socketReady == TRUE && WSAInitialized;

	cmp	rcx, -1
	je	$LN51@UDPSendMes
	cmp	DWORD PTR [rdi+80], esi
	je	$LN51@UDPSendMes

; 92   : 	if ( !SocketReady(UDP) )
; 93   : 		return FALSE;
; 94   : 
; 95   : 	int sent = SendTo(this->UDPSocket, ( char* ) &message, sizeof(message), 0, NULL, NULL);

	mov	rax, QWORD PTR [rdi+40]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rsi
	xor	r9d, r9d
	mov	r8d, 16
	call	rax

; 96   : 	if ( sent == SOCKET_ERROR )

	cmp	eax, -1
	je	SHORT $LN51@UDPSendMes
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory

; 3601 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	ecx, 40					; 00000028H
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rbx, rax
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm0
	mov	QWORD PTR [rbx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR udpResponseBuffer$[rsp], rbx
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 105  : 	int received = ReceiveFrom(this->UDPSocket, udpResponseBuffer.get(), sizeof(udpResponseBuffer), 0, NULL, NULL);

	mov	r10, QWORD PTR [rdi+64]
	mov	QWORD PTR [rsp+40], rsi
	mov	QWORD PTR [rsp+32], rsi
	xor	r9d, r9d
	mov	r8d, 8
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rdi+88]
	call	r10

; 106  : 	if ( received == SOCKET_ERROR )

	cmp	eax, -1
	je	SHORT $LN8@UDPSendMes

; 107  : 		return FALSE;
; 108  : 
; 109  : 	UDPResponse* response = reinterpret_cast< UDPResponse* >( udpResponseBuffer.get() );
; 110  : 
; 111  : 	// update connected server after receiving a udp response from the server
; 112  : 	if (response->isValid) this->ConnectedServer = response->TCPServer;

	cmp	DWORD PTR [rbx+36], esi
	je	SHORT $LN5@UDPSendMes
	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR [rdi+104], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR [rdi+120], xmm1
	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR [rdi+136], eax
$LN5@UDPSendMes:

; 114  : 	return response->isValid;

	mov	esi, DWORD PTR [rbx+36]
$LN8@UDPSendMes:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory

; 3314 :         delete[] _Ptr;

	mov	rcx, rbx
	call	??_V@YAXPEAX@Z				; operator delete[]
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 114  : 	return response->isValid;

	mov	eax, esi
	jmp	SHORT $LN1@UDPSendMes
$LN51@UDPSendMes:

; 97   : 		return FALSE;

	xor	eax, eax
$LN1@UDPSendMes:

; 115  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ENDP ; Client::UDPSendMessageToServer
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
udpResponseBuffer$ = 48
__$ArrayPad$ = 56
this$ = 80
message$ = 88
?dtor$0@?0??UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA PROC ; `Client::UDPSendMessageToServer'::`1'::dtor$0
	lea	rcx, QWORD PTR udpResponseBuffer$[rdx]
	jmp	??1?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@XZ ; std::unique_ptr<char [0],std::default_delete<char [0]> >::~unique_ptr<char [0],std::default_delete<char [0]> >
?dtor$0@?0??UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z@4HA ENDP ; `Client::UDPSendMessageToServer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAAX_K@Z PROC ; std::unique_ptr<char [0],std::default_delete<char [0]> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<char [0],std::default_delete<char [0]> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z
_TEXT	SEGMENT
this$ = 48
message$ = 56
?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z PROC ; Client::TCPSendMessageToServer, COMDAT

; 117  : BOOL Client::TCPSendMessageToServer(ClientMessage message) {

$LN16:
	sub	rsp, 40					; 00000028H

; 84   : 		socketReady = this->TCPSocket != INVALID_SOCKET;

	mov	r10, QWORD PTR [rcx+96]

; 85   : 		break;
; 86   : 	}
; 87   : 
; 88   : 	return socketReady == TRUE && WSAInitialized;

	cmp	r10, -1
	je	SHORT $LN14@TCPSendMes
	cmp	DWORD PTR [rcx+80], 0
	je	SHORT $LN14@TCPSendMes

; 118  : 	if ( !SocketReady(TCP) )
; 119  : 		return FALSE;
; 120  : 
; 121  : 	int sent = Send(this->TCPSocket, reinterpret_cast< char* >( &message ), sizeof(ClientMessage), 0);

	mov	rax, QWORD PTR [rcx+48]
	xor	r9d, r9d
	mov	rcx, r10
	mov	r8d, 16
	call	rax

; 122  : 	if ( sent == SOCKET_ERROR )

	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	eax, ecx

; 124  : 
; 125  : 	return TRUE;
; 126  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN14@TCPSendMes:

; 123  : 		return FALSE;

	xor	eax, eax

; 124  : 
; 125  : 	return TRUE;
; 126  : }

	add	rsp, 40					; 00000028H
	ret	0
?TCPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ENDP ; Client::TCPSendMessageToServer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
this$ = 80
request$ = 88
udp$ = 96
?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z PROC ; Client::MakeServerRequest, COMDAT

; 128  : BOOL Client::MakeServerRequest(ClientRequest request, BOOL udp) {

$LN19:
	sub	rsp, 72					; 00000048H

; 129  : 	return udp ? UDPSendMessageToServer(request) : TCPSendMessageToServer(request);

	movups	xmm0, XMMWORD PTR [rdx]
	test	r8d, r8d
	je	SHORT $LN3@MakeServer
	lea	rdx, QWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	call	?UDPSendMessageToServer@Client@@IEAAHUClientRequest@@@Z ; Client::UDPSendMessageToServer

; 130  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN3@MakeServer:

; 84   : 		socketReady = this->TCPSocket != INVALID_SOCKET;

	mov	r10, QWORD PTR [rcx+96]

; 129  : 	return udp ? UDPSendMessageToServer(request) : TCPSendMessageToServer(request);

	movaps	XMMWORD PTR $T2[rsp], xmm0

; 88   : 	return socketReady == TRUE && WSAInitialized;

	cmp	r10, -1
	je	SHORT $LN17@MakeServer
	cmp	DWORD PTR [rcx+80], 0
	je	SHORT $LN17@MakeServer

; 121  : 	int sent = Send(this->TCPSocket, reinterpret_cast< char* >( &message ), sizeof(ClientMessage), 0);

	mov	rax, QWORD PTR [rcx+48]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, r10
	xor	r9d, r9d
	mov	r8d, 16
	call	rax

; 122  : 	if ( sent == SOCKET_ERROR )

	xor	ecx, ecx
	cmp	eax, -1
	setne	cl

; 129  : 	return udp ? UDPSendMessageToServer(request) : TCPSendMessageToServer(request);

	mov	eax, ecx

; 130  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN17@MakeServer:

; 119  : 		return FALSE;

	xor	ecx, ecx

; 129  : 	return udp ? UDPSendMessageToServer(request) : TCPSendMessageToServer(request);

	mov	eax, ecx

; 130  : }

	add	rsp, 72					; 00000048H
	ret	0
?MakeServerRequest@Client@@QEAAHUClientRequest@@H@Z ENDP ; Client::MakeServerRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
;	COMDAT ?Disconnect@Client@@QEAAHXZ
_TEXT	SEGMENT
this$ = 48
?Disconnect@Client@@QEAAHXZ PROC			; Client::Disconnect, COMDAT

; 132  : BOOL Client::Disconnect() {

$LN16:
	sub	rsp, 40					; 00000028H

; 84   : 		socketReady = this->TCPSocket != INVALID_SOCKET;

	mov	rdx, QWORD PTR [rcx+96]

; 85   : 		break;
; 86   : 	}
; 87   : 
; 88   : 	return socketReady == TRUE && WSAInitialized;

	cmp	rdx, -1
	je	SHORT $LN14@Disconnect
	cmp	DWORD PTR [rcx+80], 0
	je	SHORT $LN14@Disconnect

; 133  : 	if ( !SocketReady(TCP) )
; 134  : 		return FALSE;
; 135  : 
; 136  : 	int status = CloseSocket(this->TCPSocket);

	mov	rax, QWORD PTR [rcx+24]
	mov	rcx, rdx
	call	rax

; 137  : 	if ( status == SOCKET_ERROR ) {

	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	eax, ecx

; 139  : 	}
; 140  : 
; 141  : 	return TRUE;
; 142  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN14@Disconnect:

; 138  : 		return FALSE;

	xor	eax, eax

; 139  : 	}
; 140  : 
; 141  : 	return TRUE;
; 142  : }

	add	rsp, 40					; 00000028H
	ret	0
?Disconnect@Client@@QEAAHXZ ENDP			; Client::Disconnect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory
;	COMDAT ?get@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEBAPEADXZ
_TEXT	SEGMENT
this$ = 8
?get@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEBAPEADXZ PROC ; std::unique_ptr<char [0],std::default_delete<char [0]> >::get, COMDAT

; 3564 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3565 :     }

	ret	0
?get@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEBAPEADXZ ENDP ; std::unique_ptr<char [0],std::default_delete<char [0]> >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory
;	COMDAT ??1?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<char [0],std::default_delete<char [0]> >::~unique_ptr<char [0],std::default_delete<char [0]> >, COMDAT

; 3546 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]

; 3547 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3548 :         }
; 3549 :     }

	ret	0
??1?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<char [0],std::default_delete<char [0]> >::~unique_ptr<char [0],std::default_delete<char [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<8,-9148647708104107571,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+8], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@810979618f4359cd810979618f4359cd
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, rcx

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+8], 0

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
$LN28@operator:
	mov	r9, -9148647708104107571		; 810979618f4359cdH
	npad	12
$LL27@operator:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 8
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+8], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<8,-9148647708104107571,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<8,-9148647708104107571,char>::~obfuscated_data<8,-9148647708104107571,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<8,-9148647708104107571,char>::~obfuscated_data<8,-9148647708104107571,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HOPGIGJOHALMKGDD@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HOPGIGJOHALMKGDD@D@1@@Z PROC ; ay::obfuscated_data<8,-9148647708104107571,char>::obfuscated_data<8,-9148647708104107571,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+8], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HOPGIGJOHALMKGDD@D@1@@Z ENDP ; ay::obfuscated_data<8,-9148647708104107571,char>::obfuscated_data<8,-9148647708104107571,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,-193670462159642669,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+1], 31
	xor	BYTE PTR [rcx+2], 125			; 0000007dH
	xor	BYTE PTR [rcx+3], -93			; ffffffffffffffa3H
	xor	BYTE PTR [rcx+4], -67			; ffffffffffffffbdH
	xor	BYTE PTR [rcx+5], -15
	xor	BYTE PTR [rcx+6], 79			; 0000004fH
	xor	BYTE PTR [rcx+7], -3
	xor	BYTE PTR [rcx+8], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+9], 31
	xor	BYTE PTR [rcx+10], 125			; 0000007dH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,-193670462159642669,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,-193670462159642669,char>::~obfuscated_data<11,-193670462159642669,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,-193670462159642669,char>::~obfuscated_data<11,-193670462159642669,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?CLAAOECFMICOACN@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?CLAAOECFMICOACN@D@1@@Z PROC ; ay::obfuscated_data<11,-193670462159642669,char>::obfuscated_data<11,-193670462159642669,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?CLAAOECFMICOACN@D@1@@Z ENDP ; ay::obfuscated_data<11,-193670462159642669,char>::obfuscated_data<11,-193670462159642669,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<5,2983409589604555257,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -7
	xor	BYTE PTR [rcx+1], -103			; ffffffffffffff99H
	xor	BYTE PTR [rcx+2], -33			; ffffffffffffffdfH
	xor	BYTE PTR [rcx+3], 7
	xor	BYTE PTR [rcx+4], 55			; 00000037H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<5,2983409589604555257,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<5,2983409589604555257,char>::~obfuscated_data<5,2983409589604555257,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<5,2983409589604555257,char>::~obfuscated_data<5,2983409589604555257,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0CJGHDDDHAHNPJJPJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0CJGHDDDHAHNPJJPJ@D@1@@Z PROC ; ay::obfuscated_data<5,2983409589604555257,char>::obfuscated_data<5,2983409589604555257,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+5], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0CJGHDDDHAHNPJJPJ@D@1@@Z ENDP ; ay::obfuscated_data<5,2983409589604555257,char>::obfuscated_data<5,2983409589604555257,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<9,1947751379898066285,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+9], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 109			; 0000006dH
	xor	BYTE PTR [rcx+1], -27
	xor	BYTE PTR [rcx+2], -103			; ffffffffffffff99H
	xor	BYTE PTR [rcx+3], 117			; 00000075H
	xor	BYTE PTR [rcx+4], -113			; ffffffffffffff8fH
	xor	BYTE PTR [rcx+5], -51			; ffffffffffffffcdH
	xor	BYTE PTR [rcx+6], 7
	xor	BYTE PTR [rcx+7], 27
	xor	BYTE PTR [rcx+8], 109			; 0000006dH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+9], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<9,1947751379898066285,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<9,1947751379898066285,char>::~obfuscated_data<9,1947751379898066285,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+8], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<9,1947751379898066285,char>::~obfuscated_data<9,1947751379898066285,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAA@AEBV?$obfuscator@$08$0BLAHMNIPHFJJOFGN@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAA@AEBV?$obfuscator@$08$0BLAHMNIPHFJJOFGN@D@1@@Z PROC ; ay::obfuscated_data<9,1947751379898066285,char>::obfuscated_data<9,1947751379898066285,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+9], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAA@AEBV?$obfuscator@$08$0BLAHMNIPHFJJOFGN@D@1@@Z ENDP ; ay::obfuscated_data<9,1947751379898066285,char>::obfuscated_data<9,1947751379898066285,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<7,-1061941394542743601,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -49			; ffffffffffffffcfH
	xor	BYTE PTR [rcx+1], 47			; 0000002fH
	xor	BYTE PTR [rcx+3], -107			; ffffffffffffff95H
	xor	BYTE PTR [rcx+4], -19
	xor	BYTE PTR [rcx+5], 57			; 00000039H
	xor	BYTE PTR [rcx+6], 67			; 00000043H
	not	BYTE PTR [rcx+2]

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<7,-1061941394542743601,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<7,-1061941394542743601,char>::~obfuscated_data<7,-1061941394542743601,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	WORD PTR [rcx+4], 0
	mov	BYTE PTR [rcx+6], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<7,-1061941394542743601,char>::~obfuscated_data<7,-1061941394542743601,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAA@AEBV?$obfuscator@$06$0?OLMMGBCGKAANADB@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAA@AEBV?$obfuscator@$06$0?OLMMGBCGKAANADB@D@1@@Z PROC ; ay::obfuscated_data<7,-1061941394542743601,char>::obfuscated_data<7,-1061941394542743601,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+7], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAA@AEBV?$obfuscator@$06$0?OLMMGBCGKAANADB@D@1@@Z ENDP ; ay::obfuscated_data<7,-1061941394542743601,char>::obfuscated_data<7,-1061941394542743601,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<5,6185075688865743849,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -23
	xor	BYTE PTR [rcx+1], 67			; 00000043H
	xor	BYTE PTR [rcx+2], -65			; ffffffffffffffbfH
	xor	BYTE PTR [rcx+3], -81			; ffffffffffffffafH
	xor	BYTE PTR [rcx+4], -111			; ffffffffffffff91H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<5,6185075688865743849,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<5,6185075688865743849,char>::~obfuscated_data<5,6185075688865743849,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<5,6185075688865743849,char>::~obfuscated_data<5,6185075688865743849,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0FFNFMNJBKPLPEDOJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0FFNFMNJBKPLPEDOJ@D@1@@Z PROC ; ay::obfuscated_data<5,6185075688865743849,char>::obfuscated_data<5,6185075688865743849,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+5], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0FFNFMNJBKPLPEDOJ@D@1@@Z ENDP ; ay::obfuscated_data<5,6185075688865743849,char>::obfuscated_data<5,6185075688865743849,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<7,-2638032247341472419,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 93			; 0000005dH
	xor	BYTE PTR [rcx+1], -91			; ffffffffffffffa5H
	xor	BYTE PTR [rcx+2], 47			; 0000002fH
	xor	BYTE PTR [rcx+3], -33			; ffffffffffffffdfH
	xor	BYTE PTR [rcx+4], -91			; ffffffffffffffa5H
	xor	BYTE PTR [rcx+5], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+6], 99			; 00000063H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<7,-2638032247341472419,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<7,-2638032247341472419,char>::~obfuscated_data<7,-2638032247341472419,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	WORD PTR [rcx+4], 0
	mov	BYTE PTR [rcx+6], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<7,-2638032247341472419,char>::~obfuscated_data<7,-2638032247341472419,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAA@AEBV?$obfuscator@$06$0?CEJMCMFKCANAFKKD@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAA@AEBV?$obfuscator@$06$0?CEJMCMFKCANAFKKD@D@1@@Z PROC ; ay::obfuscated_data<7,-2638032247341472419,char>::obfuscated_data<7,-2638032247341472419,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+7], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAA@AEBV?$obfuscator@$06$0?CEJMCMFKCANAFKKD@D@1@@Z ENDP ; ay::obfuscated_data<7,-2638032247341472419,char>::obfuscated_data<7,-2638032247341472419,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<12,6339698204315287977,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+12], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@57fb21ed7b6501a957fb21ed7b6501a9
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, 6339698204315287977			; 57fb21ed7b6501a9H
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 12
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+12], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<12,6339698204315287977,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<12,6339698204315287977,char>::~obfuscated_data<12,6339698204315287977,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<12,6339698204315287977,char>::~obfuscated_data<12,6339698204315287977,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0FHPLCBONHLGFABKJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0FHPLCBONHLGFABKJ@D@1@@Z PROC ; ay::obfuscated_data<12,6339698204315287977,char>::obfuscated_data<12,6339698204315287977,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+12], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0FHPLCBONHLGFABKJ@D@1@@Z ENDP ; ay::obfuscated_data<12,6339698204315287977,char>::obfuscated_data<12,6339698204315287977,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<5,-2048805790205510789,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 123			; 0000007bH
	xor	BYTE PTR [rcx+1], 123			; 0000007bH
	xor	BYTE PTR [rcx+2], 9
	xor	BYTE PTR [rcx+3], 37			; 00000025H
	xor	BYTE PTR [rcx+4], -3

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<5,-2048805790205510789,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<5,-2048805790205510789,char>::~obfuscated_data<5,-2048805790205510789,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<5,-2048805790205510789,char>::~obfuscated_data<5,-2048805790205510789,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$04$0?BMGONCACNKPGIEIF@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$04$0?BMGONCACNKPGIEIF@D@1@@Z PROC ; ay::obfuscated_data<5,-2048805790205510789,char>::obfuscated_data<5,-2048805790205510789,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+5], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$04$0?BMGONCACNKPGIEIF@D@1@@Z ENDP ; ay::obfuscated_data<5,-2048805790205510789,char>::obfuscated_data<5,-2048805790205510789,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,8022544353138530575,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 15
	xor	BYTE PTR [rcx+1], 89			; 00000059H
	xor	BYTE PTR [rcx+2], -93			; ffffffffffffffa3H
	xor	BYTE PTR [rcx+3], 123			; 0000007bH
	xor	BYTE PTR [rcx+4], -107			; ffffffffffffff95H
	xor	BYTE PTR [rcx+5], -51			; ffffffffffffffcdH
	xor	BYTE PTR [rcx+6], 85			; 00000055H
	xor	BYTE PTR [rcx+7], 111			; 0000006fH
	xor	BYTE PTR [rcx+8], 15
	xor	BYTE PTR [rcx+9], 89			; 00000059H
	xor	BYTE PTR [rcx+10], -93			; ffffffffffffffa3H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,8022544353138530575,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,8022544353138530575,char>::~obfuscated_data<11,8022544353138530575,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,8022544353138530575,char>::~obfuscated_data<11,8022544353138530575,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0GPFFMNJFHLKDFJAP@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0GPFFMNJFHLKDFJAP@D@1@@Z PROC ; ay::obfuscated_data<11,8022544353138530575,char>::obfuscated_data<11,8022544353138530575,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0GPFFMNJFHLKDFJAP@D@1@@Z ENDP ; ay::obfuscated_data<11,8022544353138530575,char>::obfuscated_data<11,8022544353138530575,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,-4509840863236766927,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 49			; 00000031H
	xor	BYTE PTR [rcx+1], 67			; 00000043H
	xor	BYTE PTR [rcx+2], 59			; 0000003bH
	xor	BYTE PTR [rcx+3], 9
	xor	BYTE PTR [rcx+4], -95			; ffffffffffffffa1H
	xor	BYTE PTR [rcx+5], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+6], 105			; 00000069H
	xor	BYTE PTR [rcx+7], -63			; ffffffffffffffc1H
	xor	BYTE PTR [rcx+8], 49			; 00000031H
	xor	BYTE PTR [rcx+9], 67			; 00000043H
	xor	BYTE PTR [rcx+10], 59			; 0000003bH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,-4509840863236766927,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,-4509840863236766927,char>::~obfuscated_data<11,-4509840863236766927,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,-4509840863236766927,char>::~obfuscated_data<11,-4509840863236766927,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@1@@Z PROC ; ay::obfuscated_data<11,-4509840863236766927,char>::obfuscated_data<11,-4509840863236766927,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@1@@Z ENDP ; ay::obfuscated_data<11,-4509840863236766927,char>::obfuscated_data<11,-4509840863236766927,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,-7558938099074472137,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 55			; 00000037H
	xor	BYTE PTR [rcx+1], -25
	xor	BYTE PTR [rcx+2], 127			; 0000007fH
	xor	BYTE PTR [rcx+3], 13
	xor	BYTE PTR [rcx+4], -39			; ffffffffffffffd9H
	xor	BYTE PTR [rcx+5], 65			; 00000041H
	xor	BYTE PTR [rcx+6], 25
	xor	BYTE PTR [rcx+7], -105			; ffffffffffffff97H
	xor	BYTE PTR [rcx+8], 55			; 00000037H
	xor	BYTE PTR [rcx+9], -25
	xor	BYTE PTR [rcx+10], 127			; 0000007fH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,-7558938099074472137,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,-7558938099074472137,char>::~obfuscated_data<11,-7558938099074472137,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,-7558938099074472137,char>::~obfuscated_data<11,-7558938099074472137,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?GIOGLOCGPCIABIMJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?GIOGLOCGPCIABIMJ@D@1@@Z PROC ; ay::obfuscated_data<11,-7558938099074472137,char>::obfuscated_data<11,-7558938099074472137,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?GIOGLOCGPCIABIMJ@D@1@@Z ENDP ; ay::obfuscated_data<11,-7558938099074472137,char>::obfuscated_data<11,-7558938099074472137,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<13,-2048805790205510789,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@e3912dfd25097b7be3912dfd25097b7b
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, -2048805790205510789		; e3912dfd25097b7bH
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<13,-2048805790205510789,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<13,-2048805790205510789,char>::~obfuscated_data<13,-2048805790205510789,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<13,-2048805790205510789,char>::~obfuscated_data<13,-2048805790205510789,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?BMGONCACNKPGIEIF@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?BMGONCACNKPGIEIF@D@1@@Z PROC ; ay::obfuscated_data<13,-2048805790205510789,char>::obfuscated_data<13,-2048805790205510789,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+13], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?BMGONCACNKPGIEIF@D@1@@Z ENDP ; ay::obfuscated_data<13,-2048805790205510789,char>::obfuscated_data<13,-2048805790205510789,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<10,8022544353138530575,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+10], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@6f55cd957ba3590f6f55cd957ba3590f
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, 8022544353138530575			; 6f55cd957ba3590fH
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 10
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+10], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<10,8022544353138530575,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<10,8022544353138530575,char>::~obfuscated_data<10,8022544353138530575,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<10,8022544353138530575,char>::~obfuscated_data<10,8022544353138530575,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$09$0GPFFMNJFHLKDFJAP@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$09$0GPFFMNJFHLKDFJAP@D@1@@Z PROC ; ay::obfuscated_data<10,8022544353138530575,char>::obfuscated_data<10,8022544353138530575,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+10], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAA@AEBV?$obfuscator@$09$0GPFFMNJFHLKDFJAP@D@1@@Z ENDP ; ay::obfuscated_data<10,8022544353138530575,char>::obfuscated_data<10,8022544353138530575,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<13,-3668875623370088579,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@cd15890f1fef9f7dcd15890f1fef9f7d
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, -3668875623370088579		; cd15890f1fef9f7dH
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<13,-3668875623370088579,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<13,-3668875623370088579,char>::~obfuscated_data<13,-3668875623370088579,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<13,-3668875623370088579,char>::~obfuscated_data<13,-3668875623370088579,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?DCOKHGPAOABAGAID@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?DCOKHGPAOABAGAID@D@1@@Z PROC ; ay::obfuscated_data<13,-3668875623370088579,char>::obfuscated_data<13,-3668875623370088579,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+13], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?DCOKHGPAOABAGAID@D@1@@Z ENDP ; ay::obfuscated_data<13,-3668875623370088579,char>::obfuscated_data<13,-3668875623370088579,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3179 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 3179 :     _CONSTEXPR20 ~basic_string() noexcept {

	mov	rbx, rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN16@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN30@basic_stri

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN27@basic_stri

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN30@basic_stri:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN16@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 3187 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN27@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN39@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2559 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN117:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	esi, esi
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rsi

; 2559 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	r14, rdx

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rsi

; 2559 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	rdi, rcx

; 398  :             return __builtin_strlen(_First);

	mov	rbx, -1
	npad	1
$LL103@basic_stri:
	inc	rbx
	cmp	BYTE PTR [rdx+rbx], sil
	jne	SHORT $LL103@basic_stri

; 2672 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbx, rbp
	ja	$LN114@basic_stri

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	rbx, 15
	ja	SHORT $LN21@basic_stri

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rdi+rbx], sil

; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();
; 2699 :             return;

	jmp	$LN19@basic_stri
$LN21@basic_stri:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rbx
	or	rax, 15
	cmp	rax, rbp

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN31@basic_stri

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN62@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN61@basic_stri

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rsi, QWORD PTR [rax+39]
	and	rsi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rsi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN48@basic_stri
$LN31@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN48@basic_stri

; 197  :         return nullptr;
; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN51@basic_stri

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN115@basic_stri
	jmp	SHORT $LN62@basic_stri
$LN51@basic_stri:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
$LN48@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rdi], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rdi+16], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rsi

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2713 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rsi+rbx], 0
$LN19@basic_stri:

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2561 :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN61@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN115@basic_stri:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN114@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN112@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN123:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	r14, rdx

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rbx, rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN17@basic_stri

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdx]
$LN17@basic_stri:

; 2672 :         if (_Count > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rdi
	ja	$LN120@basic_stri

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	rsi, 15
	ja	SHORT $LN25@basic_stri

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rsi

; 2510 :     }

	mov	rax, rbx

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0

; 2510 :     }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN25@basic_stri:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rcx, rsi
	or	rcx, 15
	cmp	rcx, rdi

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN35@basic_stri

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN66@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN65@basic_stri

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN52@basic_stri
$LN35@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	edx, 22
	mov	rdi, rcx
	cmp	rcx, rdx
	cmovb	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rdi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN52@basic_stri

; 197  :         return nullptr;
; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN55@basic_stri

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN121@basic_stri
	jmp	SHORT $LN66@basic_stri
$LN55@basic_stri:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN52@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]
	mov	QWORD PTR [rbx], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2510 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN65@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN121@basic_stri:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN120@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN118@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2499 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	xorps	xmm0, xmm0

; 2500 :         _Construct_empty();
; 2501 :     }

	mov	rax, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 2500 :         _Construct_empty();
; 2501 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@D@std@@PEAD$00@std@@QEAAAEAU?$default_delete@$$BY0A@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@D@std@@PEAD$00@std@@QEAAAEAU?$default_delete@$$BY0A@D@2@XZ PROC ; std::_Compressed_pair<std::default_delete<char [0]>,char *,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@D@std@@PEAD$00@std@@QEAAAEAU?$default_delete@$$BY0A@D@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<char [0]>,char *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<8,-9148647708104107571,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+8], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@810979618f4359cd810979618f4359cd
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+8], 0

; 151  : 			}
; 152  : 		}

	ret	0
$LN26@decrypt:
	mov	r9, -9148647708104107571		; 810979618f4359cdH
$LL25@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 8
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+8], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<8,-9148647708104107571,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<8,-9148647708104107571,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$07$0?HOPGIGJOHALMKGDD@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<8,-9148647708104107571,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,-193670462159642669,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+1], 31
	xor	BYTE PTR [rcx+2], 125			; 0000007dH
	xor	BYTE PTR [rcx+3], -93			; ffffffffffffffa3H
	xor	BYTE PTR [rcx+4], -67			; ffffffffffffffbdH
	xor	BYTE PTR [rcx+5], -15
	xor	BYTE PTR [rcx+6], 79			; 0000004fH
	xor	BYTE PTR [rcx+7], -3
	xor	BYTE PTR [rcx+8], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+9], 31
	xor	BYTE PTR [rcx+10], 125			; 0000007dH

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0L@$0?CLAAOECFMICOACN@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,-193670462159642669,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0?CLAAOECFMICOACN@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0?CLAAOECFMICOACN@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,-193670462159642669,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0?CLAAOECFMICOACN@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,-193670462159642669,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<5,2983409589604555257,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -7
	xor	BYTE PTR [rcx+1], -103			; ffffffffffffff99H
	xor	BYTE PTR [rcx+2], -33			; ffffffffffffffdfH
	xor	BYTE PTR [rcx+3], 7
	xor	BYTE PTR [rcx+4], 55			; 00000037H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<5,2983409589604555257,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<5,2983409589604555257,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$04$0CJGHDDDHAHNPJJPJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<5,2983409589604555257,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<9,1947751379898066285,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+9], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 109			; 0000006dH
	xor	BYTE PTR [rcx+1], -27
	xor	BYTE PTR [rcx+2], -103			; ffffffffffffff99H
	xor	BYTE PTR [rcx+3], 117			; 00000075H
	xor	BYTE PTR [rcx+4], -113			; ffffffffffffff8fH
	xor	BYTE PTR [rcx+5], -51			; ffffffffffffffcdH
	xor	BYTE PTR [rcx+6], 7
	xor	BYTE PTR [rcx+7], 27
	xor	BYTE PTR [rcx+8], 109			; 0000006dH

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+9], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<9,1947751379898066285,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<9,1947751379898066285,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$08$0BLAHMNIPHFJJOFGN@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<9,1947751379898066285,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<7,-1061941394542743601,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -49			; ffffffffffffffcfH
	xor	BYTE PTR [rcx+1], 47			; 0000002fH
	xor	BYTE PTR [rcx+3], -107			; ffffffffffffff95H
	xor	BYTE PTR [rcx+4], -19
	xor	BYTE PTR [rcx+5], 57			; 00000039H
	xor	BYTE PTR [rcx+6], 67			; 00000043H
	not	BYTE PTR [rcx+2]

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$06$0?OLMMGBCGKAANADB@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<7,-1061941394542743601,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$06$0?OLMMGBCGKAANADB@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$06$0?OLMMGBCGKAANADB@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<7,-1061941394542743601,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$06$0?OLMMGBCGKAANADB@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<7,-1061941394542743601,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<5,6185075688865743849,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -23
	xor	BYTE PTR [rcx+1], 67			; 00000043H
	xor	BYTE PTR [rcx+2], -65			; ffffffffffffffbfH
	xor	BYTE PTR [rcx+3], -81			; ffffffffffffffafH
	xor	BYTE PTR [rcx+4], -111			; ffffffffffffff91H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<5,6185075688865743849,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<5,6185075688865743849,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$04$0FFNFMNJBKPLPEDOJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<5,6185075688865743849,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<7,-2638032247341472419,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 93			; 0000005dH
	xor	BYTE PTR [rcx+1], -91			; ffffffffffffffa5H
	xor	BYTE PTR [rcx+2], 47			; 0000002fH
	xor	BYTE PTR [rcx+3], -33			; ffffffffffffffdfH
	xor	BYTE PTR [rcx+4], -91			; ffffffffffffffa5H
	xor	BYTE PTR [rcx+5], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+6], 99			; 00000063H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<7,-2638032247341472419,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<7,-2638032247341472419,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$06$0?CEJMCMFKCANAFKKD@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<7,-2638032247341472419,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<12,6339698204315287977,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+12], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@57fb21ed7b6501a957fb21ed7b6501a9
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, 6339698204315287977			; 57fb21ed7b6501a9H
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 12
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+12], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<12,6339698204315287977,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<12,6339698204315287977,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0M@$0FHPLCBONHLGFABKJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<12,6339698204315287977,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<5,-2048805790205510789,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 123			; 0000007bH
	xor	BYTE PTR [rcx+1], 123			; 0000007bH
	xor	BYTE PTR [rcx+2], 9
	xor	BYTE PTR [rcx+3], 37			; 00000025H
	xor	BYTE PTR [rcx+4], -3

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$04$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<5,-2048805790205510789,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$04$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$04$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<5,-2048805790205510789,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$04$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<5,-2048805790205510789,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,8022544353138530575,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 15
	xor	BYTE PTR [rcx+1], 89			; 00000059H
	xor	BYTE PTR [rcx+2], -93			; ffffffffffffffa3H
	xor	BYTE PTR [rcx+3], 123			; 0000007bH
	xor	BYTE PTR [rcx+4], -107			; ffffffffffffff95H
	xor	BYTE PTR [rcx+5], -51			; ffffffffffffffcdH
	xor	BYTE PTR [rcx+6], 85			; 00000055H
	xor	BYTE PTR [rcx+7], 111			; 0000006fH
	xor	BYTE PTR [rcx+8], 15
	xor	BYTE PTR [rcx+9], 89			; 00000059H
	xor	BYTE PTR [rcx+10], -93			; ffffffffffffffa3H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,8022544353138530575,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,8022544353138530575,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,8022544353138530575,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,-4509840863236766927,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 49			; 00000031H
	xor	BYTE PTR [rcx+1], 67			; 00000043H
	xor	BYTE PTR [rcx+2], 59			; 0000003bH
	xor	BYTE PTR [rcx+3], 9
	xor	BYTE PTR [rcx+4], -95			; ffffffffffffffa1H
	xor	BYTE PTR [rcx+5], -45			; ffffffffffffffd3H
	xor	BYTE PTR [rcx+6], 105			; 00000069H
	xor	BYTE PTR [rcx+7], -63			; ffffffffffffffc1H
	xor	BYTE PTR [rcx+8], 49			; 00000031H
	xor	BYTE PTR [rcx+9], 67			; 00000043H
	xor	BYTE PTR [rcx+10], 59			; 0000003bH

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,-4509840863236766927,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,-4509840863236766927,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0?DOJGCMFOPGMELMMP@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,-4509840863236766927,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,-7558938099074472137,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 55			; 00000037H
	xor	BYTE PTR [rcx+1], -25
	xor	BYTE PTR [rcx+2], 127			; 0000007fH
	xor	BYTE PTR [rcx+3], 13
	xor	BYTE PTR [rcx+4], -39			; ffffffffffffffd9H
	xor	BYTE PTR [rcx+5], 65			; 00000041H
	xor	BYTE PTR [rcx+6], 25
	xor	BYTE PTR [rcx+7], -105			; ffffffffffffff97H
	xor	BYTE PTR [rcx+8], 55			; 00000037H
	xor	BYTE PTR [rcx+9], -25
	xor	BYTE PTR [rcx+10], 127			; 0000007fH

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,-7558938099074472137,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,-7558938099074472137,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,-7558938099074472137,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<13,-2048805790205510789,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@e3912dfd25097b7be3912dfd25097b7b
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, -2048805790205510789		; e3912dfd25097b7bH
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<13,-2048805790205510789,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<13,-2048805790205510789,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0N@$0?BMGONCACNKPGIEIF@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<13,-2048805790205510789,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<10,8022544353138530575,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+10], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@6f55cd957ba3590f6f55cd957ba3590f
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, 8022544353138530575			; 6f55cd957ba3590fH
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 10
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+10], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<10,8022544353138530575,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<10,8022544353138530575,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$09$0GPFFMNJFHLKDFJAP@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<10,8022544353138530575,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<13,-3668875623370088579,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@cd15890f1fef9f7dcd15890f1fef9f7d
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, -3668875623370088579		; cd15890f1fef9f7dH
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<13,-3668875623370088579,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<13,-3668875623370088579,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0N@$0?DCOKHGPAOABAGAID@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<13,-3668875623370088579,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4896 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4897 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4892 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4893 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 4865 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 4865 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	mov	rbx, rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 4866 :         auto& _My_data = _Mypair._Myval2;
; 4867 :         _My_data._Orphan_all();
; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN13@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Tidy_deall

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@Tidy_deall

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@Tidy_deall:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 4879 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN35@Tidy_deall:
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 2647 :         auto& _My_data = _Mypair._Myval2;
; 2648 :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2649 : 
; 2650 :         // initialize basic_string data members
; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 2657 :     }

	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2235 :         const value_type* _Result = _Bx._Buf;
; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@Myptr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2241 :     }

	ret	0
$LN8@Myptr:

; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

	mov	rax, rcx

; 2241 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 718  :         return _Al;

	mov	rax, rcx

; 719  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 386  :         // find length of null-terminated string
; 387  : #if _HAS_CXX17
; 388  : #ifdef __cpp_char8_t
; 389  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 390  : #if _HAS_U8_INTRINSICS
; 391  :             return __builtin_u8strlen(_First);
; 392  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 393  :             return _Primary_char_traits::length(_First);
; 394  : #endif // ^^^ no u8 intrinsics ^^^
; 395  :         } else
; 396  : #endif // defined(__cpp_char8_t)
; 397  :         {
; 398  :             return __builtin_strlen(_First);

	mov	rax, -1
$LL4@length:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL4@length

; 399  :         }
; 400  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 401  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 402  : #endif // ^^^ !_HAS_CXX17 ^^^
; 403  :     }

	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 73   :     // return larger of _Left and _Right
; 74   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 75   : }

	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 2641 :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN27:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 2642 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r8+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN17@Deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN20@Deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2644 :     }

	add	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN17@Deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN24@Deallocate:
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }

	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15
	seta	al

; 2245 :     }

	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             return _Primary_char_traits::assign(_Left, _Right);
; 442  :         }
; 443  : #endif // _HAS_CXX20
; 444  :         _Left = _Right;
; 445  :     }

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	rax, rbx

; 68   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 951  :     }

	add	rsp, 40					; 00000028H

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 181  : #if _HAS_CXX20
; 182  :         if (_STD is_constant_evaluated()) {
; 183  :             _STD construct_at(_STD addressof(_Left), _Right);
; 184  :         } else
; 185  : #endif // _HAS_CXX20
; 186  :         {
; 187  :             _Left = _Right;
; 188  :         }
; 189  :     }

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	ret	0
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory
;	COMDAT ??$make_unique@$$BY0A@D$0A@@std@@YA?AV?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@0@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
_Size$dead$ = 72
??$make_unique@$$BY0A@D$0A@@std@@YA?AV?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@0@_K@Z PROC ; std::make_unique<char [0],0>, COMDAT

; 3599 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(const size_t _Size) { // make a unique_ptr

$LN15:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3601 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	ecx, 40					; 00000028H
	call	??_U@YAPEAX_K@Z				; operator new[]
	xorps	xmm0, xmm0
	xor	ecx, ecx
	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
	mov	QWORD PTR [rax+32], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rbx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory

; 3601 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rax, rbx

; 3602 : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$make_unique@$$BY0A@D$0A@@std@@YA?AV?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@0@_K@Z ENDP ; std::make_unique<char [0],0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory
;	COMDAT ??$?RD$0A@@?$default_delete@$$BY0A@D@std@@QEBAXPEAD@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$?RD$0A@@?$default_delete@$$BY0A@D@std@@QEBAXPEAD@Z PROC ; std::default_delete<char [0]>::operator()<char,0>, COMDAT

; 3313 :         static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
; 3314 :         delete[] _Ptr;

	mov	rcx, rdx
	jmp	??_V@YAXPEAX@Z				; operator delete[]
??$?RD$0A@@?$default_delete@$$BY0A@D@std@@QEBAXPEAD@Z ENDP ; std::default_delete<char [0]>::operator()<char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1086 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1087 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1088 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1089 : 
; 1090 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1091 :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 1092 :             _Xlength_error("size is too long for _Size_type");
; 1093 :         }
; 1094 :     }
; 1095 : 
; 1096 :     return static_cast<_Size_type>(_Len);

	mov	rax, rcx

; 1097 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
this$ = 80
_Arg$ = 88
_Count$ = 96
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 2662 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN97:
	push	rbx
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 40					; 00000028H

; 2663 :         auto& _My_data = _Mypair._Myval2;
; 2664 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2665 : 
; 2666 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2667 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2668 :         } else {
; 2669 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2670 :         }
; 2671 : 
; 2672 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	mov	rbx, r8
	mov	r14, rdx
	mov	rsi, rcx
	cmp	r8, rbp
	ja	$LN94@Construct

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	rbx, 15
	ja	SHORT $LN3@Construct

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2683 : 
; 2684 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2685 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2688 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rbx+rsi], 0

; 2714 :         } else { // _Strat == _Construct_strategy::_From_string
; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN3@Construct:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rbx
	mov	QWORD PTR [rsp+32], rdi
	or	rax, 15
	cmp	rax, rbp

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN13@Construct

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN44@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN43@Construct

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN30@Construct
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN31@Construct

; 197  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN30@Construct
$LN31@Construct:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN33@Construct

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN95@Construct
	jmp	SHORT $LN44@Construct
$LN33@Construct:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN30@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx

; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();
; 2699 :             return;
; 2700 :         }
; 2701 : 
; 2702 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());
; 2703 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2705 : 
; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rdi

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2708 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2711 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2713 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0
	mov	rdi, QWORD PTR [rsp+32]

; 2714 :         } else { // _Strat == _Construct_strategy::_From_string
; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN43@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN95@Construct:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN94@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN92@Construct:
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
this$ = 64
_Arg$ = 72
_Count$ = 80
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 2662 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN99:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2663 :         auto& _My_data = _Mypair._Myval2;
; 2664 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2665 : 
; 2666 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2667 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2668 :         } else {
; 2669 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2670 :         }
; 2671 : 
; 2672 :         if (_Count > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rsi, r8
	mov	rbp, rdx
	mov	rdi, rcx
	cmp	r8, rbx
	ja	$LN96@Construct

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	r8, 15
	ja	SHORT $LN3@Construct

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rsi
	or	rax, 15
	cmp	rax, rbx

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN13@Construct

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN44@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN43@Construct

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN30@Construct
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbx, rax
	cmp	rax, rcx
	cmovb	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN31@Construct

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN30@Construct
$LN31@Construct:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN33@Construct

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN97@Construct
	jmp	SHORT $LN44@Construct
$LN33@Construct:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN30@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]
	mov	QWORD PTR [rdi], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbp

; 2683 : 
; 2684 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2685 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2688 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();
; 2699 :             return;
; 2700 :         }
; 2701 : 
; 2702 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());
; 2703 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 2705 : 
; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rdi+16], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx

; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
$LN43@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN97@Construct:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN96@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN94@Construct:
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 36   :     return _Ptr;

	mov	rax, rcx

; 37   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 230  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN20:
	sub	rsp, 40					; 00000028H

; 231  :     // deallocate storage allocated by _Allocate
; 232  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         ::operator delete(_Ptr);
; 235  :         return;
; 236  :     }
; 237  : #endif // _HAS_CXX20
; 238  : 
; 239  : #ifdef __cpp_aligned_new
; 240  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 241  :         size_t _Passed_align = _Align;
; 242  : #if defined(_M_IX86) || defined(_M_X64)
; 243  :         if (_Bytes >= _Big_allocation_threshold) {
; 244  :             // boost the alignment of big allocations to help autovectorization
; 245  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 246  :         }
; 247  : #endif // defined(_M_IX86) || defined(_M_X64)
; 248  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 249  :     } else
; 250  : #endif // defined(__cpp_aligned_new)
; 251  :     {
; 252  : #if defined(_M_IX86) || defined(_M_X64)
; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@Deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN12@Deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN15@Deallocate:

; 259  :     }
; 260  : }

	add	rsp, 40					; 00000028H

; 254  :             // boost the alignment of big allocations to help autovectorization
; 255  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 256  :         }
; 257  : #endif // defined(_M_IX86) || defined(_M_X64)
; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@Deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN17@Deallocate:
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 290  :     if constexpr (is_array_v<_Ty>) {
; 291  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 292  :     } else {
; 293  :         _Obj.~_Ty();
; 294  :     }
; 295  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z PROC	; std::construct_at<char,char const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@DAEBD$0A@@std@@YAPEADQEADAEBD@Z ENDP	; std::construct_at<char,char const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Requested$ = 8
_Old$ = 16
_Max$ = 24
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rcx, 15
	cmp	rcx, r8

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN9@Calculate_

; 4765 :             return _Max;
; 4766 :         }
; 4767 : 
; 4768 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r9, rdx
	mov	rax, r8
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN9@Calculate_

; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r9+rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rax
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	rax, rcx

; 4773 :     }

	ret	0
$LN9@Calculate_:

; 4769 :             return _Max;

	mov	rax, r8

; 4773 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 4171 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 4172 :         const size_type _Storage_max = // can always store small string
; 4173 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4174 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 4175 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4176 :         );
; 4177 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 939  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	xorps	xmm0, xmm0
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBD@std@@YAAEBDAEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBD@std@@YAAEBDAEBD@Z PROC			; std::forward<char const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBD@std@@YAAEBDAEBD@Z ENDP			; std::forward<char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory
;	COMDAT ??$?0PEADU?$default_delete@$$BY0A@D@std@@$0A@$0A@@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@PEAD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0PEADU?$default_delete@$$BY0A@D@std@@$0A@$0A@@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@PEAD@Z PROC ; std::unique_ptr<char [0],std::default_delete<char [0]> >::unique_ptr<char [0],std::default_delete<char [0]> ><char *,std::default_delete<char [0]>,0,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\memory

; 3477 :     _CONSTEXPR23 explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0PEADU?$default_delete@$$BY0A@D@std@@$0A@$0A@@?$unique_ptr@$$BY0A@DU?$default_delete@$$BY0A@D@std@@@std@@QEAA@PEAD@Z ENDP ; std::unique_ptr<char [0],std::default_delete<char [0]> >::unique_ptr<char [0],std::default_delete<char [0]> ><char *,std::default_delete<char [0]>,0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Capacity$ = 56
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 2614 :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN52:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2615 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2616 :         ++_Capacity; // Take null terminator into consideration

	add	QWORD PTR [rdx], 1
	mov	rbx, rdx
	mov	rcx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	jne	SHORT $LN12@Allocate_f

; 197  :         return nullptr;

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2636 :         --_Capacity;

	dec	QWORD PTR [rdx]

; 2638 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN12@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN14@Allocate_f

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN50@Allocate_f

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN24@Allocate_f

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2636 :         --_Capacity;

	dec	QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2638 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN14@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2636 :         --_Capacity;

	dec	QWORD PTR [rbx]

; 2638 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN50@Allocate_f:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN48@Allocate_f:
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 96   :     // return smaller of _Left and _Right
; 97   :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rdx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 98   : }

	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0AEAPEAD@?$_Compressed_pair@U?$default_delete@$$BY0A@D@std@@PEAD$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAD@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAD@?$_Compressed_pair@U?$default_delete@$$BY0A@D@std@@PEAD$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAD@Z PROC ; std::_Compressed_pair<std::default_delete<char [0]>,char *,1>::_Compressed_pair<std::default_delete<char [0]>,char *,1><char * &>, COMDAT

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAD@?$_Compressed_pair@U?$default_delete@$$BY0A@D@std@@PEAD$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAD@Z ENDP ; std::_Compressed_pair<std::default_delete<char [0]>,char *,1>::_Compressed_pair<std::default_delete<char [0]>,char *,1><char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN33:
	sub	rsp, 40					; 00000028H

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN6@Allocate_a

; 197  :         return nullptr;

	xor	eax, eax

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Allocate_a:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@Allocate_a

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN32@Allocate_a

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@Allocate_a

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@Allocate_a:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN32@Allocate_a:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN18@Allocate_a:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN30@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z PROC		; std::construct_at<char,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z ENDP		; std::construct_at<char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 196  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 197  :         return nullptr;

	xor	eax, eax

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@allocate:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN29@allocate

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@allocate:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN29@allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN16@allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN27@allocate:
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 194  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN27:
	sub	rsp, 40					; 00000028H

; 195  :     // allocate _Bytes
; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN2@Allocate

; 197  :         return nullptr;

	xor	eax, eax

; 221  :             // boost the alignment of big allocations to help autovectorization
; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 223  :         }
; 224  : #endif // defined(_M_IX86) || defined(_M_X64)
; 225  :         return _Traits::_Allocate(_Bytes);
; 226  :     }
; 227  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@Allocate:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN26@Allocate

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN14@Allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 221  :             // boost the alignment of big allocations to help autovectorization
; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 223  :         }
; 224  : #endif // defined(_M_IX86) || defined(_M_X64)
; 225  :         return _Traits::_Allocate(_Bytes);
; 226  :     }
; 227  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Allocate:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN26@Allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN14@Allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN24@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {
; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	mov	rax, rcx

; 90   : }

	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 151  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN17:
	sub	rsp, 40					; 00000028H

; 152  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN16@Allocate_m

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN7@Allocate_m

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 162  : 
; 163  : #ifdef _DEBUG
; 164  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 165  : #endif // defined(_DEBUG)
; 166  :     return _Ptr;
; 167  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Allocate_m:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN16@Allocate_m:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
END
