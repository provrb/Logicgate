; Listing generated by Microsoft (R) Optimizing Compiler Version 19.40.33811.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?piecewise_construct@std@@3Upiecewise_construct_t@1@B ; std::piecewise_construct
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Min_buckets
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
EXTRN	_Mtx_unlock:PROC
EXTRN	_Mtx_lock:PROC
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
EXTRN	__imp_htons:PROC
;	COMDAT ??_R0?AVout_of_range@std@@@8
data$r	SEGMENT
??_R0?AVout_of_range@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVout_of_range@std@@', 00H
data$r	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
PUBLIC	??$move@AEAV?$tuple@AEBJ@std@@@std@@YA$$QEAV?$tuple@AEBJ@0@AEAV10@@Z ; std::move<std::tuple<long const &> &>
PUBLIC	??$_Tuple_get@$0A@AEBJ@std@@YA$$QEA_P$$QEAV?$tuple@AEBJ@0@@Z ; std::_Tuple_get<0,long const &>
PUBLIC	??$?0V?$tuple@AEBJ@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@AEAV?$tuple@AEBJ@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > ><std::tuple<long const &>,std::tuple<>,0>
PUBLIC	??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z	; std::construct_at<unsigned char,unsigned char &,0>
PUBLIC	??$?0AEBJ@?$_Tuple_val@AEBJ@std@@QEAA@AEBJ@Z	; std::_Tuple_val<long const &>::_Tuple_val<long const &><long const &>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$V$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
PUBLIC	??$?0AEBJ$$Z$$V@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@Z ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > ><long const &>
PUBLIC	??0?$tuple@AEBJ@std@@QEAA@$$QEAV01@@Z		; std::tuple<long const &>::tuple<long const &>
PUBLIC	??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &,0>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
PUBLIC	??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
PUBLIC	??$forward@AEAE@std@@YAAEAEAEAE@Z		; std::forward<unsigned char &>
PUBLIC	??$construct_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBJ@0@$$QEAV?$tuple@$$V@0@@Z ; std::construct_at<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<>,0>
PUBLIC	??$?0U_Exact_args_t@std@@AEBJ$$V$0A@@?$tuple@AEBJ@std@@QEAA@U_Exact_args_t@1@AEBJ@Z ; std::tuple<long const &>::tuple<long const &><std::_Exact_args_t,long const &,0>
PUBLIC	??$?0AEAVClient@@@?$_Tuple_val@VClient@@@std@@QEAA@AEAVClient@@@Z ; std::_Tuple_val<Client>::_Tuple_val<Client><Client &>
PUBLIC	??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
PUBLIC	?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
PUBLIC	?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
PUBLIC	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
PUBLIC	??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::operator()
PUBLIC	?_Get_bits@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAAIXZ ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
PUBLIC	?_Get_random_product@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KKI@Z ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_random_product
PUBLIC	?_Adjust@?$uniform_int@J@std@@CAKK@Z		; std::uniform_int<long>::_Adjust
PUBLIC	?_Get_rest@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV?$tuple@$$V@2@XZ ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get_rest
PUBLIC	??0?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAA@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??R?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAKK@Z ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::operator()
PUBLIC	?_Get_all_bits@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAIXZ ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_all_bits
PUBLIC	??_G?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAAPEAXI@Z ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::`scalar deleting destructor'
PUBLIC	??$_Fnv1a_append_value@J@std@@YA_K_KAEBJ@Z	; std::_Fnv1a_append_value<long>
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * const &,0>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * const &>
PUBLIC	??1?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@XZ ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$destroy_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAXQEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@@Z ; std::destroy_at<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &>
PUBLIC	??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char &>
PUBLIC	??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z	; std::move<unsigned char * &>
PUBLIC	??$forward@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *>
PUBLIC	??$construct@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::construct<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<> >
PUBLIC	??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$forward@V?$tuple@AEBJ@std@@@std@@YA$$QEAV?$tuple@AEBJ@0@AEAV10@@Z ; std::forward<std::tuple<long const &> >
PUBLIC	??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ; std::forward<std::piecewise_construct_t const &>
PUBLIC	??$?0AEBJ$0A@@?$tuple@AEBJ@std@@QEAA@AEBJ@Z	; std::tuple<long const &>::tuple<long const &><long const &,0>
PUBLIC	??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$forward@V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::forward<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@AEBAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@JJ@Z ; std::uniform_int<long>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??R?$equal_to@J@std@@QEBA_NAEBJ0@Z		; std::equal_to<long>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@J@std@@M$00@std@@QEBAAEBU?$equal_to@J@2@XZ ; std::_Compressed_pair<std::equal_to<long>,float,1>::_Get_first
PUBLIC	??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Get_rest@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get_rest
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_Allocate
PUBLIC	??$_Hash_representation@J@std@@YA_KAEBJ@Z	; std::_Hash_representation<long>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * const &>
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,std::nullptr_t>
PUBLIC	??$destroy@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::destroy<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$addressof@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *>
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
PUBLIC	??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ; std::ranges::_Unwrap_sent<unsigned char *,unsigned char *>
PUBLIC	??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ; std::ranges::_Unwrap_iter<unsigned char *,unsigned char *>
PUBLIC	??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z	; std::forward<unsigned char * const &>
PUBLIC	??$?0PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool>::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool><std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool,0>
PUBLIC	??$?0AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool>::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool><std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * &,bool,0>
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<> >
PUBLIC	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
PUBLIC	??$forward_as_tuple@AEBJ@std@@YA?AV?$tuple@AEBJ@0@AEBJ@Z ; std::forward_as_tuple<long const &>
PUBLIC	??$forward@AEBJ@std@@YAAEBJAEBJ@Z		; std::forward<long const &>
PUBLIC	??$_Kfn@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@SAAEBJAEBU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z ; std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0>::_Kfn<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptInternetData<ClientResponse>
PUBLIC	??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptInternetData<ClientRequest>
PUBLIC	??$get@$00VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@@Z ; std::get<1,Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$forward@V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YA$$QEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@AEAV10@@Z ; std::forward<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$forward@VClient@@@std@@YA$$QEAVClient@@AEAV1@@Z ; std::forward<Client>
PUBLIC	??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
PUBLIC	??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$forward@AEAVClient@@@std@@YAAEAVClient@@AEAV1@@Z ; std::forward<Client &>
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::uniform_int<long>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??$?RJJ@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBA_NAEBJ0@Z ; std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >::operator()<long,long>
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Orphan_non_end
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::clear
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_erase
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >::_Get_max_bucket_size
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_begin
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,1>::_Get_first
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::clear
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::max_size
PUBLIC	?_Getal@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Getal
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_splice
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_end
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBJ@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::bucket
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Min_load_factor_buckets
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Max_bucket_size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::max_size
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator==
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator++
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::__autoclassinit2
PUBLIC	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
PUBLIC	?_Do_hash@?$hash@J@std@@SA_KAEBJ@Z		; std::hash<long>::_Do_hash
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >::deallocate
PUBLIC	?max_size@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::max_size
PUBLIC	?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Orphan_ptr2
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::bucket_count
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::max_load_factor
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Forced_rehash
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
PUBLIC	??R?$_Conditionally_enabled_hash@J$00@std@@QEBA_KAEBJ@Z ; std::_Conditionally_enabled_hash<long,1>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@J@std@@V?$_Compressed_pair@U?$equal_to@J@std@@M$00@2@$00@std@@QEBAAEBU?$hash@J@2@XZ ; std::_Compressed_pair<std::hash<long>,std::_Compressed_pair<std::equal_to<long>,float,1>,1>::_Get_first
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::deallocate
PUBLIC	?_Unchecked_erase@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@@Z ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_erase
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Rehash_for_1
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Erase_bucket
PUBLIC	?_Get_rest@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get_rest
PUBLIC	??0?$_Tuple_val@VClient@@@std@@QEAA@XZ		; std::_Tuple_val<Client>::_Tuple_val<Client>
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_Release
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
PUBLIC	??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::_Release
PUBLIC	??0ClientResponse@@QEAA@$$QEAU0@@Z		; ClientResponse::ClientResponse
PUBLIC	??0ClientRequest@@QEAA@$$QEAU0@@Z		; ClientRequest::ClientRequest
PUBLIC	??$_Get_size_of_n@$0BCA@@std@@YA_K_K@Z		; std::_Get_size_of_n<288>
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > * const &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>
PUBLIC	??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char * const &,unsigned char * const &>
PUBLIC	??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >
PUBLIC	??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Try_emplace<long const &>
PUBLIC	??$_Find_last@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBJ_K@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Find_last<long>
PUBLIC	??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z ; ServerInterface::DecryptClientData<ClientResponse>
PUBLIC	??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z ; ServerInterface::DecryptClientData<ClientRequest>
PUBLIC	??4ClientResponse@@QEAAAEAU0@$$QEAU0@@Z		; ClientResponse::operator=
PUBLIC	??4Client@@QEAAAEAV0@$$QEAV0@@Z			; Client::operator=
PUBLIC	??$?4V?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,Client,0>
PUBLIC	??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z ; std::make_tuple<Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$get@$0A@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@YAAEAVClient@@AEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@@Z ; std::get<0,Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>
PUBLIC	??$?RJ@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBA_KAEBJ@Z ; std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >::operator()<long>
PUBLIC	??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Erase<long>
PUBLIC	??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int_distribution@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >::allocate
PUBLIC	?_Init@param_type@?$uniform_int@J@std@@QEAAXJJ@Z ; std::uniform_int<long>::param_type::_Init
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,1>::_Get_first
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::allocate
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::size
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
PUBLIC	??0param_type@?$uniform_int@J@std@@QEAA@JJ@Z	; std::uniform_int<long>::param_type::param_type
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_end
PUBLIC	?_Getal@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Getal
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::deallocate
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::_Assign_grow
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >,1>::_Get_first
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction
PUBLIC	??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
PUBLIC	??0?$uniform_int@J@std@@QEAA@JJ@Z		; std::uniform_int<long>::uniform_int<long>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?decrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z	; Cipher::Aes<256>::decrypt_block
PUBLIC	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@XZ ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
PUBLIC	??0?$uniform_int_distribution@J@std@@QEAA@JJ@Z	; std::uniform_int_distribution<long>::uniform_int_distribution<long>
PUBLIC	??0?$lock_guard@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z ; std::lock_guard<std::mutex>::lock_guard<std::mutex>
PUBLIC	??1?$lock_guard@Vmutex@std@@@std@@QEAA@XZ	; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
PUBLIC	?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::erase
PUBLIC	??A?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@1@AEBJ@Z ; std::unordered_map<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::hash<long>,std::equal_to<long>,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator[]
PUBLIC	?at@?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@2@AEBJ@Z ; std::unordered_map<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::hash<long>,std::equal_to<long>,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::at
PUBLIC	?IsCUIDInUse@ServerInterface@@QEAAHJ@Z		; ServerInterface::IsCUIDInUse
PUBLIC	?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z ; ServerInterface::EncryptServerRequest
PUBLIC	?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z ; ServerInterface::DecryptClientResponse
PUBLIC	?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z ; ServerInterface::DecryptClientRequest
PUBLIC	?IsClientAlive@ServerInterface@@QEAAHJ@Z	; ServerInterface::IsClientAlive
PUBLIC	?AddToClientList@ServerInterface@@QEAAHVClient@@@Z ; ServerInterface::AddToClientList
PUBLIC	?ClientIsInClientList@ServerInterface@@QEAAHJ@Z	; ServerInterface::ClientIsInClientList
PUBLIC	?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z ; ServerInterface::PingClient
PUBLIC	?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z ; ServerInterface::PerformUDPRequest
PUBLIC	?AcceptTCPConnection@ServerInterface@@QEAAJVClient@@@Z ; ServerInterface::AcceptTCPConnection
PUBLIC	?UDPSendMessageToClient@ServerInterface@@QEAAHJUUDPResponse@@@Z ; ServerInterface::UDPSendMessageToClient
PUBLIC	?WaitForClientResponse@ServerInterface@@QEAA?AUClientResponse@@J@Z ; ServerInterface::WaitForClientResponse
PUBLIC	?TCPSendMessageToClient@ServerInterface@@QEAAHJUServerCommand@@@Z ; ServerInterface::TCPSendMessageToClient
PUBLIC	?NewServerInstance@ServerInterface@@QEAA?AUServer@@W4SocketTypes@@H@Z ; ServerInterface::NewServerInstance
PUBLIC	??0ClientResponse@@QEAA@AEBU0@@Z		; ClientResponse::ClientResponse
PUBLIC	??0Client@@QEAA@AEBV0@@Z			; Client::Client
PUBLIC	??0?$_Tuple_val@VClient@@@std@@QEAA@AEBU01@@Z	; std::_Tuple_val<Client>::_Tuple_val<Client>
PUBLIC	??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBU01@@Z ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1Client@@QEAA@XZ				; Client::~Client
PUBLIC	??1?$_Tuple_val@VClient@@@std@@QEAA@XZ		; std::_Tuple_val<Client>::~_Tuple_val<Client>
PUBLIC	??1?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1ClientResponse@@QEAA@XZ			; ClientResponse::~ClientResponse
PUBLIC	?GetClientList@ServerInterface@@QEAAAEAV?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@XZ ; ServerInterface::GetClientList
PUBLIC	??0ClientResponse@@QEAA@XZ			; ClientResponse::ClientResponse
PUBLIC	??0Client@@QEAA@XZ				; Client::Client
PUBLIC	?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z ; ServerInterface::GetClientData
PUBLIC	?RemoveClientFromClientList@ServerInterface@@QEAAHJ@Z ; ServerInterface::RemoveClientFromClientList
PUBLIC	?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
PUBLIC	?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ ; std::_Mutex_base::_Verify_ownership_levels
PUBLIC	?unlock@_Mutex_base@std@@QEAAXXZ		; std::_Mutex_base::unlock
PUBLIC	?lock@_Mutex_base@std@@QEAAXXZ			; std::_Mutex_base::lock
PUBLIC	?SetClientID@Client@@QEAAXJ@Z			; Client::SetClientID
PUBLIC	?GenerateCUID@Client@@QEAAJXZ			; Client::GenerateCUID
PUBLIC	?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; NetCommon::RequestToBlob
PUBLIC	?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptByteString
PUBLIC	??0Server@@QEAA@XZ				; Server::Server
PUBLIC	??0?$tuple@$$V@std@@QEAA@AEBV01@@Z		; std::tuple<>::tuple<>
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$tuple@AEBJ@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@AEAV?$tuple@AEBJ@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+34
	DD	imagerel $unwind$??$?0V?$tuple@AEBJ@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@AEAV?$tuple@AEBJ@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$V$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN9
	DD	imagerel $LN9+26
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$V$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBJ$$Z$$V@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@Z DD imagerel $LN7
	DD	imagerel $LN7+34
	DD	imagerel $unwind$??$?0AEBJ$$Z$$V@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBJ@0@$$QEAV?$tuple@$$V@0@@Z DD imagerel $LN12
	DD	imagerel $LN12+34
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBJ@0@$$QEAV?$tuple@$$V@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAVClient@@@?$_Tuple_val@VClient@@@std@@QEAA@AEAVClient@@@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??$?0AEAVClient@@@?$_Tuple_val@VClient@@@std@@QEAA@AEAVClient@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DD imagerel $LN16
	DD	imagerel $LN16+57
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ DD imagerel $LN20
	DD	imagerel $LN20+235
	DD	imagerel $unwind$?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD imagerel $LN37
	DD	imagerel $LN37+116
	DD	imagerel $unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD imagerel $LN37+116
	DD	imagerel $LN37+331
	DD	imagerel $chain$0$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD imagerel $LN37+331
	DD	imagerel $LN37+396
	DD	imagerel $chain$1$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_random_product@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KKI@Z DD imagerel $LN17
	DD	imagerel $LN17+28
	DD	imagerel $unwind$?_Get_random_product@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KKI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAKK@Z DD imagerel $LN42
	DD	imagerel $LN42+107
	DD	imagerel $unwind$??R?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAKK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN22
	DD	imagerel $LN22+45
	DD	imagerel $unwind$??_G?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+32
	DD	imagerel $unwind$??1?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAXQEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@@Z DD imagerel $LN25
	DD	imagerel $LN25+32
	DD	imagerel $unwind$??$destroy_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAXQEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN9
	DD	imagerel $LN9+23
	DD	imagerel $unwind$??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z DD imagerel $LN23
	DD	imagerel $LN23+85
	DD	imagerel $unwind$??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@AEBAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@JJ@Z DD imagerel $LN74
	DD	imagerel $LN74+162
	DD	imagerel $unwind$??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@AEBAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@JJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+37
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z DD imagerel $LN27
	DD	imagerel $LN27+32
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN75
	DD	imagerel $LN75+54
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z DD imagerel $LN24
	DD	imagerel $LN24+49
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN49
	DD	imagerel $LN49+76
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD imagerel $LN80
	DD	imagerel $LN80+275
	DD	imagerel $unwind$??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD imagerel $LN80
	DD	imagerel $LN80+289
	DD	imagerel $unwind$??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN15
	DD	imagerel $LN15+54
	DD	imagerel $unwind$??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DD imagerel $LN26
	DD	imagerel $LN26+83
	DD	imagerel $unwind$??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z DD imagerel $LN76
	DD	imagerel $LN76+155
	DD	imagerel $unwind$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN79
	DD	imagerel $LN79+83
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN92
	DD	imagerel $LN92+36
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN92+36
	DD	imagerel $LN92+100
	DD	imagerel $chain$1$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN92+100
	DD	imagerel $LN92+133
	DD	imagerel $chain$2$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN275
	DD	imagerel $LN275+45
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN275+45
	DD	imagerel $LN275+520
	DD	imagerel $chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN275+520
	DD	imagerel $LN275+534
	DD	imagerel $chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN275+534
	DD	imagerel $LN275+558
	DD	imagerel $chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN112
	DD	imagerel $LN112+62
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN112+62
	DD	imagerel $LN112+86
	DD	imagerel $chain$0$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN112+86
	DD	imagerel $LN112+148
	DD	imagerel $chain$2$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN112+148
	DD	imagerel $LN112+203
	DD	imagerel $chain$3$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN112+203
	DD	imagerel $LN112+209
	DD	imagerel $chain$4$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN12
	DD	imagerel $LN12+99
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN118
	DD	imagerel $LN118+71
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN118+71
	DD	imagerel $LN118+95
	DD	imagerel $chain$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN118+95
	DD	imagerel $LN118+164
	DD	imagerel $chain$2$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN118+164
	DD	imagerel $LN118+219
	DD	imagerel $chain$3$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN118+219
	DD	imagerel $LN118+225
	DD	imagerel $chain$4$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+115
	DD	imagerel $unwind$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN25
	DD	imagerel $LN25+159
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN291
	DD	imagerel $LN291+47
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN291+47
	DD	imagerel $LN291+120
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN291+120
	DD	imagerel $LN291+356
	DD	imagerel $chain$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN291+356
	DD	imagerel $LN291+373
	DD	imagerel $chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN291+373
	DD	imagerel $LN291+411
	DD	imagerel $chain$5$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN291+411
	DD	imagerel $LN291+424
	DD	imagerel $chain$6$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN67
	DD	imagerel $LN67+139
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD imagerel $LN46
	DD	imagerel $LN46+136
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@@Z DD imagerel $LN79
	DD	imagerel $LN79+90
	DD	imagerel $unwind$?_Unchecked_erase@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN27
	DD	imagerel $LN27+175
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN58
	DD	imagerel $LN58+70
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ DD imagerel $LN37
	DD	imagerel $LN37+92
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+62
	DD	imagerel $LN21+98
	DD	imagerel $chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+98
	DD	imagerel $LN21+132
	DD	imagerel $chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN88
	DD	imagerel $LN88+25
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN88+25
	DD	imagerel $LN88+87
	DD	imagerel $chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN88+87
	DD	imagerel $LN88+93
	DD	imagerel $chain$2$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+46
	DD	imagerel $LN104+162
	DD	imagerel $chain$0$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+162
	DD	imagerel $LN104+163
	DD	imagerel $chain$1$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+163
	DD	imagerel $LN104+169
	DD	imagerel $chain$2$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+169
	DD	imagerel $LN104+175
	DD	imagerel $chain$3$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN104+175
	DD	imagerel $LN104+181
	DD	imagerel $chain$4$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z DD imagerel $LN245
	DD	imagerel $LN245+682
	DD	imagerel $unwind$??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DD imagerel $LN405
	DD	imagerel $LN405+760
	DD	imagerel $unwind$??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DD imagerel $LN405
	DD	imagerel $LN405+771
	DD	imagerel $unwind$??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4ClientResponse@@QEAAAEAU0@$$QEAU0@@Z DD imagerel $LN6
	DD	imagerel $LN6+47
	DD	imagerel $unwind$??4ClientResponse@@QEAAAEAU0@$$QEAU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Client@@QEAAAEAV0@$$QEAV0@@Z DD imagerel $LN12
	DD	imagerel $LN12+177
	DD	imagerel $unwind$??4Client@@QEAAAEAV0@$$QEAV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4V?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN27
	DD	imagerel $LN27+271
	DD	imagerel $unwind$??$?4V?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z DD imagerel $LN30
	DD	imagerel $LN30+83
	DD	imagerel $unwind$??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ DD imagerel $LN177
	DD	imagerel $LN177+278
	DD	imagerel $unwind$??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z DD imagerel $LN148
	DD	imagerel $LN148+145
	DD	imagerel $unwind$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z DD imagerel $LN148+145
	DD	imagerel $LN148+259
	DD	imagerel $chain$0$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z DD imagerel $LN148+259
	DD	imagerel $LN148+267
	DD	imagerel $chain$1$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int_distribution@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z DD imagerel $LN78
	DD	imagerel $LN78+155
	DD	imagerel $unwind$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int_distribution@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN34
	DD	imagerel $LN34+111
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+66
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN103
	DD	imagerel $LN103+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN103+54
	DD	imagerel $LN103+257
	DD	imagerel $chain$0$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN103+257
	DD	imagerel $LN103+306
	DD	imagerel $chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN103+306
	DD	imagerel $LN103+318
	DD	imagerel $chain$2$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN111
	DD	imagerel $LN111+188
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$lock_guard@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z DD imagerel $LN20
	DD	imagerel $LN20+82
	DD	imagerel $unwind$??0?$lock_guard@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z DD imagerel $LN152
	DD	imagerel $LN152+145
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z DD imagerel $LN152+145
	DD	imagerel $LN152+259
	DD	imagerel $chain$0$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z DD imagerel $LN152+259
	DD	imagerel $LN152+267
	DD	imagerel $chain$1$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@1@AEBJ@Z DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$??A?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@1@AEBJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?at@?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@2@AEBJ@Z DD imagerel $LN56
	DD	imagerel $LN56+148
	DD	imagerel $unwind$?at@?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@2@AEBJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z DD imagerel $LN12
	DD	imagerel $LN12+82
	DD	imagerel $unwind$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??IsCUIDInUse@ServerInterface@@QEAAHJ@Z@4HA DD imagerel ?catch$0@?0??IsCUIDInUse@ServerInterface@@QEAAHJ@Z@4HA
	DD	imagerel ?catch$0@?0??IsCUIDInUse@ServerInterface@@QEAAHJ@Z@4HA+30
	DD	imagerel $unwind$?catch$0@?0??IsCUIDInUse@ServerInterface@@QEAAHJ@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z DD imagerel $LN23
	DD	imagerel $LN23+317
	DD	imagerel $unwind$?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DD imagerel $LN39
	DD	imagerel $LN39+179
	DD	imagerel $unwind$?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DD imagerel $LN39
	DD	imagerel $LN39+179
	DD	imagerel $unwind$?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsClientAlive@ServerInterface@@QEAAHJ@Z DD imagerel $LN194
	DD	imagerel $LN194+405
	DD	imagerel $unwind$?IsClientAlive@ServerInterface@@QEAAHJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddToClientList@ServerInterface@@QEAAHVClient@@@Z DD imagerel $LN343
	DD	imagerel $LN343+743
	DD	imagerel $unwind$?AddToClientList@ServerInterface@@QEAAHVClient@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z DD imagerel $LN184
	DD	imagerel $LN184+431
	DD	imagerel $unwind$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$18@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA DD imagerel ?catch$18@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA
	DD	imagerel ?catch$18@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA+44
	DD	imagerel $unwind$?catch$18@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z DD imagerel $LN486
	DD	imagerel $LN486+761
	DD	imagerel $unwind$?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z DD imagerel $LN166
	DD	imagerel $LN166+518
	DD	imagerel $unwind$?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AcceptTCPConnection@ServerInterface@@QEAAJVClient@@@Z DD imagerel $LN5
	DD	imagerel $LN5+19
	DD	imagerel $unwind$?AcceptTCPConnection@ServerInterface@@QEAAJVClient@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TCPSendMessageToClient@ServerInterface@@QEAAHJUServerCommand@@@Z DD imagerel $LN5
	DD	imagerel $LN5+22
	DD	imagerel $unwind$?TCPSendMessageToClient@ServerInterface@@QEAAHJUServerCommand@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?NewServerInstance@ServerInterface@@QEAA?AUServer@@W4SocketTypes@@H@Z DD imagerel $LN15
	DD	imagerel $LN15+150
	DD	imagerel $unwind$?NewServerInstance@ServerInterface@@QEAA?AUServer@@W4SocketTypes@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ClientResponse@@QEAA@AEBU0@@Z DD imagerel $LN6
	DD	imagerel $LN6+47
	DD	imagerel $unwind$??0ClientResponse@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Client@@QEAA@AEBV0@@Z DD imagerel $LN16
	DD	imagerel $LN16+184
	DD	imagerel $unwind$??0Client@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tuple_val@VClient@@@std@@QEAA@AEBU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??0?$_Tuple_val@VClient@@@std@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN9
	DD	imagerel $LN9+23
	DD	imagerel $unwind$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z DD imagerel $LN16
	DD	imagerel $LN16+55
	DD	imagerel $unwind$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z DD imagerel $LN23
	DD	imagerel $LN23+69
	DD	imagerel $unwind$??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Client@@QEAA@XZ DD imagerel $LN220
	DD	imagerel $LN220+427
	DD	imagerel $unwind$??1Client@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD imagerel $LN48
	DD	imagerel $LN48+94
	DD	imagerel $unwind$??1?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD imagerel $LN54
	DD	imagerel $LN54+94
	DD	imagerel $unwind$??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ DD imagerel $LN106
	DD	imagerel $LN106+169
	DD	imagerel $unwind$??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ DD imagerel $LN11
	DD	imagerel $LN11+31
	DD	imagerel $unwind$??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ClientResponse@@QEAA@XZ DD imagerel $LN48
	DD	imagerel $LN48+94
	DD	imagerel $unwind$??1ClientResponse@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetClientList@ServerInterface@@QEAAAEAV?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@XZ DD imagerel $LN30
	DD	imagerel $LN30+92
	DD	imagerel $unwind$?GetClientList@ServerInterface@@QEAAAEAV?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z DD imagerel $LN65
	DD	imagerel $LN65+237
	DD	imagerel $unwind$?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RemoveClientFromClientList@ServerInterface@@QEAAHJ@Z DD imagerel $LN182
	DD	imagerel $LN182+358
	DD	imagerel $unwind$?RemoveClientFromClientList@ServerInterface@@QEAAHJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?lock@_Mutex_base@std@@QEAAXXZ DD imagerel $LN17
	DD	imagerel $LN17+62
	DD	imagerel $unwind$?lock@_Mutex_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateCUID@Client@@QEAAJXZ DD imagerel $LN105
	DD	imagerel $LN105+193
	DD	imagerel $unwind$?GenerateCUID@Client@@QEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN82
	DD	imagerel $LN82+348
	DD	imagerel $unwind$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD imagerel $LN94
	DD	imagerel $LN94+387
	DD	imagerel $unwind$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 06H
	DB	'|'
	DB	02H
	DB	'M', 03H
	DB	00H
	DB	0ccH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	imagerel $ip2state$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 051f19H
	DD	032340dH
	DD	02e010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	0162H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	0f4H
	DB	06H
	DB	01cH
	DB	08H
	DB	01cH
	DB	0aH
	DB	0a2H
	DB	0cH
	DB	0beH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0cH
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a0H
	DB	034H
	DD	imagerel ??1ServerCommand@@QEAA@XZ
	DB	090H
	DB	034H
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$10@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$11@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	086H
	DD	imagerel ?dtor$4@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 061a19H
	DD	0e007b20bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateCUID@Client@@QEAAJXZ DD 021f19H
	DD	0279010dH
	DD	imagerel __GSHandlerCheck
	DD	013b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?lock@_Mutex_base@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RemoveClientFromClientList@ServerInterface@@QEAAHJ@Z DD 081001H
	DD	0c3410H
	DD	0f00c3210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z DB 08H
	DB	'>'
	DB	00H
	DB	011H, 02H
	DB	02H
	DB	01cH
	DB	04H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	0b0H
	DB	03cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z
	DD	imagerel $ip2state$?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z DD 061611H
	DD	0a3416H
	DD	070125216H
	DD	050106011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetClientList@ServerInterface@@QEAAAEAV?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ClientResponse@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Client@@QEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z DB 06H
	DB	'*'
	DB	00H
	DB	01cH
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	060H
	DB	03cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z DB 04H
	DB	'*'
	DB	00H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBU01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tuple_val@VClient@@@std@@QEAA@AEBU01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Client@@QEAA@AEBV0@@Z DB 0aH
	DB	'>'
	DB	00H
	DB	'('
	DB	02H
	DB	'2'
	DB	04H
	DB	'^'
	DB	06H
	DB	'('
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Client@@QEAA@AEBV0@@Z DB 08H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???0Client@@QEAA@AEBV0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0Client@@QEAA@AEBV0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0Client@@QEAA@AEBV0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Client@@QEAA@AEBV0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0Client@@QEAA@AEBV0@@Z
	DD	imagerel $ip2state$??0Client@@QEAA@AEBV0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Client@@QEAA@AEBV0@@Z DD 081911H
	DD	096419H
	DD	085419H
	DD	073419H
	DD	070153219H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0Client@@QEAA@AEBV0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ClientResponse@@QEAA@AEBU0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?NewServerInstance@ServerInterface@@QEAA?AUServer@@W4SocketTypes@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TCPSendMessageToClient@ServerInterface@@QEAAHJUServerCommand@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AcceptTCPConnection@ServerInterface@@QEAAJVClient@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z DB 08H
	DB	0c2H
	DB	02H
	DB	0fdH, 02H
	DB	04H
	DB	'&'
	DB	06H
	DB	0b5H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	081H
	DB	04H
	DB	03aH
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	0c1H
	DB	03H
	DB	03aH
	DD	imagerel ??1Client@@QEAA@XZ
	DB	0c1H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	imagerel $ip2state$?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z DD 072419H
	DD	0466412H
	DD	0443412H
	DD	0420112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	0202H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z DB 012H
	DB	'v'
	DB	00H
	DB	'|'
	DB	02H
	DB	'"'
	DB	04H
	DB	'a', 03H
	DB	00H
	DB	098H
	DB	06H
	DB	'"'
	DB	08H
	DB	'x'
	DB	0aH
	DB	01eH
	DB	0cH
	DB	01cH
	DB	0eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z DB 0eH
	DB	0aH
	DD	imagerel ??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
	DB	0c1H
	DB	04H
	DB	03aH
	DD	imagerel ??1Client@@QEAA@XZ
	DB	01H
	DB	09H
	DB	03eH
	DD	imagerel ?dtor$6@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	03H
	DB	09aH
	DD	imagerel ??1ServerCommand@@QEAA@XZ
	DB	0c1H
	DB	02H
	DB	03eH
	DD	imagerel ?dtor$31@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$32@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z DB 028H
	DD	imagerel $stateUnwindMap$?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z
	DD	imagerel $ip2state$?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z DD 072719H
	DD	0640116H
	DD	07005e007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z
	DD	0312H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$18@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z DB 0eH
	DB	0f4H
	DB	02H
	DB	','
	DB	04H
	DB	01eH
	DB	06H
	DB	01eH
	DB	02H
	DB	0c1H, 02H
	DB	00H
	DB	'6'
	DB	02H
	DB	'j'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z DB 02H
	DB	013H
	DB	012H
	DD	imagerel ??_R0?AVout_of_range@std@@@8
	DD	imagerel ?catch$18@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA
	DB	'E', 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z DB 02H
	DB	00H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z DB 08H
	DB	08H
	DB	0aH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	060H
	DB	03aH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
	DB	060H
	DB	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z DB 038H
	DD	imagerel $stateUnwindMap$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z
	DD	imagerel $tryMap$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z
	DD	imagerel $ip2state$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z DD 051f19H
	DD	02e340dH
	DD	02a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z
	DD	0143H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?AddToClientList@ServerInterface@@QEAAHVClient@@@Z DB 0cH
	DB	0e4H
	DB	02H
	DB	'$'
	DB	04H
	DB	01cH
	DB	06H
	DB	'"'
	DB	08H
	DB	0c1H, 07H
	DB	00H
	DB	'Z'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?AddToClientList@ServerInterface@@QEAAHVClient@@@Z DB 08H
	DB	0cH
	DD	imagerel ??1Client@@QEAA@XZ
	DB	01H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	040H
	DB	06aH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
	DB	040H
	DB	09aH
	DD	imagerel ??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?AddToClientList@ServerInterface@@QEAAHVClient@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?AddToClientList@ServerInterface@@QEAAHVClient@@@Z
	DD	imagerel $ip2state$?AddToClientList@ServerInterface@@QEAAHVClient@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddToClientList@ServerInterface@@QEAAHVClient@@@Z DD 0b2a19H
	DD	036341cH
	DD	02c011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?AddToClientList@ServerInterface@@QEAAHVClient@@@Z
	DD	0152H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?IsClientAlive@ServerInterface@@QEAAHJ@Z DB 0aH
	DB	'H'
	DB	00H
	DB	'<'
	DB	02H
	DB	','
	DB	04H
	DB	0d0H
	DB	02H
	DB	0cdH, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?IsClientAlive@ServerInterface@@QEAAHJ@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1Client@@QEAA@XZ
	DB	081H
	DB	05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?IsClientAlive@ServerInterface@@QEAAHJ@Z DB 028H
	DD	imagerel $stateUnwindMap$?IsClientAlive@ServerInterface@@QEAAHJ@Z
	DD	imagerel $ip2state$?IsClientAlive@ServerInterface@@QEAAHJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsClientAlive@ServerInterface@@QEAAHJ@Z DD 051f19H
	DD	04c340dH
	DD	048010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?IsClientAlive@ServerInterface@@QEAAHJ@Z
	DD	0232H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DB 04H
	DB	'v'
	DB	02H
	DB	'.'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	imagerel $ip2state$?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DD 061a19H
	DD	0e007b20bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DB 04H
	DB	'v'
	DB	02H
	DB	'.'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	imagerel $ip2state$?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z DD 061a19H
	DD	0e007b20bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z DB 010H
	DB	0a2H
	DB	02H
	DB	'v'
	DB	04H
	DB	01eH
	DB	06H
	DB	'$'
	DB	08H
	DB	'@'
	DB	02H
	DB	'D'
	DB	0aH
	DB	'"'
	DB	02H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z DB 0aH
	DB	0cH
	DD	imagerel ??1ServerCommand@@QEAA@XZ
	DB	061H
	DB	07H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$6@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA
	DB	0baH
	DD	imagerel ??1NET_BLOB@@QEAA@XZ
	DB	081H
	DB	07H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z
	DD	imagerel $ip2state$?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z DD 072219H
	DD	0623410H
	DD	05e0110H
	DD	07007e009H
	DD	06006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z
	DD	02e2H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??IsCUIDInUse@ServerInterface@@QEAAHJ@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z DB 04H
	DB	01eH
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z DB 02H
	DB	013H
	DB	012H
	DD	imagerel ??_R0?AVout_of_range@std@@@8
	DD	imagerel ?catch$0@?0??IsCUIDInUse@ServerInterface@@QEAAHJ@Z@4HA
	DB	088H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z DB 038H
	DD	imagerel $stateUnwindMap$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z
	DD	imagerel $tryMap$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z
	DD	imagerel $ip2state$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?at@?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@2@AEBJ@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@1@AEBJ@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z DD 021H
	DD	imagerel $LN152
	DD	imagerel $LN152+145
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z DD 020521H
	DD	087405H
	DD	imagerel $LN152
	DD	imagerel $LN152+145
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$lock_guard@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z DD 020021H
	DD	0a6400H
	DD	imagerel $LN103
	DD	imagerel $LN103+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN103
	DD	imagerel $LN103+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z DD 020521H
	DD	0a6405H
	DD	imagerel $LN103
	DD	imagerel $LN103+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z DD 040901H
	DD	0e0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int_distribution@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z DD 084601H
	DD	077446H
	DD	066441H
	DD	08340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z DD 021H
	DD	imagerel $LN148
	DD	imagerel $LN148+145
	DD	imagerel $unwind$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z DD 020521H
	DD	087405H
	DD	imagerel $LN148
	DD	imagerel $LN148+145
	DD	imagerel $unwind$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z DB 06H
	DB	'@'
	DB	00H
	DB	01aH
	DB	02H
	DB	01aH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	080H
	DB	03cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z DB 028H
	DD	imagerel $stateUnwindMap$??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z
	DD	imagerel $ip2state$??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z DD 061411H
	DD	0a6414H
	DD	093414H
	DD	070105214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4V?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV01@$$QEAV01@@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Client@@QEAAAEAV0@$$QEAV0@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4ClientResponse@@QEAAAEAU0@$$QEAU0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DB 0eH
	DB	08aH
	DB	02H
	DB	'n'
	DB	04H
	DB	01cH
	DB	06H
	DB	'@'
	DB	08H
	DB	'*'
	DB	0cH
	DB	'v'
	DB	0aH
	DB	'Y', 07H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DB 0cH
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0f0H
	DB	032H
	DD	imagerel ??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
	DB	041H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	06cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DB 028H
	DD	imagerel $stateUnwindMap$??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
	DD	imagerel $ip2state$??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DD 082919H
	DD	03f0118H
	DD	0e007f009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
	DD	01e2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DB 0eH
	DB	092H
	DB	02H
	DB	'|'
	DB	04H
	DB	01cH
	DB	06H
	DB	'@'
	DB	08H
	DB	'*'
	DB	0cH
	DB	'Z'
	DB	0aH
	DB	')', 07H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DB 0cH
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0f0H
	DB	032H
	DD	imagerel ??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
	DB	041H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	06cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DB 028H
	DD	imagerel $stateUnwindMap$??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
	DD	imagerel $ip2state$??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z DD 0a2d19H
	DD	03f011cH
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
	DD	01e2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z DB 06H
	DB	0c5H, 03H
	DB	02H
	DB	0adH, 03H
	DB	04H
	DB	'!', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z
	DD	imagerel $ip2state$??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z DD 0a1411H
	DD	0113414H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 020021H
	DD	047400H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 021H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 020021H
	DD	047400H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 021H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 020521H
	DD	047405H
	DD	imagerel $LN104
	DD	imagerel $LN104+46
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 051301H
	DD	0f00f4213H
	DD	0600be00dH
	DD	0300aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+25
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 040a21H
	DD	08740aH
	DD	063405H
	DD	imagerel $LN88
	DD	imagerel $LN88+25
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN291
	DD	imagerel $LN291+47
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 060021H
	DD	04e400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN291
	DD	imagerel $LN291+47
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN291+47
	DD	imagerel $LN291+120
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 020521H
	DD	0b5405H
	DD	imagerel $LN291+47
	DD	imagerel $LN291+120
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 041821H
	DD	04e418H
	DD	0a3405H
	DD	imagerel $LN291
	DD	imagerel $LN291+47
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN118
	DD	imagerel $LN118+71
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN118+71
	DD	imagerel $LN118+95
	DD	imagerel $chain$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 040a21H
	DD	0a740aH
	DD	093405H
	DD	imagerel $LN118+71
	DD	imagerel $LN118+95
	DD	imagerel $chain$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020521H
	DD	0be405H
	DD	imagerel $LN118
	DD	imagerel $LN118+71
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN112
	DD	imagerel $LN112+62
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN112+62
	DD	imagerel $LN112+86
	DD	imagerel $chain$0$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 040a21H
	DD	0a740aH
	DD	093405H
	DD	imagerel $LN112+62
	DD	imagerel $LN112+86
	DD	imagerel $chain$0$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020521H
	DD	0be405H
	DD	imagerel $LN112
	DD	imagerel $LN112+62
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a0021H
	DD	0ac400H
	DD	0b7400H
	DD	0136400H
	DD	0125400H
	DD	0113400H
	DD	imagerel $LN275
	DD	imagerel $LN275+45
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021H
	DD	imagerel $LN275
	DD	imagerel $LN275+45
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a1721H
	DD	0ac417H
	DD	0b7413H
	DD	013640fH
	DD	012540bH
	DD	0113404H
	DD	imagerel $LN275
	DD	imagerel $LN275+45
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 040d01H
	DD	0f009b20dH
	DD	0d005e007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN92
	DD	imagerel $LN92+36
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ DD 040a21H
	DD	08740aH
	DD	073405H
	DD	imagerel $LN92
	DD	imagerel $LN92+36
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ DD 040b01H
	DD	09640bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z DD 084601H
	DD	077446H
	DD	066441H
	DD	08340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DB 06H
	DB	'@'
	DB	00H
	DB	01aH
	DB	02H
	DB	01aH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	060H
	DB	03cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
	DD	imagerel $ip2state$??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DD 061411H
	DD	086414H
	DD	073414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 06H
	DB	'z'
	DB	04H
	DB	'f'
	DB	02H
	DB	'A', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	imagerel $ip2state$??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 061b19H
	DD	015340cH
	DD	07008d20cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 06H
	DB	'z'
	DB	04H
	DB	'T'
	DB	02H
	DB	'A', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
	DB	034H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	imagerel $ip2state$??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 061a19H
	DD	0e007d20bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	'F'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@AEBAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@JJ@Z DD 084601H
	DD	077446H
	DD	066441H
	DD	08340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z DB 06H
	DB	'D'
	DB	00H
	DB	01aH
	DB	02H
	DB	01aH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	060H
	DB	03cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z
	DD	imagerel $ip2state$??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z DD 061411H
	DD	086414H
	DD	073414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAXQEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAKK@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_random_product@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KKI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+116
	DD	imagerel $unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD 020421H
	DD	03404H
	DD	imagerel $LN37
	DD	imagerel $LN37+116
	DD	imagerel $unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DB 04H
	DB	'0'
	DB	00H
	DB	01aH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
	DD	imagerel $ip2state$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAVClient@@@?$_Tuple_val@VClient@@@std@@QEAA@AEAVClient@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBJ@0@$$QEAV?$tuple@$$V@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBJ$$Z$$V@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$V$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$tuple@AEBJ@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@AEAV?$tuple@AEBJ@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$tuple@$$V@std@@QEAA@AEBV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT

; 226  :     constexpr tuple(const tuple&) noexcept /* strengthened */ {} // TRANSITION, ABI: should be defaulted

	mov	rax, rcx
	ret	0
??0?$tuple@$$V@std@@QEAA@AEBV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_types.h
;	COMDAT ??0Server@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Server@@QEAA@XZ PROC					; Server::Server, COMDAT

; 45   :     {

	xorps	xmm0, xmm0

; 43   :         : sfd(INVALID_SOCKET), domain(AF_INET),

	mov	DWORD PTR [rcx], -1

; 44   :         type(-1), protocol(-1), port(-1), addr({0}), alive(FALSE)

	movups	XMMWORD PTR [rcx+20], xmm0
	mov	DWORD PTR [rcx+4], 2

; 46   :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], -1
	mov	DWORD PTR [rcx+16], -1
	mov	DWORD PTR [rcx+36], 0
	ret	0
??0Server@@QEAA@XZ ENDP					; Server::Server
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
_TEXT	SEGMENT
$T1 = 40
key$GSCopy$ = 72
byteKey$ = 80
aes$ = 112
__$ArrayPad$ = 352
string$ = 384
key$ = 392
?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; NetCommon::DecryptByteString, COMDAT

; 80   :     inline void DecryptByteString(BYTESTRING& string, std::string key) {

$LN94:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 368				; 00000170H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR key$GSCopy$[rsp], rdx
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR byteKey$[rsp], xmm0
	mov	QWORD PTR byteKey$[rsp+16], rax

; 81   :         BYTESTRING byteKey = NetCommon::SerializeString(key);

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR byteKey$[rsp]
	call	?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::SerializeString
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 608  :         Aes(unsigned char key[key_bits]) : round_keys() {

	xor	edx, edx
	mov	r8d, 240				; 000000f0H
	lea	rcx, QWORD PTR aes$[rsp]
	call	memset

; 609  :             constexpr bool invalid_aes_key_bit_size = key_bits == 128 || key_bits == 192 || key_bits == 256;
; 610  :             static_assert( invalid_aes_key_bit_size, "The valid values are only: 128, 192 & 256" );
; 611  : 
; 612  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 613  :             if constexpr ( key_bits == 128 ) {
; 614  :                 AES_128_Key_Expansion(key, round_keys);
; 615  :             }
; 616  :             else if constexpr ( key_bits == 192 ) {
; 617  :                 AES_192_Key_Expansion(key, round_keys);
; 618  :             }
; 619  :             else if constexpr ( key_bits == 256 ) {
; 620  :                 AES_256_Key_Expansion(key, round_keys);

	lea	r8, QWORD PTR aes$[rsp]
	mov	rdx, QWORD PTR byteKey$[rsp]
	call	?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ; Cipher::Aes<256>::AES_256_Key_Expansion
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 83   :         aes.decrypt_block(string.data());

	mov	rdx, QWORD PTR [rbx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 778  :             state = _mm_xor_si128(state, xmm_round_keys[Nr]);

	movdqu	xmm5, XMMWORD PTR [rdx]
	xorps	xmm5, XMMWORD PTR aes$[rsp+224]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 80   :     inline void DecryptByteString(BYTESTRING& string, std::string key) {

	lea	rax, QWORD PTR aes$[rsp+208]
	mov	ecx, 6
	npad	3
$LL15@DecryptByt:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 782  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i]));

	aesimc	xmm0, XMMWORD PTR [rax]

; 783  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i - 1]));

	aesimc	xmm1, XMMWORD PTR [rax-16]

; 782  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i]));

	aesdec	xmm5, xmm0

; 783  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i - 1]));

	aesdec	xmm5, xmm1

; 779  : 
; 780  :             // usual rounds
; 781  :             for ( size_t i = Nr - 1; i > 1; i -= 2 ) {

	lea	rax, QWORD PTR [rax-32]
	sub	rcx, 1
	jne	SHORT $LL15@DecryptByt

; 784  :             }
; 785  : 
; 786  :             // last round
; 787  :             state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[1]));

	aesimc	xmm0, XMMWORD PTR aes$[rsp+16]
	aesdec	xmm5, xmm0

; 788  :             state = _mm_aesdeclast_si128(state, xmm_round_keys[0]);

	aesdeclast xmm5, XMMWORD PTR aes$[rsp]

; 789  : 
; 790  :             // store from register to array
; 791  :             _mm_storeu_si128(( __m128i* ) block, state);

	movdqu	XMMWORD PTR [rdx], xmm5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	xor	ebx, ebx
	mov	rcx, QWORD PTR byteKey$[rsp]
	test	rcx, rcx
	je	SHORT $LN24@DecryptByt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR byteKey$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN43@DecryptByt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN92@DecryptByt
$LN43@DecryptByt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR byteKey$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR byteKey$[rsp+16], rbx
$LN24@DecryptByt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN66@DecryptByt

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN80@DecryptByt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN77@DecryptByt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN80@DecryptByt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN66@DecryptByt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbx

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 84   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+400]
	add	rsp, 368				; 00000170H
	pop	rdi
	ret	0
$LN92@DecryptByt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN77@DecryptByt:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN90@DecryptByt:
?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; NetCommon::DecryptByteString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
key$GSCopy$ = 72
byteKey$ = 80
aes$ = 112
__$ArrayPad$ = 352
string$ = 384
key$ = 392
?dtor$0@?0??DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptByteString'::`1'::dtor$0
	mov	rcx, QWORD PTR key$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptByteString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_types.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 48
$T1 = 64
request$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnUdt$ = 144
request$ = 152
aesKey$ = 160
?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; NetCommon::RequestToBlob, COMDAT

; 115  :     inline NET_BLOB RequestToBlob(ServerRequest request, std::string aesKey) {

$LN82:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbp, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR request$GSCopy$[rsp], rdx
	mov	QWORD PTR aesKey$GSCopy$[rsp], r8
	xor	r14d, r14d
	xorps	xmm0, xmm0

; 116  :         return NET_BLOB{ {0}, request, {}, aesKey };

	movups	XMMWORD PTR [rcx], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+16], xmm1

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+32], r14

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+40], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+16], r14b
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 116  :         return NET_BLOB{ {0}, request, {}, aesKey };

	lea	rbx, QWORD PTR [rcx+48]
	mov	QWORD PTR $T1[rsp], rbx
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rbx], al
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rbx+12], eax
	mov	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rbx+16], eax
	lea	rcx, QWORD PTR [rbx+24]
	add	rdx, 24
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+56]
	lea	rdx, QWORD PTR [rdi+56]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+88]
	lea	rdx, QWORD PTR [rdi+88]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rdi+120]
	mov	DWORD PTR [rbx+120], eax
	xor	eax, eax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_types.h

; 44   :         type(-1), protocol(-1), port(-1), addr({0}), alive(FALSE)

	mov	QWORD PTR [rbp+212], rax

; 43   :         : sfd(INVALID_SOCKET), domain(AF_INET),

	mov	DWORD PTR [rbp+176], -1
	mov	DWORD PTR [rbp+180], 2

; 44   :         type(-1), protocol(-1), port(-1), addr({0}), alive(FALSE)

	mov	QWORD PTR [rbp+184], -1
	mov	DWORD PTR [rbp+192], -1
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rbp+196], xmm0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 116  :         return NET_BLOB{ {0}, request, {}, aesKey };

	lea	rcx, QWORD PTR [rbp+220]
	mov	rdx, rsi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, rdi
	call	??1ServerCommand@@QEAA@XZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rsi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN58@RequestToB

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rsi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN72@RequestToB

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN69@RequestToB

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN72@RequestToB:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN58@RequestToB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+16], r14

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rsi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 116  :         return NET_BLOB{ {0}, request, {}, aesKey };

	mov	rax, rbp

; 117  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN69@RequestToB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN79@RequestToB:
?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; NetCommon::RequestToBlob
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
$T1 = 64
request$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnUdt$ = 144
request$ = 152
aesKey$ = 160
?dtor$0@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$0
	mov	rcx, QWORD PTR aesKey$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
$T1 = 64
request$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnUdt$ = 144
request$ = 152
aesKey$ = 160
?dtor$1@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$1
	mov	rcx, QWORD PTR request$GSCopy$[rdx]
	jmp	??1ServerCommand@@QEAA@XZ
?dtor$1@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
$T1 = 64
request$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnUdt$ = 144
request$ = 152
aesKey$ = 160
?dtor$3@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$3
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$3@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
$T1 = 64
request$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnUdt$ = 144
request$ = 152
aesKey$ = 160
?dtor$10@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$10
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1ProcessInformation@@QEAA@XZ
?dtor$10@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
$T1 = 64
request$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnUdt$ = 144
request$ = 152
aesKey$ = 160
?dtor$11@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$11
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 48
$T1 = 64
request$GSCopy$ = 72
aesKey$GSCopy$ = 80
__$ArrayPad$ = 88
__$ReturnUdt$ = 144
request$ = 152
aesKey$ = 160
?dtor$4@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `NetCommon::RequestToBlob'::`1'::dtor$4
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1ServerCommand@@QEAA@XZ
?dtor$4@?0??RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `NetCommon::RequestToBlob'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h
;	COMDAT ?GenerateCUID@Client@@QEAAJXZ
_TEXT	SEGMENT
generator$ = 32
__$ArrayPad$ = 5040
this$dead$ = 5072
?GenerateCUID@Client@@QEAAJXZ PROC			; Client::GenerateCUID, COMDAT

; 44   :     inline long   GenerateCUID() {

$LN105:
	mov	eax, 5064				; 000013c8H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random

; 1172 :         _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;

	mov	edx, 5489				; 00001571H

; 1161 :         : _Dxval(_Dxarg) {

	mov	DWORD PTR generator$[rsp+4996], -1	; ffffffffH

; 1172 :         _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;

	mov	DWORD PTR generator$[rsp+4], edx

; 1161 :         : _Dxval(_Dxarg) {

	mov	ecx, 1
	npad	8
$LL90@GenerateCU:

; 1174 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	eax, edx
	shr	eax, 30
	xor	eax, edx
	imul	edx, eax, 1812433253			; 6c078965H
	add	edx, ecx
	mov	DWORD PTR generator$[rsp+rcx*4+4], edx
	inc	rcx
	cmp	rcx, 624				; 00000270H
	jb	SHORT $LL90@GenerateCU

; 1417 :         return _Mybase::operator()();

	lea	rcx, QWORD PTR generator$[rsp]

; 1177 :         this->_Idx = _Nx;

	mov	DWORD PTR generator$[rsp], 624		; 00000270H

; 1417 :         return _Mybase::operator()();

	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	ecx, eax
	imul	rax, rcx, 10400				; 000028a0H

; 1999 :         if (_Rem < _Index) {

	cmp	eax, 6495				; 0000195fH
	ja	SHORT $LN53@GenerateCU
$LL52@GenerateCU:

; 1417 :         return _Mybase::operator()();

	lea	rcx, QWORD PTR generator$[rsp]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	ecx, eax
	imul	rax, rcx, 10400				; 000028a0H

; 2002 :             while (_Rem < _Threshold) {

	cmp	eax, 6496				; 00001960H
	jb	SHORT $LL52@GenerateCU
$LN53@GenerateCU:

; 2003 :                 _Product = _Get_random_product(_Index, _Niter);
; 2004 :                 _Rem     = static_cast<_Udiff>(_Product) & _Mask;
; 2005 :             }
; 2006 :         }
; 2007 : 
; 2008 :         unsigned int _Generated_bits;
; 2009 :         if constexpr (_Bits < _Udiff_bits) {
; 2010 :             _Generated_bits = static_cast<unsigned int>(_Popcount(_Mask));
; 2011 :         } else {
; 2012 :             _Generated_bits = _Udiff_bits;
; 2013 :         }
; 2014 : 
; 2015 :         // m / 2^L
; 2016 :         return static_cast<_Diff>(_Product >> _Generated_bits);

	shr	rax, 32					; 00000020H

; 2209 :         return static_cast<_Ty>(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	add	eax, -2147483647			; ffffffff80000001H

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	xor	eax, -2147483648			; ffffffff80000000H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h

; 48   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 5064				; 000013c8H
	ret	0
?GenerateCUID@Client@@QEAAJXZ ENDP			; Client::GenerateCUID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\client.h
;	COMDAT ?SetClientID@Client@@QEAAXJ@Z
_TEXT	SEGMENT
this$ = 8
cuid$ = 16
?SetClientID@Client@@QEAAXJ@Z PROC			; Client::SetClientID, COMDAT

; 55   :         this->ClientUID = cuid;

	mov	DWORD PTR [rcx+196], edx

; 56   :     }

	ret	0
?SetClientID@Client@@QEAAXJ@Z ENDP			; Client::SetClientID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
;	COMDAT ?lock@_Mutex_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?lock@_Mutex_base@std@@QEAAXXZ PROC			; std::_Mutex_base::lock, COMDAT

; 51   :     void lock() {

$LN17:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	call	_Mtx_lock
	test	eax, eax
	jne	SHORT $LN14@lock

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	cmp	DWORD PTR [rbx+76], 2147483647		; 7fffffffH
	je	SHORT $LN15@lock

; 62   :         }
; 63   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@lock:

; 55   :         }
; 56   : 
; 57   :         if (!_Verify_ownership_levels()) {
; 58   :             // only occurs for recursive mutexes (N4950 [thread.mutex.recursive]/3)
; 59   :             // POSIX specifies EAGAIN in the corresponding situation:
; 60   :             // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html
; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	ecx, 6

; 80   :             --_Mtx_storage._Count;

	mov	DWORD PTR [rbx+76], 2147483646		; 7ffffffeH

; 55   :         }
; 56   : 
; 57   :         if (!_Verify_ownership_levels()) {
; 58   :             // only occurs for recursive mutexes (N4950 [thread.mutex.recursive]/3)
; 59   :             // POSIX specifies EAGAIN in the corresponding situation:
; 60   :             // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html
; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN14@lock:

; 53   :             // undefined behavior, only occurs for plain mutexes (N4950 [thread.mutex.requirements.mutex.general]/6)
; 54   :             _STD _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN12@lock:
?lock@_Mutex_base@std@@QEAAXXZ ENDP			; std::_Mutex_base::lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
;	COMDAT ?unlock@_Mutex_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?unlock@_Mutex_base@std@@QEAAXXZ PROC			; std::_Mutex_base::unlock, COMDAT

; 71   :         _Mtx_unlock(_Mymtx());

	jmp	_Mtx_unlock
?unlock@_Mutex_base@std@@QEAAXXZ ENDP			; std::_Mutex_base::unlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
;	COMDAT ?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ PROC ; std::_Mutex_base::_Verify_ownership_levels, COMDAT

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	cmp	DWORD PTR [rcx+76], 2147483647		; 7fffffffH
	jne	SHORT $LN2@Verify_own

; 79   :             // only occurs for recursive mutexes (N4950 [thread.mutex.recursive]/3)
; 80   :             --_Mtx_storage._Count;

	mov	DWORD PTR [rcx+76], 2147483646		; 7ffffffeH

; 81   :             return false;

	xor	al, al

; 85   :     }

	ret	0
$LN2@Verify_own:

; 82   :         }
; 83   : 
; 84   :         return true;

	mov	al, 1

; 85   :     }

	ret	0
?_Verify_ownership_levels@_Mutex_base@std@@IEAA_NXZ ENDP ; std::_Mutex_base::_Verify_ownership_levels
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
;	COMDAT ?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ PROC ; std::_Mutex_base::_Mymtx, COMDAT

; 94   :         return &_Mtx_storage;

	mov	rax, rcx

; 95   :     }

	ret	0
?_Mymtx@_Mutex_base@std@@AEAAPEAU_Mtx_internal_imp_t@@XZ ENDP ; std::_Mutex_base::_Mymtx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
;	COMDAT ?RemoveClientFromClientList@ServerInterface@@QEAAHJ@Z
_TEXT	SEGMENT
this$ = 80
cuid$ = 88
?RemoveClientFromClientList@ServerInterface@@QEAAHJ@Z PROC ; ServerInterface::RemoveClientFromClientList, COMDAT

; 146  : 	inline BOOL    RemoveClientFromClientList(long cuid) {

$LN182:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	mov	edi, edx
	mov	ebp, edx
	mov	r14d, edx
	mov	r15d, edx
	shr	ebp, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	add	rcx, 64					; 00000040H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h

; 146  : 	inline BOOL    RemoveClientFromClientList(long cuid) {

	shr	r14d, 16
	shr	r15d, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	call	_Mtx_lock
	test	eax, eax
	jne	$LN179@RemoveClie

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	mov	eax, DWORD PTR [rsi+140]
	cmp	eax, 2147483647				; 7fffffffH
	je	$LN180@RemoveClie

; 71   :         _Mtx_unlock(_Mymtx());

	lea	rcx, QWORD PTR [rsi+64]
	call	_Mtx_unlock
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r8, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	movzx	edx, dil
	xor	rdx, rax
	movzx	eax, r15b
	imul	rdx, rcx
	xor	rdx, rax
	movzx	eax, r14b
	imul	rdx, rcx
	xor	rdx, rax
	mov	eax, ebp
	imul	rdx, rcx
	xor	rdx, rax
	imul	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1567 :         if (_Where == _End) {

	xor	ecx, ecx
	and	rdx, QWORD PTR [rsi+48]
	shl	rdx, 4
	add	rdx, QWORD PTR [rsi+24]
	mov	r9, QWORD PTR [rdx+8]
	mov	rbx, r9
	cmp	r9, r8
	je	SHORT $LN157@RemoveClie

; 1568 :             return {_End, _Nodeptr{}};
; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	edi, DWORD PTR [r9+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN156@RemoveClie
$LL54@RemoveClie:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};
; 1582 :             }
; 1583 : 
; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rax
	je	SHORT $LN157@RemoveClie

; 1585 :                 return {_Where, _Nodeptr{}};
; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	edi, DWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL54@RemoveClie
	jmp	SHORT $LN156@RemoveClie
$LN157@RemoveClie:

; 1109 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	rbx, rcx
$LN156@RemoveClie:
	test	rbx, rbx

; 1110 :             if (_Target) {

	je	SHORT $LN29@RemoveClie

; 1665 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rdx]
	cmp	r9, rbx
	jne	SHORT $LN68@RemoveClie

; 1666 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rbx
	jne	SHORT $LN70@RemoveClie

; 1667 :                 const auto _End = _List._Mypair._Myval2._Myhead;
; 1668 : 
; 1669 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rdx], r8

; 1673 :             }

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN72@RemoveClie
$LN70@RemoveClie:

; 1670 :                 _Bucket_hi = _End;
; 1671 :             } else {
; 1672 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	r8, QWORD PTR [rbx+8]

; 1673 :             }

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN72@RemoveClie
$LN68@RemoveClie:

; 1674 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rbx
	jne	SHORT $LN72@RemoveClie

; 1675 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdx], rax
$LN72@RemoveClie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1423 :         const auto _Result = _Pnode->_Next;

	mov	rcx, QWORD PTR [rbx]

; 1424 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1425 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR [rsi+16]

; 1426 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax], rcx

; 1427 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rcx+8], rax
	lea	rcx, QWORD PTR [rbx+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rbx+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1113 :                 return 1;

	mov	ecx, 1
$LN29@RemoveClie:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h

; 148  : 	}

	mov	rbx, QWORD PTR [rsp+96]
	mov	eax, ecx
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN180@RemoveClie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 80   :             --_Mtx_storage._Count;

	dec	eax

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	ecx, 6

; 80   :             --_Mtx_storage._Count;

	mov	DWORD PTR [rsi+140], eax

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN179@RemoveClie:

; 53   :             // undefined behavior, only occurs for plain mutexes (N4950 [thread.mutex.requirements.mutex.general]/6)
; 54   :             _STD _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN177@RemoveClie:
?RemoveClientFromClientList@ServerInterface@@QEAAHJ@Z ENDP ; ServerInterface::RemoveClientFromClientList
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
;	COMDAT ?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
cuid$ = 96
?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z PROC ; ServerInterface::GetClientData, COMDAT

; 154  : 	inline const ClientData GetClientData(long cuid) {

$LN65:
	mov	QWORD PTR [rsp+8], rbx
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rdx
	mov	rbp, rcx

; 155  : 		if ( !ClientIsInClientList(cuid) )

	mov	edx, r8d
	call	?ClientIsInClientList@ServerInterface@@QEAAHJ@Z ; ServerInterface::ClientIsInClientList
	test	eax, eax
	jne	SHORT $LN2@GetClientD

; 156  : 			return {};

	mov	rcx, rsi
	call	??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>

; 160  : 	}

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN2@GetClientD:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	lea	rcx, QWORD PTR [rbp+64]
	call	_Mtx_lock
	test	eax, eax
	jne	$LN58@GetClientD

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	cmp	DWORD PTR [rbp+140], 2147483647		; 7fffffffH
	jne	SHORT $LN8@GetClientD

; 80   :             --_Mtx_storage._Count;

	mov	eax, 2147483646				; 7ffffffeH

; 81   :             return false;

	jmp	SHORT $LN57@GetClientD
$LN8@GetClientD:

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	lea	rcx, QWORD PTR [rbp+64]
	call	_Mtx_lock
	test	eax, eax
	jne	SHORT $LN58@GetClientD

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	mov	eax, DWORD PTR [rbp+140]
	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN63@GetClientD

; 71   :         _Mtx_unlock(_Mymtx());

	lea	rcx, QWORD PTR [rbp+64]
	call	_Mtx_unlock
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h

; 159  : 		return GetClientList().at(cuid);

	lea	rdx, QWORD PTR cuid$[rsp]
	mov	rcx, rbp
	call	?at@?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@2@AEBJ@Z ; std::unordered_map<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::hash<long>,std::equal_to<long>,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::at
	mov	rbx, rax
	mov	rdx, rax
	mov	rcx, rsi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 361  :     tuple(const tuple&) = default;

	lea	rcx, QWORD PTR [rsi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rsi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h

; 160  : 	}

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN63@GetClientD:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 80   :             --_Mtx_storage._Count;

	dec	eax
$LN57@GetClientD:

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	DWORD PTR [rbp+140], eax
	mov	ecx, 6
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN58@GetClientD:

; 53   :             // undefined behavior, only occurs for plain mutexes (N4950 [thread.mutex.requirements.mutex.general]/6)
; 54   :             _STD _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN60@GetClientD:
?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z ENDP ; ServerInterface::GetClientData
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
cuid$ = 96
?dtor$4@?0??GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z@4HA PROC ; `ServerInterface::GetClientData'::`1'::dtor$4
	mov	rcx, QWORD PTR __$ReturnUdt$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$4@?0??GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z@4HA ENDP ; `ServerInterface::GetClientData'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
cuid$ = 96
?dtor$2@?0??GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z@4HA PROC ; `ServerInterface::GetClientData'::`1'::dtor$2
	mov	rcx, QWORD PTR __$ReturnUdt$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
?dtor$2@?0??GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z@4HA ENDP ; `ServerInterface::GetClientData'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0Client@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Client@@QEAA@XZ PROC					; Client::Client, COMDAT

; 2651 :         _My_data._Mysize = 0;

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+36], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+52], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+60], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+36], al
	mov	DWORD PTR [rcx+68], -1

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+76], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+92], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+100], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+76], al
	mov	DWORD PTR [rcx+108], -1
	mov	QWORD PTR [rcx+116], -1
	mov	QWORD PTR [rcx+124], -1

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+132], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+148], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+156], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+132], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+164], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+180], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+188], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+164], al
	mov	rax, rcx
	mov	DWORD PTR [rcx+196], -1
	ret	0
??0Client@@QEAA@XZ ENDP					; Client::Client
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0ClientResponse@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ClientResponse@@QEAA@XZ PROC				; ClientResponse::ClientResponse, COMDAT
	xorps	xmm0, xmm0
	mov	rax, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0
	mov	DWORD PTR [rcx+32], -1
	ret	0
??0ClientResponse@@QEAA@XZ ENDP				; ClientResponse::ClientResponse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h
;	COMDAT ?GetClientList@ServerInterface@@QEAAAEAV?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@XZ
_TEXT	SEGMENT
this$ = 48
?GetClientList@ServerInterface@@QEAAAEAV?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@XZ PROC ; ServerInterface::GetClientList, COMDAT

; 162  : 	inline std::unordered_map<long, ClientData>& GetClientList() {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	add	rcx, 64					; 00000040H
	call	_Mtx_lock
	test	eax, eax
	jne	SHORT $LN27@GetClientL

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	mov	eax, DWORD PTR [rdi+140]
	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN28@GetClientL

; 71   :         _Mtx_unlock(_Mymtx());

	lea	rcx, QWORD PTR [rdi+64]
	call	_Mtx_unlock
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\server.h

; 165  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@GetClientL:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 80   :             --_Mtx_storage._Count;

	dec	eax

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	ecx, 6

; 80   :             --_Mtx_storage._Count;

	mov	DWORD PTR [rdi+140], eax

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN27@GetClientL:

; 53   :             // undefined behavior, only occurs for plain mutexes (N4950 [thread.mutex.requirements.mutex.general]/6)
; 54   :             _STD _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN25@GetClientL:
?GetClientList@ServerInterface@@QEAAAEAV?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@XZ ENDP ; ServerInterface::GetClientList
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1ClientResponse@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ClientResponse@@QEAA@XZ PROC				; ClientResponse::~ClientResponse, COMDAT
$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@ClientResp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@ClientResp

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN32@ClientResp

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@ClientResp:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@ClientResp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN32@ClientResp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN45@ClientResp:
??1ClientResponse@@QEAA@XZ ENDP				; ClientResponse::~ClientResponse
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ PROC ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 64					; 00000040H
	call	??1Client@@QEAA@XZ
	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ENDP ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
$LN106:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+56]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN26@tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@tuple

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN86@tuple

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN40@tuple:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@tuple:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+48], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+56], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+32], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN75@tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN89@tuple

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN86@tuple

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN89@tuple:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN75@tuple:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN86@tuple:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN103@tuple:
??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
$LN54:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN26@tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@tuple

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN37@tuple

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN40@tuple:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@tuple:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN37@tuple:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN51@tuple:
??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@Tuple_val
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@Tuple_val

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN32@Tuple_val

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@Tuple_val:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@Tuple_val:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN32@Tuple_val:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN45@Tuple_val:
??1?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tuple_val@VClient@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tuple_val@VClient@@@std@@QEAA@XZ PROC		; std::_Tuple_val<Client>::~_Tuple_val<Client>, COMDAT
	jmp	??1Client@@QEAA@XZ
??1?$_Tuple_val@VClient@@@std@@QEAA@XZ ENDP		; std::_Tuple_val<Client>::~_Tuple_val<Client>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1Client@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Client@@QEAA@XZ PROC					; Client::~Client, COMDAT
$LN220:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+188]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@Client
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+164]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@Client

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN193@Client

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@Client:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	xor	edi, edi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+188], 15
	mov	QWORD PTR [rbx+180], rdi

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+164], dil

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+156]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN59@Client
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+132]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN73@Client

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN193@Client

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN73@Client:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN59@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+148], rdi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+156], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+132], dil

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+100]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN101@Client
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+76]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN115@Client

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN193@Client

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN115@Client:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN101@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+92], rdi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+100], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+76], dil

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+60]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN144@Client
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN158@Client

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN193@Client

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN158@Client:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN144@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+52], rdi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+60], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+36], dil

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN182@Client
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN196@Client

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN193@Client

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN196@Client:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN182@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rdi

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], dil
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN193@Client:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN217@Client:
??1Client@@QEAA@XZ ENDP					; Client::~Client
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z PROC ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 361  :     tuple(const tuple&) = default;

$LN23:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z ENDP ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$2@?0???0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$2@?0???0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
?dtor$0@?0???0?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 361  :     tuple(const tuple&) = default;

$LN16:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$0@?0???0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 361  :     tuple(const tuple&) = default;

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBU01@@Z PROC ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBU01@@Z ENDP ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tuple_val@VClient@@@std@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$_Tuple_val@VClient@@@std@@QEAA@AEBU01@@Z PROC	; std::_Tuple_val<Client>::_Tuple_val<Client>, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??0Client@@QEAA@AEBV0@@Z
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$_Tuple_val@VClient@@@std@@QEAA@AEBU01@@Z ENDP	; std::_Tuple_val<Client>::_Tuple_val<Client>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0Client@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0Client@@QEAA@AEBV0@@Z PROC				; Client::Client, COMDAT
$LN16:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbp, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR [rsi+32]
	mov	DWORD PTR [rbp+32], eax
	lea	rdx, QWORD PTR [rsi+36]
	lea	rcx, QWORD PTR [rbp+36]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rsi+68]
	mov	DWORD PTR [rbp+68], eax
	mov	eax, DWORD PTR [rsi+72]
	mov	DWORD PTR [rbp+72], eax
	lea	rdx, QWORD PTR [rsi+76]
	lea	rcx, QWORD PTR [rbp+76]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rsi+108]
	mov	DWORD PTR [rbp+108], eax
	mov	eax, DWORD PTR [rsi+112]
	mov	DWORD PTR [rbp+112], eax
	mov	rax, QWORD PTR [rsi+116]
	mov	QWORD PTR [rbp+116], rax
	mov	rax, QWORD PTR [rsi+124]
	mov	QWORD PTR [rbp+124], rax
	lea	rcx, QWORD PTR [rbp+132]
	lea	rdx, QWORD PTR [rsi+132]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbp+164]
	lea	rdx, QWORD PTR [rsi+164]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rsi+196]
	mov	DWORD PTR [rbp+196], eax
	mov	rax, rbp
	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0Client@@QEAA@AEBV0@@Z ENDP				; Client::Client
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0Client@@QEAA@AEBV0@@Z@4HA PROC		; `Client::Client'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0Client@@QEAA@AEBV0@@Z@4HA ENDP		; `Client::Client'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$1@?0???0Client@@QEAA@AEBV0@@Z@4HA PROC		; `Client::Client'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 36					; 00000024H
	jmp	??1ClientResponse@@QEAA@XZ
?dtor$1@?0???0Client@@QEAA@AEBV0@@Z@4HA ENDP		; `Client::Client'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$2@?0???0Client@@QEAA@AEBV0@@Z@4HA PROC		; `Client::Client'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 76					; 0000004cH
	jmp	??1ClientResponse@@QEAA@XZ
?dtor$2@?0???0Client@@QEAA@AEBV0@@Z@4HA ENDP		; `Client::Client'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$3@?0???0Client@@QEAA@AEBV0@@Z@4HA PROC		; `Client::Client'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 132				; 00000084H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???0Client@@QEAA@AEBV0@@Z@4HA ENDP		; `Client::Client'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ClientResponse@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ClientResponse@@QEAA@AEBU0@@Z PROC			; ClientResponse::ClientResponse, COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR [rdi+32], eax
	mov	eax, DWORD PTR [rbx+36]
	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi+36], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0ClientResponse@@QEAA@AEBU0@@Z ENDP			; ClientResponse::ClientResponse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_types.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_types.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?NewServerInstance@ServerInterface@@QEAA?AUServer@@W4SocketTypes@@H@Z
_TEXT	SEGMENT
this$dead$ = 48
__$ReturnUdt$ = 56
serverType$dead$ = 64
port$dead$ = 72
?NewServerInstance@ServerInterface@@QEAA?AUServer@@W4SocketTypes@@H@Z PROC ; ServerInterface::NewServerInstance, COMDAT

; 4    : Server ServerInterface::NewServerInstance(SocketTypes serverType, int port) {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 7    : 	if ( !NetCommon::WSAInitialized )

	cmp	DWORD PTR ?WSAInitialized@NetCommon@@3HA, 0 ; NetCommon::WSAInitialized
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_types.h

; 43   :         : sfd(INVALID_SOCKET), domain(AF_INET),

	mov	edi, 2
	xorps	xmm0, xmm0
	mov	DWORD PTR [rdx+4], edi

; 44   :         type(-1), protocol(-1), port(-1), addr({0}), alive(FALSE)

	movups	XMMWORD PTR [rdx+20], xmm0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 4    : Server ServerInterface::NewServerInstance(SocketTypes serverType, int port) {

	mov	rbx, rdx
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_types.h

; 43   :         : sfd(INVALID_SOCKET), domain(AF_INET),

	mov	DWORD PTR [rdx], -1

; 44   :         type(-1), protocol(-1), port(-1), addr({0}), alive(FALSE)

	mov	QWORD PTR [rdx+8], -1
	mov	DWORD PTR [rdx+16], -1
	mov	DWORD PTR [rdx+36], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 7    : 	if ( !NetCommon::WSAInitialized )

	jne	SHORT $LN2@NewServerI

; 8    : 		NetCommon::LoadWSAFunctions();

	call	?LoadWSAFunctions@NetCommon@@YAXXZ	; NetCommon::LoadWSAFunctions
$LN2@NewServerI:

; 9    : 
; 10   : 	// create socket for server type
; 11   : 	// update server fields
; 12   : 	if ( serverType == TCP ) {
; 13   : 		server.sfd = CreateSocket(AF_INET, SOCK_STREAM, 0);

	mov	rax, QWORD PTR ?CreateSocket@@3P6A_KHHH@ZEA ; CreateSocket
	xor	r8d, r8d
	mov	edx, 1
	mov	ecx, edi
	call	rax
	mov	DWORD PTR [rbx], eax

; 14   : 		if ( server.sfd == INVALID_SOCKET )

	cmp	eax, -1
	je	SHORT $LN13@NewServerI

; 15   : 			return server;
; 16   : 
; 17   : 		server.type = SOCK_STREAM;
; 18   : 	} else if ( serverType == UDP) {
; 19   : 		server.sfd = CreateSocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
; 20   : 		if ( server.sfd == INVALID_SOCKET )
; 21   : 			return server;
; 22   : 
; 23   : 		server.type = SOCK_DGRAM;
; 24   : 	}
; 25   : 
; 26   : 	// update server fields
; 27   : 	server.addr.sin_family	    = AF_INET;
; 28   : 	server.addr.sin_addr.s_addr = INADDR_ANY; // servers shouldnt bind to any address
; 29   : 	server.addr.sin_port        = htons(port);

	mov	ecx, 5454				; 0000154eH
	mov	DWORD PTR [rbx+8], 1
	mov	WORD PTR [rbx+20], di
	mov	DWORD PTR [rbx+24], 0
	call	QWORD PTR __imp_htons
	mov	WORD PTR [rbx+22], ax

; 30   : 	server.port                 = port;

	mov	DWORD PTR [rbx+16], 5454		; 0000154eH
$LN13@NewServerI:

; 31   : 
; 32   : 	return server;
; 33   : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?NewServerInstance@ServerInterface@@QEAA?AUServer@@W4SocketTypes@@H@Z ENDP ; ServerInterface::NewServerInstance
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?TCPSendMessageToClient@ServerInterface@@QEAAHJUServerCommand@@@Z
_TEXT	SEGMENT
this$dead$ = 48
cuid$dead$ = 56
req$ = 64
?TCPSendMessageToClient@ServerInterface@@QEAAHJUServerCommand@@@Z PROC ; ServerInterface::TCPSendMessageToClient, COMDAT

; 36   : BOOL ServerInterface::TCPSendMessageToClient(long cuid, ServerCommand req) {

$LN5:
	sub	rsp, 40					; 00000028H

; 37   : 	return TRUE;

	mov	rcx, r8
	call	??1ServerCommand@@QEAA@XZ
	mov	eax, 1

; 38   : }

	add	rsp, 40					; 00000028H
	ret	0
?TCPSendMessageToClient@ServerInterface@@QEAAHJUServerCommand@@@Z ENDP ; ServerInterface::TCPSendMessageToClient
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?WaitForClientResponse@ServerInterface@@QEAA?AUClientResponse@@J@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
cuid$dead$ = 24
?WaitForClientResponse@ServerInterface@@QEAA?AUClientResponse@@J@Z PROC ; ServerInterface::WaitForClientResponse, COMDAT

; 41   : 	return {};

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	DWORD PTR [rdx+36], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 41   : 	return {};

	mov	rax, rdx
	mov	DWORD PTR [rdx+32], -1

; 42   : }

	ret	0
?WaitForClientResponse@ServerInterface@@QEAA?AUClientResponse@@J@Z ENDP ; ServerInterface::WaitForClientResponse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?UDPSendMessageToClient@ServerInterface@@QEAAHJUUDPResponse@@@Z
_TEXT	SEGMENT
this$dead$ = 8
cuid$dead$ = 16
message$dead$ = 24
?UDPSendMessageToClient@ServerInterface@@QEAAHJUUDPResponse@@@Z PROC ; ServerInterface::UDPSendMessageToClient, COMDAT

; 45   : 	return TRUE;

	mov	eax, 1

; 46   : }

	ret	0
?UDPSendMessageToClient@ServerInterface@@QEAAHJUUDPResponse@@@Z ENDP ; ServerInterface::UDPSendMessageToClient
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?AcceptTCPConnection@ServerInterface@@QEAAJVClient@@@Z
_TEXT	SEGMENT
this$dead$ = 48
clientToAccept$ = 56
?AcceptTCPConnection@ServerInterface@@QEAAJVClient@@@Z PROC ; ServerInterface::AcceptTCPConnection, COMDAT

; 48   : long ServerInterface::AcceptTCPConnection(Client clientToAccept) {

$LN5:
	sub	rsp, 40					; 00000028H

; 49   : 	return 0;

	mov	rcx, rdx
	call	??1Client@@QEAA@XZ
	xor	eax, eax

; 50   : }

	add	rsp, 40					; 00000028H
	ret	0
?AcceptTCPConnection@ServerInterface@@QEAAJVClient@@@Z ENDP ; ServerInterface::AcceptTCPConnection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
message$ = 240
req$GSCopy$ = 288
client$2 = 304
__$ArrayPad$ = 512
this$dead$ = 544
req$ = 552
?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; ServerInterface::PerformUDPRequest, COMDAT

; 52   : BOOL ServerInterface::PerformUDPRequest(BYTESTRING req) {

$LN166:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 528				; 00000210H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	QWORD PTR req$GSCopy$[rsp], rdx

; 53   : 	BOOL success = FALSE;

	xor	esi, esi
	mov	edi, esi

; 54   : 	
; 55   : 	// udp isnt encrypted, which is why we want to get out of udp as fast as possible
; 56   : 	// only serialized as a bytestring to send over sockets
; 57   : 	ClientMessage message = *reinterpret_cast< ClientMessage* >( req.data() );

	mov	rdx, QWORD PTR [rdx]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR message$[rsp], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR message$[rsp+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR message$[rsp+8], rax
	add	rdx, 16
	lea	rcx, QWORD PTR message$[rsp+16]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 58   : 	if ( !message.valid )

	cmp	DWORD PTR message$[rsp], esi
	jne	$LN4@PerformUDP
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR message$[rsp+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN38@PerformUDP

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR message$[rsp+16]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN52@PerformUDP

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN125@PerformUDP
$LN52@PerformUDP:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN38@PerformUDP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN64@PerformUDP

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN83@PerformUDP

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN155@PerformUDP

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN83@PerformUDP:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rsi

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rsi
$LN64@PerformUDP:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 59   : 		return FALSE;

	xor	eax, eax
	jmp	$LN1@PerformUDP
$LN4@PerformUDP:

; 60   : 
; 61   : 	switch ( message.action ) {

	cmp	DWORD PTR message$[rsp+4], 1048576	; 00100000H
	jne	SHORT $LN2@PerformUDP

; 62   : 	case ClientMessage::CONNECT_CLIENT:
; 63   : 		Client client = *reinterpret_cast< Client* >( message.client );

	mov	rdx, QWORD PTR message$[rsp+8]
	lea	rcx, QWORD PTR client$2[rsp]
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1

; 64   : 		
; 65   : 		long cuid = AcceptTCPConnection(client);

	lea	rdx, QWORD PTR client$2[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0Client@@QEAA@AEBV0@@Z

; 49   : 	return 0;

	mov	rcx, rax
	call	??1Client@@QEAA@XZ

; 66   : 		if ( cuid == -1 )
; 67   : 			success = FALSE;
; 68   : 		
; 69   : 		UDPMessage response = {};
; 70   : 		response.TCPServer = this->ServerDetails;
; 71   : 		response.isValid = TRUE;
; 72   : 		if ( UDPSendMessageToClient(cuid, response) )
; 73   : 			success = TRUE;

	mov	edi, 1

; 74   : 		break;

	lea	rcx, QWORD PTR client$2[rsp]
	call	??1Client@@QEAA@XZ
	npad	1
$LN2@PerformUDP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR message$[rsp+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN114@PerformUDP

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR message$[rsp+16]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN128@PerformUDP

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN125@PerformUDP
$LN128@PerformUDP:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN114@PerformUDP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN139@PerformUDP

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN158@PerformUDP

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN155@PerformUDP

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN158@PerformUDP:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rsi

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rsi
$LN139@PerformUDP:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 77   : 	return success;

	mov	eax, edi
$LN1@PerformUDP:

; 78   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+528]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN125@PerformUDP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN155@PerformUDP:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN163@PerformUDP:
?PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; ServerInterface::PerformUDPRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
message$ = 240
req$GSCopy$ = 288
client$2 = 304
__$ArrayPad$ = 512
this$dead$ = 544
req$ = 552
?dtor$0@?0??PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ServerInterface::PerformUDPRequest'::`1'::dtor$0
	mov	rcx, QWORD PTR req$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0??PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ServerInterface::PerformUDPRequest'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
message$ = 240
req$GSCopy$ = 288
client$2 = 304
__$ArrayPad$ = 512
this$dead$ = 544
req$ = 552
?dtor$1@?0??PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ServerInterface::PerformUDPRequest'::`1'::dtor$1
	lea	rcx, QWORD PTR message$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$1@?0??PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ServerInterface::PerformUDPRequest'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
message$ = 240
req$GSCopy$ = 288
client$2 = 304
__$ArrayPad$ = 512
this$dead$ = 544
req$ = 552
?dtor$2@?0??PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ServerInterface::PerformUDPRequest'::`1'::dtor$2
	lea	rcx, QWORD PTR client$2[rdx]
	jmp	??1Client@@QEAA@XZ
?dtor$2@?0??PerformUDPRequest@ServerInterface@@IEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ServerInterface::PerformUDPRequest'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 40
$T2 = 48
pingCommand$ = 176
clientInfo$ = 304
client$ = 576
__$ArrayPad$ = 784
this$ = 848
__$ReturnUdt$ = 856
cuid$ = 864
?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z PROC ; ServerInterface::PingClient, COMDAT

; 80   : ClientResponse ServerInterface::PingClient(long cuid) {

$LN486:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-544]
	sub	rsp, 800				; 00000320H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	esi, r8d
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	r14d, r14d

; 81   : 	if ( !ClientIsInClientList(cuid) )

	mov	edx, r8d
	call	?ClientIsInClientList@ServerInterface@@QEAAHJ@Z ; ServerInterface::ClientIsInClientList
	test	eax, eax
	jne	SHORT $LN2@PingClient

; 82   : 		return {};

	xor	eax, eax
	mov	DWORD PTR [rbx+36], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r14

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 82   : 		return {};

	mov	DWORD PTR [rbx+32], -1
	jmp	$LN460@PingClient
$LN2@PingClient:

; 83   : 
; 84   : 	ClientData clientInfo = GetClientData(cuid);

	mov	r8d, esi
	lea	rdx, QWORD PTR clientInfo$[rbp-256]
	mov	rcx, rdi
	call	?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z ; ServerInterface::GetClientData
	npad	1

; 85   : 	Client     client     = std::get<CLIENT_CLASS>(clientInfo);

	lea	rdx, QWORD PTR clientInfo$[rbp-192]
	lea	rcx, QWORD PTR client$[rbp-256]
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1

; 86   : 	if ( !client.SocketReady(TCP) ) // socket isnt ready so cant ping.

	xorps	xmm0, xmm0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 17   : 	return socketReady == TRUE;

	cmp	QWORD PTR client$[rbp-132], -1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 86   : 	if ( !client.SocketReady(TCP) ) // socket isnt ready so cant ping.

	jne	$LN3@PingClient

; 87   : 		return {};

	xor	eax, eax
	mov	DWORD PTR [rbx+36], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r14

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 87   : 		return {};

	mov	DWORD PTR [rbx+32], -1
	lea	rcx, QWORD PTR client$[rbp-256]
	call	??1Client@@QEAA@XZ
	npad	1
	lea	rcx, QWORD PTR clientInfo$[rbp-192]
	call	??1Client@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rbp-200]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN102@PingClient

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rbp-224]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN116@PingClient

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN471@PingClient
$LN116@PingClient:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN102@PingClient:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR clientInfo$[rbp-208], xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR clientInfo$[rbp-224], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rbp-232]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN460@PingClient

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rbp-256]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN474@PingClient

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN471@PingClient
$LN474@PingClient:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 96   : }

	call	??3@YAXPEAX_K@Z				; operator delete
$LN460@PingClient:
	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 800				; 00000320H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN3@PingClient:

; 90   : 	ServerCommand pingCommand = { true, {}, "", client.RSAPublicKey, PING_CLIENT};

	mov	BYTE PTR pingCommand$[rbp-256], 1
	movups	XMMWORD PTR pingCommand$[rbp-248], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR pingCommand$[rbp-232], xmm1

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR pingCommand$[rbp-216], r14

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR pingCommand$[rbp-208], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR pingCommand$[rbp-232], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR pingCommand$[rbp-200], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR pingCommand$[rbp-184], r14

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR pingCommand$[rbp-176], r14

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR pingCommand$[rbp-200]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 90   : 	ServerCommand pingCommand = { true, {}, "", client.RSAPublicKey, PING_CLIENT};

	lea	rdx, QWORD PTR client$[rbp-92]
	lea	rcx, QWORD PTR pingCommand$[rbp-168]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR pingCommand$[rbp-136], 6

; 91   : 	BOOL sent = TCPSendMessageToClient(cuid, pingCommand);

	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T1[rsp], rax
	movzx	eax, BYTE PTR pingCommand$[rbp-256]
	mov	BYTE PTR $T2[rsp], al
	mov	eax, DWORD PTR pingCommand$[rbp-248]
	mov	DWORD PTR $T2[rsp+8], eax
	mov	eax, DWORD PTR pingCommand$[rbp-244]
	mov	DWORD PTR $T2[rsp+12], eax
	mov	eax, DWORD PTR pingCommand$[rbp-240]
	mov	DWORD PTR $T2[rsp+16], eax
	lea	rdx, QWORD PTR pingCommand$[rbp-232]
	lea	rcx, QWORD PTR $T2[rsp+24]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR pingCommand$[rbp-200]
	lea	rcx, QWORD PTR $T2[rsp+56]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR pingCommand$[rbp-168]
	lea	rcx, QWORD PTR $T2[rbp-168]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR pingCommand$[rbp-136]
	mov	DWORD PTR $T2[rbp-136], eax

; 37   : 	return TRUE;

	lea	rcx, QWORD PTR $T2[rsp]
	call	??1ServerCommand@@QEAA@XZ

; 41   : 	return {};

	xor	eax, eax
	mov	DWORD PTR [rbx+36], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r14

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 41   : 	return {};

	mov	DWORD PTR [rbx+32], -1

; 92   : 	if ( !sent )
; 93   : 		return {};
; 94   : 
; 95   : 	return WaitForClientResponse(cuid);

	lea	rcx, QWORD PTR pingCommand$[rbp-256]
	call	??1ServerCommand@@QEAA@XZ
	npad	1
	lea	rcx, QWORD PTR client$[rbp-256]
	call	??1Client@@QEAA@XZ
	npad	1
	lea	rcx, QWORD PTR clientInfo$[rbp-192]
	call	??1Client@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rbp-200]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN411@PingClient

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rbp-224]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN425@PingClient

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN471@PingClient
$LN425@PingClient:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN411@PingClient:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR clientInfo$[rbp-208], xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR clientInfo$[rbp-224], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rbp-232]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	$LN460@PingClient

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rbp-256]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	$LN474@PingClient

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN474@PingClient
$LN471@PingClient:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN483@PingClient:
?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z ENDP ; ServerInterface::PingClient
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 40
$T2 = 48
pingCommand$ = 176
clientInfo$ = 304
client$ = 576
__$ArrayPad$ = 784
this$ = 848
__$ReturnUdt$ = 856
cuid$ = 864
?dtor$2@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA PROC ; `ServerInterface::PingClient'::`1'::dtor$2
	lea	rcx, QWORD PTR clientInfo$[rdx]
	jmp	??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
?dtor$2@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA ENDP ; `ServerInterface::PingClient'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 40
$T2 = 48
pingCommand$ = 176
clientInfo$ = 304
client$ = 576
__$ArrayPad$ = 784
this$ = 848
__$ReturnUdt$ = 856
cuid$ = 864
?dtor$3@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA PROC ; `ServerInterface::PingClient'::`1'::dtor$3
	lea	rcx, QWORD PTR client$[rdx]
	jmp	??1Client@@QEAA@XZ
?dtor$3@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA ENDP ; `ServerInterface::PingClient'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 40
$T2 = 48
pingCommand$ = 176
clientInfo$ = 304
client$ = 576
__$ArrayPad$ = 784
this$ = 848
__$ReturnUdt$ = 856
cuid$ = 864
?dtor$6@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA PROC ; `ServerInterface::PingClient'::`1'::dtor$6
	lea	rcx, QWORD PTR pingCommand$[rdx]
	add	rcx, 8
	jmp	??1ProcessInformation@@QEAA@XZ
?dtor$6@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA ENDP ; `ServerInterface::PingClient'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 40
$T2 = 48
pingCommand$ = 176
clientInfo$ = 304
client$ = 576
__$ArrayPad$ = 784
this$ = 848
__$ReturnUdt$ = 856
cuid$ = 864
?dtor$7@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA PROC ; `ServerInterface::PingClient'::`1'::dtor$7
	lea	rcx, QWORD PTR pingCommand$[rdx+56]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA ENDP ; `ServerInterface::PingClient'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 40
$T2 = 48
pingCommand$ = 176
clientInfo$ = 304
client$ = 576
__$ArrayPad$ = 784
this$ = 848
__$ReturnUdt$ = 856
cuid$ = 864
?dtor$9@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA PROC ; `ServerInterface::PingClient'::`1'::dtor$9
	lea	rcx, QWORD PTR pingCommand$[rdx]
	jmp	??1ServerCommand@@QEAA@XZ
?dtor$9@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA ENDP ; `ServerInterface::PingClient'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 40
$T2 = 48
pingCommand$ = 176
clientInfo$ = 304
client$ = 576
__$ArrayPad$ = 784
this$ = 848
__$ReturnUdt$ = 856
cuid$ = 864
?dtor$31@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA PROC ; `ServerInterface::PingClient'::`1'::dtor$31
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1ProcessInformation@@QEAA@XZ
?dtor$31@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA ENDP ; `ServerInterface::PingClient'::`1'::dtor$31
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T1 = 40
$T2 = 48
pingCommand$ = 176
clientInfo$ = 304
client$ = 576
__$ArrayPad$ = 784
this$ = 848
__$ReturnUdt$ = 856
cuid$ = 864
?dtor$32@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA PROC ; `ServerInterface::PingClient'::`1'::dtor$32
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$32@?0??PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z@4HA ENDP ; `ServerInterface::PingClient'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?ClientIsInClientList@ServerInterface@@QEAAHJ@Z
_TEXT	SEGMENT
cuid$GSCopy$ = 32
this$GSCopy$ = 40
cd$1 = 48
__$ArrayPad$ = 320
this$ = 352
cuid$ = 360
?ClientIsInClientList@ServerInterface@@QEAAHJ@Z PROC	; ServerInterface::ClientIsInClientList, COMDAT

; 98   : BOOL ServerInterface::ClientIsInClientList(long cuid) {

$LN184:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 336				; 00000150H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	mov	DWORD PTR cuid$GSCopy$[rsp], edx

; 99   : 	try {
; 100  : 		ClientListMutex.lock();

	lea	rbx, QWORD PTR [rcx+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	mov	rcx, rbx
	call	_Mtx_lock
	test	eax, eax
	jne	$LN180@ClientIsIn

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	cmp	DWORD PTR [rbx+76], 2147483647		; 7fffffffH
	je	$LN181@ClientIsIn

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	mov	rcx, rbx
	call	_Mtx_lock
	test	eax, eax
	jne	$LN182@ClientIsIn

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	mov	eax, DWORD PTR [rbx+76]
	cmp	eax, 2147483647				; 7fffffffH
	je	$LN183@ClientIsIn

; 71   :         _Mtx_unlock(_Mymtx());

	mov	rcx, rbx
	call	_Mtx_unlock
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 101  : 		ClientData cd = GetClientList().at(cuid);

	lea	rdx, QWORD PTR cuid$GSCopy$[rsp]
	mov	rcx, rdi
	call	?at@?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@2@AEBJ@Z ; std::unordered_map<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::hash<long>,std::equal_to<long>,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::at
	mov	rdi, rax
	mov	rdx, rax
	lea	rcx, QWORD PTR cd$1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR [rdi+32]
	lea	rcx, QWORD PTR cd$1[rsp+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR [rdi+64]
	lea	rcx, QWORD PTR cd$1[rsp+64]
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 71   :         _Mtx_unlock(_Mymtx());

	mov	rcx, rbx
	call	_Mtx_unlock
	lea	rcx, QWORD PTR cd$1[rsp+64]
	call	??1Client@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR cd$1[rsp+56]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN99@ClientIsIn

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR cd$1[rsp+32]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN113@ClientIsIn

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN159@ClientIsIn
$LN113@ClientIsIn:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN99@ClientIsIn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR cd$1[rsp+48], xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR cd$1[rsp+32], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR cd$1[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN148@ClientIsIn

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR cd$1[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN162@ClientIsIn

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN159@ClientIsIn
$LN162@ClientIsIn:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN148@ClientIsIn:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 108  : 	return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@ClientIsIn
$LN8@ClientIsIn:

; 102  : 		ClientListMutex.unlock();
; 103  : 	}
; 104  : 	catch ( const std::out_of_range& ) {
; 105  : 		ClientListMutex.unlock();
; 106  : 		return FALSE;

	xor	eax, eax
$LN1@ClientIsIn:

; 109  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+368]
	add	rsp, 336				; 00000150H
	pop	rdi
	ret	0
$LN180@ClientIsIn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 54   :             _STD _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN181@ClientIsIn:

; 80   :             --_Mtx_storage._Count;

	mov	DWORD PTR [rbx+76], 2147483646		; 7ffffffeH

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	ecx, 6
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN182@ClientIsIn:

; 54   :             _STD _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN183@ClientIsIn:

; 80   :             --_Mtx_storage._Count;

	dec	eax
	mov	DWORD PTR [rbx+76], eax

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	ecx, 6
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN159@ClientIsIn:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN177@ClientIsIn:
	int	3
?ClientIsInClientList@ServerInterface@@QEAAHJ@Z ENDP	; ServerInterface::ClientIsInClientList
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
cuid$GSCopy$ = 32
this$GSCopy$ = 40
cd$1 = 48
__$ArrayPad$ = 320
this$ = 352
cuid$ = 360
?dtor$4@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA PROC ; `ServerInterface::ClientIsInClientList'::`1'::dtor$4
	lea	rcx, QWORD PTR cd$1[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$4@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA ENDP ; `ServerInterface::ClientIsInClientList'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
cuid$GSCopy$ = 32
this$GSCopy$ = 40
cd$1 = 48
__$ArrayPad$ = 320
this$ = 352
cuid$ = 360
?dtor$2@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA PROC ; `ServerInterface::ClientIsInClientList'::`1'::dtor$2
	lea	rcx, QWORD PTR cd$1[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
?dtor$2@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA ENDP ; `ServerInterface::ClientIsInClientList'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT text$x
text$x	SEGMENT
cuid$GSCopy$ = 32
this$GSCopy$ = 40
cd$1 = 48
__$ArrayPad$ = 320
this$ = 352
cuid$ = 360
?catch$18@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA PROC ; `ServerInterface::ClientIsInClientList'::`1'::catch$18

; 104  : 	catch ( const std::out_of_range& ) {

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?ClientIsInClientList@ServerInterface@@QEAAHJ@Z$0:

; 105  : 		ClientListMutex.unlock();

	mov	rcx, QWORD PTR this$GSCopy$[rbp]
	add	rcx, 64					; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 71   :         _Mtx_unlock(_Mymtx());

	call	_Mtx_unlock
	npad	1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 106  : 		return FALSE;

	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$18@?0??ClientIsInClientList@ServerInterface@@QEAAHJ@Z@4HA ENDP ; `ServerInterface::ClientIsInClientList'::`1'::catch$18
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?AddToClientList@ServerInterface@@QEAAHVClient@@@Z
_TEXT	SEGMENT
$T2 = 32
$T3 = 304
client$GSCopy$ = 320
cuid$ = 328
__$ArrayPad$ = 336
this$ = 416
client$ = 424
?AddToClientList@ServerInterface@@QEAAHVClient@@@Z PROC	; ServerInterface::AddToClientList, COMDAT

; 111  : BOOL ServerInterface::AddToClientList(Client client) {

$LN343:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14, rdx
	mov	r13, rcx
	mov	QWORD PTR client$GSCopy$[rbp-256], rdx
	xor	r12d, r12d

; 112  : 	long cuid = -1;

	mov	DWORD PTR cuid$[rbp-256], -1

; 113  : 	
; 114  : 	// generate a cuid that isnt in use
; 115  : 	while ( cuid != -1 && IsCUIDInUse(cuid) )
; 116  : 		cuid = client.GenerateCUID();
; 117  : 
; 118  : 	client.SetClientID(cuid);

	mov	DWORD PTR [rdx+196], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	add	rcx, 64					; 00000040H
	call	_Mtx_lock
	test	eax, eax
	jne	$LN340@AddToClien

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	cmp	DWORD PTR [r13+140], 2147483647		; 7fffffffH
	je	$LN341@AddToClien
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, r14
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 121  : 	this->ClientList[cuid] = std::make_tuple(client, client.RSAPublicKey, client.RSAPrivateKey);

	lea	rdx, QWORD PTR [r14+164]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	lea	rcx, QWORD PTR $T2[rsp+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, r14
	lea	rcx, QWORD PTR $T2[rsp+64]
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 433  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	lea	r8, QWORD PTR cuid$[rbp-256]
	lea	rdx, QWORD PTR $T3[rbp-256]
	mov	rcx, r13
	call	??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Try_emplace<long const &>
	mov	rsi, QWORD PTR [rax]
	lea	rdx, QWORD PTR $T2[rsp+64]
	lea	rcx, QWORD PTR [rsi+88]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR $T2[rbp-160]
	mov	DWORD PTR [rsi+120], eax
	lea	rdx, QWORD PTR $T2[rbp-156]
	lea	rcx, QWORD PTR [rsi+124]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR $T2[rbp-124]
	mov	DWORD PTR [rsi+156], eax
	mov	eax, DWORD PTR $T2[rbp-120]
	mov	DWORD PTR [rsi+160], eax
	lea	rdx, QWORD PTR $T2[rbp-116]
	lea	rcx, QWORD PTR [rsi+164]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR $T2[rbp-84]
	mov	DWORD PTR [rsi+196], eax
	mov	eax, DWORD PTR $T2[rbp-80]
	mov	DWORD PTR [rsi+200], eax
	mov	rax, QWORD PTR $T2[rbp-76]
	mov	QWORD PTR [rsi+204], rax
	mov	rax, QWORD PTR $T2[rbp-68]
	mov	QWORD PTR [rsi+212], rax
	lea	rcx, QWORD PTR [rsi+220]
	lea	rdx, QWORD PTR $T2[rbp-60]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	rcx, QWORD PTR [rsi+252]
	lea	rdx, QWORD PTR $T2[rbp-28]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR $T2[rbp+4]
	mov	DWORD PTR [rsi+284], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 586  :         _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);

	lea	rcx, QWORD PTR [rsi+56]
	lea	rdx, QWORD PTR $T2[rsp+32]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR [rsi+24]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
	lea	rcx, QWORD PTR $T2[rsp+64]
	call	??1Client@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T2[rsp+56]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN184@AddToClien

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T2[rsp+32]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN198@AddToClien

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN244@AddToClien
$LN198@AddToClien:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN184@AddToClien:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR $T2[rsp+48], xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[rsp+32], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T2[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN233@AddToClien

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T2[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN247@AddToClien

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN244@AddToClien
$LN247@AddToClien:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN233@AddToClien:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 71   :         _Mtx_unlock(_Mymtx());

	lea	rcx, QWORD PTR [r13+64]
	call	_Mtx_unlock
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	r8d, DWORD PTR cuid$[rbp-256]
	movzx	edx, r8b
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rdx, rax

; 2302 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	imul	rdx, rcx

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR cuid$[rbp-255]
	xor	rdx, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rdx, rcx

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR cuid$[rbp-254]
	xor	rdx, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rdx, rcx

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR cuid$[rbp-253]
	xor	rdx, rax

; 2302 :         _Val *= _FNV_prime;

	imul	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR [r13+48]
	and	rcx, rdx

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rax, QWORD PTR [r13+24]
	mov	rdx, QWORD PTR [rax+rcx*8+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1567 :         if (_Where == _End) {

	cmp	rdx, QWORD PTR [r13+8]
	je	SHORT $LN260@AddToClien

; 1568 :             return {_End, _Nodeptr{}};
; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rax+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	r8d, DWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN311@AddToClien
$LL284@AddToClien:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};
; 1582 :             }
; 1583 : 
; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rdx, rcx
	je	SHORT $LN260@AddToClien

; 1585 :                 return {_Where, _Nodeptr{}};
; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rdx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	r8d, DWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL284@AddToClien
$LN311@AddToClien:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 125  : 	return std::get<CLIENT_CLASS>(this->ClientList.at(cuid)).TCPSocket == client.TCPSocket;

	mov	r8, QWORD PTR [r14+124]
	cmp	QWORD PTR [rdx+212], r8
	sete	r12b
	mov	rcx, r14
	call	??1Client@@QEAA@XZ
	mov	eax, r12d

; 126  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+432]
	add	rsp, 352				; 00000160H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN244@AddToClien:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN260@AddToClien:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 442  :         _Xout_of_range("invalid unordered_map<K, T> key");

	lea	rcx, OFFSET FLAT:??_C@_0CA@MMOGIFNF@invalid?5unordered_map?$DMK?0?5T?$DO?5key@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	int	3
$LN340@AddToClien:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex

; 54   :             _STD _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN341@AddToClien:

; 80   :             --_Mtx_storage._Count;

	mov	DWORD PTR [r13+140], 2147483646		; 7ffffffeH

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	ecx, 6
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN338@AddToClien:
?AddToClientList@ServerInterface@@QEAAHVClient@@@Z ENDP	; ServerInterface::AddToClientList
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T3 = 304
client$GSCopy$ = 320
cuid$ = 328
__$ArrayPad$ = 336
this$ = 416
client$ = 424
?dtor$0@?0??AddToClientList@ServerInterface@@QEAAHVClient@@@Z@4HA PROC ; `ServerInterface::AddToClientList'::`1'::dtor$0
	mov	rcx, QWORD PTR client$GSCopy$[rdx]
	jmp	??1Client@@QEAA@XZ
?dtor$0@?0??AddToClientList@ServerInterface@@QEAAHVClient@@@Z@4HA ENDP ; `ServerInterface::AddToClientList'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T3 = 304
client$GSCopy$ = 320
cuid$ = 328
__$ArrayPad$ = 336
this$ = 416
client$ = 424
?dtor$6@?0??AddToClientList@ServerInterface@@QEAAHVClient@@@Z@4HA PROC ; `ServerInterface::AddToClientList'::`1'::dtor$6
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$6@?0??AddToClientList@ServerInterface@@QEAAHVClient@@@Z@4HA ENDP ; `ServerInterface::AddToClientList'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T3 = 304
client$GSCopy$ = 320
cuid$ = 328
__$ArrayPad$ = 336
this$ = 416
client$ = 424
?dtor$4@?0??AddToClientList@ServerInterface@@QEAAHVClient@@@Z@4HA PROC ; `ServerInterface::AddToClientList'::`1'::dtor$4
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
?dtor$4@?0??AddToClientList@ServerInterface@@QEAAHVClient@@@Z@4HA ENDP ; `ServerInterface::AddToClientList'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T3 = 304
client$GSCopy$ = 320
cuid$ = 328
__$ArrayPad$ = 336
this$ = 416
client$ = 424
?dtor$1@?0??AddToClientList@ServerInterface@@QEAAHVClient@@@Z@4HA PROC ; `ServerInterface::AddToClientList'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
?dtor$1@?0??AddToClientList@ServerInterface@@QEAAHVClient@@@Z@4HA ENDP ; `ServerInterface::AddToClientList'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?IsClientAlive@ServerInterface@@QEAAHJ@Z
_TEXT	SEGMENT
$T1 = 32
clientInfo$ = 80
client$ = 352
__$ArrayPad$ = 560
this$ = 592
cuid$ = 600
?IsClientAlive@ServerInterface@@QEAAHJ@Z PROC		; ServerInterface::IsClientAlive, COMDAT

; 128  : BOOL ServerInterface::IsClientAlive(long cuid) {

$LN194:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 576				; 00000240H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	edi, edx
	mov	rbx, rcx

; 129  : 	// Check if client is in ClientList and exists
; 130  : 	if ( !ClientIsInClientList(cuid) )

	call	?ClientIsInClientList@ServerInterface@@QEAAHJ@Z ; ServerInterface::ClientIsInClientList
	test	eax, eax
	je	$LN1@IsClientAl

; 131  : 		return FALSE; // Client doesn't exist. Nothing returned from GetClientData
; 132  : 
; 133  : 	ClientData clientInfo = GetClientData(cuid);

	mov	r8d, edi
	lea	rdx, QWORD PTR clientInfo$[rsp]
	mov	rcx, rbx
	call	?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z ; ServerInterface::GetClientData
	npad	1

; 134  : 	Client client = std::get<CLIENT_CLASS>(clientInfo);

	lea	rdx, QWORD PTR clientInfo$[rsp+64]
	lea	rcx, QWORD PTR client$[rsp]
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\client.cpp

; 17   : 	return socketReady == TRUE;

	cmp	QWORD PTR client$[rsp+124], -1
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 136  : 	if ( client.SocketReady(TCP) == FALSE )

	je	SHORT $LN9@IsClientAl

; 140  : 	if ( PingClient(cuid).responseCode != C_OK )

	mov	r8d, edi
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	?PingClient@ServerInterface@@QEAA?AUClientResponse@@J@Z ; ServerInterface::PingClient
	mov	ebx, DWORD PTR [rax+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T1[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN49@IsClientAl

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN63@IsClientAl

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN192@IsClientAl
$LN63@IsClientAl:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN49@IsClientAl:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 140  : 	if ( PingClient(cuid).responseCode != C_OK )

	test	ebx, ebx
	jne	SHORT $LN9@IsClientAl

; 143  : 	return TRUE; // Client is alive

	mov	ebx, 1
	jmp	SHORT $LN10@IsClientAl
$LN9@IsClientAl:
	xor	ebx, ebx
$LN10@IsClientAl:
	lea	rcx, QWORD PTR client$[rsp]
	call	??1Client@@QEAA@XZ
	npad	1
	lea	rcx, QWORD PTR clientInfo$[rsp+64]
	call	??1Client@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rsp+56]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN118@IsClientAl

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rsp+32]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN132@IsClientAl

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN178@IsClientAl
$LN132@IsClientAl:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN118@IsClientAl:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR clientInfo$[rsp+48], xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR clientInfo$[rsp+32], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN167@IsClientAl

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN181@IsClientAl

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN178@IsClientAl
$LN181@IsClientAl:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN167@IsClientAl:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 143  : 	return TRUE; // Client is alive

	mov	eax, ebx
$LN1@IsClientAl:

; 144  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+608]
	add	rsp, 576				; 00000240H
	pop	rdi
	ret	0
$LN178@IsClientAl:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN192@IsClientAl:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN190@IsClientAl:
?IsClientAlive@ServerInterface@@QEAAHJ@Z ENDP		; ServerInterface::IsClientAlive
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
clientInfo$ = 80
client$ = 352
__$ArrayPad$ = 560
this$ = 592
cuid$ = 600
?dtor$0@?0??IsClientAlive@ServerInterface@@QEAAHJ@Z@4HA PROC ; `ServerInterface::IsClientAlive'::`1'::dtor$0
	lea	rcx, QWORD PTR clientInfo$[rdx]
	jmp	??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
?dtor$0@?0??IsClientAlive@ServerInterface@@QEAAHJ@Z@4HA ENDP ; `ServerInterface::IsClientAlive'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
clientInfo$ = 80
client$ = 352
__$ArrayPad$ = 560
this$ = 592
cuid$ = 600
?dtor$1@?0??IsClientAlive@ServerInterface@@QEAAHJ@Z@4HA PROC ; `ServerInterface::IsClientAlive'::`1'::dtor$1
	lea	rcx, QWORD PTR client$[rdx]
	jmp	??1Client@@QEAA@XZ
?dtor$1@?0??IsClientAlive@ServerInterface@@QEAAHJ@Z@4HA ENDP ; `ServerInterface::IsClientAlive'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
req$GSCopy$ = 72
__$ReturnUdt$GSCopy$ = 72
__$ArrayPad$ = 80
this$ = 144
__$ReturnUdt$ = 152
cuid$ = 160
req$ = 168
?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; ServerInterface::DecryptClientRequest, COMDAT

; 158  : ClientRequest ServerInterface::DecryptClientRequest(long cuid, BYTESTRING req) {

$LN39:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, r9
	mov	edi, r8d
	mov	rbp, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	mov	QWORD PTR req$GSCopy$[rsp], r9
	xor	r14d, r14d

; 159  : 	return DecryptClientData<ClientRequest>(req, cuid); // return decrypted clientRequest struct

	mov	rdx, r9
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	r9d, edi
	mov	r8, rax
	mov	rdx, rbp
	mov	rcx, rbx
	call	??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z ; ServerInterface::DecryptClientData<ClientRequest>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN11@DecryptCli

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN30@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN27@DecryptCli

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN30@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [rsi], r14

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], r14

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], r14
$LN11@DecryptCli:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 159  : 	return DecryptClientData<ClientRequest>(req, cuid); // return decrypted clientRequest struct

	mov	rax, rbp

; 160  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN27@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN36@DecryptCli:
?DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; ServerInterface::DecryptClientRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
req$GSCopy$ = 72
__$ReturnUdt$GSCopy$ = 72
__$ArrayPad$ = 80
this$ = 144
__$ReturnUdt$ = 152
cuid$ = 160
req$ = 168
?dtor$0@?0??DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ServerInterface::DecryptClientRequest'::`1'::dtor$0
	mov	rcx, QWORD PTR req$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0??DecryptClientRequest@ServerInterface@@QEAA?AUClientRequest@@JV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ServerInterface::DecryptClientRequest'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
resp$GSCopy$ = 72
__$ReturnUdt$GSCopy$ = 72
__$ArrayPad$ = 80
this$ = 144
__$ReturnUdt$ = 152
cuid$ = 160
resp$ = 168
?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; ServerInterface::DecryptClientResponse, COMDAT

; 162  : ClientResponse ServerInterface::DecryptClientResponse(long cuid, BYTESTRING resp) {

$LN39:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, r9
	mov	edi, r8d
	mov	rbp, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	mov	QWORD PTR resp$GSCopy$[rsp], r9
	xor	r14d, r14d

; 163  : 	return DecryptClientData<ClientResponse>(resp, cuid);

	mov	rdx, r9
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	r9d, edi
	mov	r8, rax
	mov	rdx, rbp
	mov	rcx, rbx
	call	??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z ; ServerInterface::DecryptClientData<ClientResponse>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN11@DecryptCli

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN30@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN27@DecryptCli

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN30@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [rsi], r14

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], r14

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], r14
$LN11@DecryptCli:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 163  : 	return DecryptClientData<ClientResponse>(resp, cuid);

	mov	rax, rbp

; 164  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN27@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN36@DecryptCli:
?DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; ServerInterface::DecryptClientResponse
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
resp$GSCopy$ = 72
__$ReturnUdt$GSCopy$ = 72
__$ArrayPad$ = 80
this$ = 144
__$ReturnUdt$ = 152
cuid$ = 160
resp$ = 168
?dtor$0@?0??DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `ServerInterface::DecryptClientResponse'::`1'::dtor$0
	mov	rcx, QWORD PTR resp$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0??DecryptClientResponse@ServerInterface@@QEAA?AUClientResponse@@JV?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `ServerInterface::DecryptClientResponse'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 184
$T5 = 216
__$ReturnUdt$GSCopy$ = 472
req$GSCopy$ = 472
blob$ = 480
__$ArrayPad$ = 736
this$dead$ = 784
__$ReturnUdt$ = 792
req$ = 800
?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z PROC ; ServerInterface::EncryptServerRequest, COMDAT

; 166  : BYTESTRING ServerInterface::EncryptServerRequest(ServerRequest req) {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 752				; 000002f0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, r8
	mov	rsi, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	mov	QWORD PTR req$GSCopy$[rsp], r8

; 167  : 	NET_BLOB blob = NetCommon::RequestToBlob(req, req.publicEncryptionKey);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR [r8+88]
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T1[rsp], rax
	movzx	eax, BYTE PTR [r14]
	mov	BYTE PTR $T3[rsp], al
	mov	eax, DWORD PTR [r14+8]
	mov	DWORD PTR $T3[rsp+8], eax
	mov	eax, DWORD PTR [r14+12]
	mov	DWORD PTR $T3[rsp+12], eax
	mov	eax, DWORD PTR [r14+16]
	mov	DWORD PTR $T3[rsp+16], eax
	lea	rdx, QWORD PTR [r14+24]
	lea	rcx, QWORD PTR $T3[rsp+24]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR [r14+56]
	lea	rcx, QWORD PTR $T3[rsp+56]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rdx, QWORD PTR [r14+88]
	lea	rcx, QWORD PTR $T3[rsp+88]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [r14+120]
	mov	DWORD PTR $T3[rsp+120], eax
	mov	r8, rdi
	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR blob$[rsp]
	call	?RequestToBlob@NetCommon@@YA?AUNET_BLOB@@UServerCommand@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; NetCommon::RequestToBlob
	npad	1
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rsi], xmm0
	mov	QWORD PTR [rsi+16], rax

; 168  : 	BYTESTRING cipher = NetCommon::AESEncryptBlob(blob);

	lea	rdx, QWORD PTR blob$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0NET_BLOB@@QEAA@AEBU0@@Z
	mov	rdx, rax
	mov	rcx, rsi
	call	?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z ; NetCommon::AESEncryptBlob
	npad	1

; 169  : 
; 170  : 	return cipher;

	lea	rcx, QWORD PTR blob$[rsp]
	call	??1NET_BLOB@@QEAA@XZ
	npad	1
	mov	rcx, r14
	call	??1ServerCommand@@QEAA@XZ
	mov	rax, rsi

; 171  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+784]
	add	rsp, 752				; 000002f0H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z ENDP ; ServerInterface::EncryptServerRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 184
$T5 = 216
__$ReturnUdt$GSCopy$ = 472
req$GSCopy$ = 472
blob$ = 480
__$ArrayPad$ = 736
this$dead$ = 784
__$ReturnUdt$ = 792
req$ = 800
?dtor$0@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA PROC ; `ServerInterface::EncryptServerRequest'::`1'::dtor$0
	mov	rcx, QWORD PTR req$GSCopy$[rdx]
	jmp	??1ServerCommand@@QEAA@XZ
?dtor$0@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA ENDP ; `ServerInterface::EncryptServerRequest'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 184
$T5 = 216
__$ReturnUdt$GSCopy$ = 472
req$GSCopy$ = 472
blob$ = 480
__$ArrayPad$ = 736
this$dead$ = 784
__$ReturnUdt$ = 792
req$ = 800
?dtor$1@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA PROC ; `ServerInterface::EncryptServerRequest'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA ENDP ; `ServerInterface::EncryptServerRequest'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 184
$T5 = 216
__$ReturnUdt$GSCopy$ = 472
req$GSCopy$ = 472
blob$ = 480
__$ArrayPad$ = 736
this$dead$ = 784
__$ReturnUdt$ = 792
req$ = 800
?dtor$6@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA PROC ; `ServerInterface::EncryptServerRequest'::`1'::dtor$6
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1ProcessInformation@@QEAA@XZ
?dtor$6@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA ENDP ; `ServerInterface::EncryptServerRequest'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 184
$T5 = 216
__$ReturnUdt$GSCopy$ = 472
req$GSCopy$ = 472
blob$ = 480
__$ArrayPad$ = 736
this$dead$ = 784
__$ReturnUdt$ = 792
req$ = 800
?dtor$7@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA PROC ; `ServerInterface::EncryptServerRequest'::`1'::dtor$7
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA ENDP ; `ServerInterface::EncryptServerRequest'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 184
$T5 = 216
__$ReturnUdt$GSCopy$ = 472
req$GSCopy$ = 472
blob$ = 480
__$ArrayPad$ = 736
this$dead$ = 784
__$ReturnUdt$ = 792
req$ = 800
?dtor$3@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA PROC ; `ServerInterface::EncryptServerRequest'::`1'::dtor$3
	lea	rcx, QWORD PTR blob$[rdx]
	jmp	??1NET_BLOB@@QEAA@XZ
?dtor$3@?0??EncryptServerRequest@ServerInterface@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@UServerCommand@@@Z@4HA ENDP ; `ServerInterface::EncryptServerRequest'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ?IsCUIDInUse@ServerInterface@@QEAAHJ@Z
_TEXT	SEGMENT
this$ = 48
cuid$ = 56
?IsCUIDInUse@ServerInterface@@QEAAHJ@Z PROC		; ServerInterface::IsCUIDInUse, COMDAT

; 173  : BOOL ServerInterface::IsCUIDInUse(long cuid) {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx

; 174  : 	try {
; 175  : 		// client isnt even in the client list
; 176  : 		if ( !ClientIsInClientList(cuid) )

	call	?ClientIsInClientList@ServerInterface@@QEAAHJ@Z ; ServerInterface::ClientIsInClientList
	test	eax, eax
	je	SHORT $LN1@IsCUIDInUs
$LN3@IsCUIDInUs:

; 177  : 			return FALSE;
; 178  : 
; 179  : 		if ( !IsClientAlive(cuid) ) {

	mov	edx, ebx
	mov	rcx, rdi
	call	?IsClientAlive@ServerInterface@@QEAAHJ@Z ; ServerInterface::IsClientAlive
	test	eax, eax
	jne	SHORT $LN4@IsCUIDInUs

; 180  : 			// client is in the client list. remove them
; 181  : 			RemoveClientFromClientList(cuid);

	mov	edx, ebx
	mov	rcx, rdi
	call	?RemoveClientFromClientList@ServerInterface@@QEAAHJ@Z ; ServerInterface::RemoveClientFromClientList

; 182  : 			
; 183  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@IsCUIDInUs
$LN4@IsCUIDInUs:

; 188  : 	}
; 189  : 
; 190  : 	return TRUE;

	mov	eax, 1

; 191  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@IsCUIDInUs:

; 184  : 		}
; 185  : 	}
; 186  : 	catch ( const std::out_of_range& ) {
; 187  : 		return FALSE;

	xor	eax, eax
$LN1@IsCUIDInUs:

; 191  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
	int	3
?IsCUIDInUse@ServerInterface@@QEAAHJ@Z ENDP		; ServerInterface::IsCUIDInUse
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
cuid$ = 56
?catch$0@?0??IsCUIDInUse@ServerInterface@@QEAAHJ@Z@4HA PROC ; `ServerInterface::IsCUIDInUse'::`1'::catch$0

; 186  : 	catch ( const std::out_of_range& ) {

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?IsCUIDInUse@ServerInterface@@QEAAHJ@Z$0:

; 187  : 		return FALSE;

	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$0@?0??IsCUIDInUse@ServerInterface@@QEAAHJ@Z@4HA ENDP ; `ServerInterface::IsCUIDInUse'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
;	COMDAT ?at@?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@2@AEBJ@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
?at@?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@2@AEBJ@Z PROC ; std::unordered_map<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::hash<long>,std::equal_to<long>,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::at, COMDAT

; 436  :     _NODISCARD mapped_type& at(const key_type& _Keyval) {

$LN56:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 436  :     _NODISCARD mapped_type& at(const key_type& _Keyval) {

	mov	r9, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 436  :     _NODISCARD mapped_type& at(const key_type& _Keyval) {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]

; 2302 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rdx, QWORD PTR [r9+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	imul	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	and	rdx, r8

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	shl	rdx, 4
	add	rdx, QWORD PTR [r9+24]
	mov	rax, QWORD PTR [rdx+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1567 :         if (_Where == _End) {

	cmp	rax, QWORD PTR [r9+8]
	je	SHORT $LN2@at
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	mov	ecx, DWORD PTR [r10]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN42@at
	npad	2
$LL26@at:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};
; 1582 :             }
; 1583 : 
; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rax, rdx
	je	SHORT $LN2@at

; 1585 :                 return {_Where, _Nodeptr{}};
; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL26@at
$LN42@at:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map

; 439  :             return _Target._Duplicate->_Myval.second;

	add	rax, 24

; 443  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@at:

; 440  :         }
; 441  : 
; 442  :         _Xout_of_range("invalid unordered_map<K, T> key");

	lea	rcx, OFFSET FLAT:??_C@_0CA@MMOGIFNF@invalid?5unordered_map?$DMK?0?5T?$DO?5key@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	int	3
$LN53@at:
?at@?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@2@AEBJ@Z ENDP ; std::unordered_map<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::hash<long>,std::equal_to<long>,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::at
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
;	COMDAT ??A?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@1@AEBJ@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
??A?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@1@AEBJ@Z PROC ; std::unordered_map<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::hash<long>,std::equal_to<long>,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator[], COMDAT

; 432  :     mapped_type& operator[](const key_type& _Keyval) {

$LN4:
	sub	rsp, 56					; 00000038H

; 433  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Try_emplace<long const &>
	mov	rax, QWORD PTR [rax]
	add	rax, 24

; 434  :     }

	add	rsp, 56					; 00000038H
	ret	0
??A?$unordered_map@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@U?$hash@J@2@U?$equal_to@J@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAAEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@1@AEBJ@Z ENDP ; std::unordered_map<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::hash<long>,std::equal_to<long>,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::erase, COMDAT

; 1135 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Erase(_Keyval))) /* strengthened */ {

$LN152:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1135 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Erase(_Keyval))) /* strengthened */ {

	mov	r9, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1135 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Erase(_Keyval))) /* strengthened */ {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]

; 2302 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rdx, QWORD PTR [r9+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	imul	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	and	rdx, r8

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r8, QWORD PTR [r9+8]
	shl	rdx, 4
	add	rdx, QWORD PTR [r9+24]
	mov	r11, QWORD PTR [rdx+8]
	mov	rbx, r11

; 1567 :         if (_Where == _End) {

	cmp	r11, r8
	je	SHORT $LN133@erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	mov	eax, DWORD PTR [r10]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	eax, DWORD PTR [r11+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN132@erase
$LL30@erase:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};
; 1582 :             }
; 1583 : 
; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rcx
	je	SHORT $LN133@erase

; 1585 :                 return {_Where, _Nodeptr{}};
; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	eax, DWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL30@erase
	jmp	SHORT $LN132@erase
$LN133@erase:

; 1109 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	xor	ebx, ebx
$LN132@erase:
	test	rbx, rbx

; 1110 :             if (_Target) {

	je	SHORT $LN5@erase

; 1665 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rdx]

; 1110 :             if (_Target) {

	mov	QWORD PTR [rsp+64], rdi

; 1665 :         if (_Bucket_hi == _Plist) {

	cmp	r11, rbx
	jne	SHORT $LN44@erase

; 1666 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rbx
	jne	SHORT $LN46@erase

; 1667 :                 const auto _End = _List._Mypair._Myval2._Myhead;
; 1668 : 
; 1669 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rdx], r8

; 1673 :             }

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN48@erase
$LN46@erase:

; 1670 :                 _Bucket_hi = _End;
; 1671 :             } else {
; 1672 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	r8, QWORD PTR [rbx+8]

; 1673 :             }

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN48@erase
$LN44@erase:

; 1674 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rbx
	jne	SHORT $LN48@erase

; 1675 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdx], rax
$LN48@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1423 :         const auto _Result = _Pnode->_Next;

	mov	rcx, QWORD PTR [rbx]

; 1424 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1425 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR [r9+16]

; 1426 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax], rcx

; 1427 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rcx+8], rax
	lea	rcx, QWORD PTR [rbx+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rbx+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1136 :         return _Erase(_Keyval);

	mov	rdi, QWORD PTR [rsp+64]
	mov	eax, 1

; 1137 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@erase:

; 1136 :         return _Erase(_Keyval);

	xor	eax, eax

; 1137 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBJ@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
;	COMDAT ??1?$lock_guard@Vmutex@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$lock_guard@Vmutex@std@@@std@@QEAA@XZ PROC		; std::lock_guard<std::mutex>::~lock_guard<std::mutex>, COMDAT

; 71   :         _Mtx_unlock(_Mymtx());

	mov	rcx, QWORD PTR [rcx]
	jmp	_Mtx_unlock
??1?$lock_guard@Vmutex@std@@@std@@QEAA@XZ ENDP		; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\mutex
;	COMDAT ??0?$lock_guard@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z
_TEXT	SEGMENT
this$ = 48
_Mtx$ = 56
??0?$lock_guard@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z PROC ; std::lock_guard<std::mutex>::lock_guard<std::mutex>, COMDAT

; 457  :     explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) { // construct and lock

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rdx

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	mov	rcx, rdx

; 457  :     explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) { // construct and lock

	mov	rbx, rdx

; 52   :         if (_Mtx_lock(_Mymtx()) != _Thrd_result::_Success) {

	call	_Mtx_lock
	test	eax, eax
	jne	SHORT $LN17@lock_guard

; 78   :         if (_Mtx_storage._Count == INT_MAX) {

	mov	eax, DWORD PTR [rbx+76]
	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN18@lock_guard

; 458  :         _MyMutex.lock();
; 459  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN18@lock_guard:

; 80   :             --_Mtx_storage._Count;

	dec	eax

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	mov	ecx, 6

; 80   :             --_Mtx_storage._Count;

	mov	DWORD PTR [rbx+76], eax

; 61   :             _STD _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN17@lock_guard:

; 53   :             // undefined behavior, only occurs for plain mutexes (N4950 [thread.mutex.requirements.mutex.general]/6)
; 54   :             _STD _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	ecx, 5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
	int	3
$LN15@lock_guard:
??0?$lock_guard@Vmutex@std@@@std@@QEAA@AEAVmutex@1@@Z ENDP ; std::lock_guard<std::mutex>::lock_guard<std::mutex>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??0?$uniform_int_distribution@J@std@@QEAA@JJ@Z
_TEXT	SEGMENT
this$ = 8
_Min0$dead$ = 16
_Max0$dead$ = 24
??0?$uniform_int_distribution@J@std@@QEAA@JJ@Z PROC	; std::uniform_int_distribution<long>::uniform_int_distribution<long>, COMDAT

; 2118 :             _Min = _Min0;

	mov	DWORD PTR [rcx], 1

; 2251 :         : _Mybase(_Min0, _Max0) {}

	mov	rax, rcx

; 2119 :             _Max = _Max0;

	mov	DWORD PTR [rcx+4], 10400		; 000028a0H

; 2251 :         : _Mybase(_Min0, _Max0) {}

	ret	0
??0?$uniform_int_distribution@J@std@@QEAA@JJ@Z ENDP	; std::uniform_int_distribution<long>::uniform_int_distribution<long>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@XZ PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>, COMDAT

; 1172 :         _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;

	mov	eax, 5489				; 00001571H

; 1161 :         : _Dxval(_Dxarg) {

	mov	DWORD PTR [rcx+4996], -1		; ffffffffH

; 1172 :         _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;

	mov	DWORD PTR [rcx+4], eax

; 1161 :         : _Dxval(_Dxarg) {

	lea	r9, QWORD PTR [rcx+8]
	mov	r8d, 1
	npad	4
$LL12@mersenne_t:

; 1174 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	edx, eax
	lea	r9, QWORD PTR [r9+4]
	shr	edx, 30
	xor	edx, eax
	imul	eax, edx, 1812433253			; 6c078965H
	add	eax, r8d
	inc	r8
	mov	DWORD PTR [r9-4], eax
	cmp	r8, 624					; 00000270H
	jb	SHORT $LL12@mersenne_t

; 1175 :         }
; 1176 : 
; 1177 :         this->_Idx = _Nx;

	mov	DWORD PTR [rcx], 624			; 00000270H

; 1341 :     mersenne_twister_engine() : _Mybase(default_seed, _Dx, _Fx) {}

	mov	rax, rcx
	ret	0
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAA@XZ ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?decrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z
_TEXT	SEGMENT
this$ = 8
block$ = 16
?decrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z PROC	; Cipher::Aes<256>::decrypt_block, COMDAT

; 772  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 773  :             // load the current block & current round key into the registers
; 774  :             __m128i* xmm_round_keys = ( __m128i* ) round_keys;
; 775  :             __m128i state = _mm_loadu_si128(( __m128i* ) & block[0]);
; 776  : 
; 777  :             // first round
; 778  :             state = _mm_xor_si128(state, xmm_round_keys[Nr]);

	movdqu	xmm0, XMMWORD PTR [rdx]
	lea	rax, QWORD PTR [rcx+208]
	mov	r8d, 6
	movdqu	xmm2, XMMWORD PTR [rcx+224]
	xorps	xmm2, xmm0
	npad	4
$LL4@decrypt_bl:

; 779  : 
; 780  :             // usual rounds
; 781  :             for ( size_t i = Nr - 1; i > 1; i -= 2 ) {
; 782  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i]));

	aesimc	xmm0, XMMWORD PTR [rax]

; 783  :                 state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[i - 1]));

	aesimc	xmm1, XMMWORD PTR [rax-16]
	lea	rax, QWORD PTR [rax-32]
	aesdec	xmm2, xmm0
	aesdec	xmm2, xmm1
	sub	r8, 1
	jne	SHORT $LL4@decrypt_bl

; 784  :             }
; 785  : 
; 786  :             // last round
; 787  :             state = _mm_aesdec_si128(state, _mm_aesimc_si128(xmm_round_keys[1]));

	aesimc	xmm0, XMMWORD PTR [rcx+16]
	aesdec	xmm2, xmm0

; 788  :             state = _mm_aesdeclast_si128(state, xmm_round_keys[0]);

	aesdeclast xmm2, XMMWORD PTR [rcx]

; 789  : 
; 790  :             // store from register to array
; 791  :             _mm_storeu_si128(( __m128i* ) block, state);

	movdqu	XMMWORD PTR [rdx], xmm2

; 792  : #elif defined(HARDWARE_ACCELERATION_ARM_NEON_AES)
; 793  :             uint8x16_t* neon_round_keys = ( uint8x16_t* ) round_keys;
; 794  :             uint8x16_t state = vld1q_u8(block);
; 795  : 
; 796  :             // Initial round
; 797  :             state = vaesimcq_u8(vaesdq_u8(state, neon_round_keys[Nr]));
; 798  : 
; 799  :             // 8 main rounds
; 800  :             for ( size_t i = Nr - 1; i > 1; i -= 2 ) {
; 801  :                 state = vaesimcq_u8(vaesdq_u8(state, vaesimcq_u8(neon_round_keys[i])));
; 802  :                 state = vaesimcq_u8(vaesdq_u8(state, vaesimcq_u8(neon_round_keys[i - 1])));
; 803  :             }
; 804  : 
; 805  :             // final 2 rounds
; 806  :             state = vaesdq_u8(state, vaesimcq_u8(neon_round_keys[1]));
; 807  :             state = veorq_u8(state, neon_round_keys[0]);
; 808  : 
; 809  :             // store the result to recover
; 810  :             vst1q_u8(block, state);
; 811  : #else
; 812  :             state_transpose(block);
; 813  : 
; 814  :             add_round_key(block, &round_keys[Nb * Nr * 4]);
; 815  : 
; 816  :             for ( size_t round = Nr - 1; round > 0; --round ) {
; 817  :                 inverse_sub_bytes(block);
; 818  :                 inverse_shift_rows(block);
; 819  :                 add_round_key(block, &round_keys[round * Nb * 4]);
; 820  :                 inverse_mix_columns(block);
; 821  :             }
; 822  : 
; 823  :             inverse_sub_bytes(block);
; 824  :             inverse_shift_rows(block);
; 825  :             add_round_key(block, &round_keys[0]);
; 826  : 
; 827  :             state_transpose(block);
; 828  : #endif
; 829  :         }

	ret	0
?decrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z ENDP	; Cipher::Aes<256>::decrypt_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 677  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN111:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 677  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	r14, rdx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 677  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rsi, rcx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 678  :         const auto& _Right_data = _Right._Mypair._Myval2;
; 679  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]

; 2069 :         if (_Count != 0) {

	je	SHORT $LN72@vector

; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbx, rax
	ja	SHORT $LN108@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN25@vector

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN109@vector

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN35@vector

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN22@vector
$LN25@vector:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN22@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rsi], rdi

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rdi+rbx]
	mov	QWORD PTR [rsi+8], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	mov	QWORD PTR [rsi+16], rax

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1804 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rcx
$LN72@vector:

; 681  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN35@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN108@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN109@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN106@vector:
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2499 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	xorps	xmm0, xmm0

; 2500 :         _Construct_empty();
; 2501 :     }

	mov	rax, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 2500 :         _Construct_empty();
; 2501 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??0?$uniform_int@J@std@@QEAA@JJ@Z
_TEXT	SEGMENT
this$ = 8
_Min0$dead$ = 16
_Max0$dead$ = 24
??0?$uniform_int@J@std@@QEAA@JJ@Z PROC			; std::uniform_int<long>::uniform_int<long>, COMDAT

; 2118 :             _Min = _Min0;

	mov	DWORD PTR [rcx], 1

; 2128 :     explicit uniform_int(_Ty _Min0, _Ty _Max0 = 9) noexcept : _Par(_Min0, _Max0) {}

	mov	rax, rcx

; 2119 :             _Max = _Max0;

	mov	DWORD PTR [rcx+4], 10400		; 000028a0H

; 2128 :     explicit uniform_int(_Ty _Min0, _Ty _Max0 = 9) noexcept : _Par(_Min0, _Max0) {}

	ret	0
??0?$uniform_int@J@std@@QEAA@JJ@Z ENDP			; std::uniform_int<long>::uniform_int<long>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z
_TEXT	SEGMENT
this$ = 8
_Xx0$dead$ = 16
_Dxarg$dead$ = 24
_Fxarg$dead$ = 32
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>, COMDAT

; 1172 :         _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;

	mov	r8d, 5489				; 00001571H

; 1161 :         : _Dxval(_Dxarg) {

	mov	DWORD PTR [rcx+4996], -1		; ffffffffH

; 1172 :         _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;

	mov	DWORD PTR [rcx+4], r8d

; 1161 :         : _Dxval(_Dxarg) {

	lea	r9, QWORD PTR [rcx+8]
	mov	edx, 1
	npad	3
$LL10@mersenne_t:

; 1174 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	eax, r8d
	lea	r9, QWORD PTR [r9+4]
	shr	eax, 30
	xor	eax, r8d
	imul	r8d, eax, 1812433253			; 6c078965H
	add	r8d, edx
	inc	rdx
	mov	DWORD PTR [r9-4], r8d
	cmp	rdx, 624				; 00000270H
	jb	SHORT $LL10@mersenne_t

; 1175 :         }
; 1176 : 
; 1177 :         this->_Idx = _Nx;

	mov	DWORD PTR [rcx], 624			; 00000270H

; 1162 :         seed(_Xx0, _Fxarg);
; 1163 :     }

	mov	rax, rcx
	ret	0
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAA@III@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction, COMDAT

; 718  :         return _Al;

	mov	rax, rcx

; 719  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 2647 :         auto& _My_data = _Mypair._Myval2;
; 2648 :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2649 : 
; 2650 :         // initialize basic_string data members
; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 2657 :     }

	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 64
_Cells$ = 72
_Val$ = 80
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::_Assign_grow, COMDAT

; 284  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN103:
	push	rbx
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 270  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	r9, QWORD PTR [rcx+8]

; 284  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

	mov	r14, rcx
	mov	rbx, r8

; 270  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	rcx, r9
	sub	rcx, r8
	mov	rax, rcx
	sar	rax, 3

; 285  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 286  :         const auto _Oldsize = size();
; 287  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 288  :         auto& _Alvec = _Mypair._Get_first();
; 289  :         if (_Oldsize < _Cells) {

	cmp	rax, rdx
	jae	$LN2@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR [rsp+80], rsi
	cmp	rdx, rax
	ja	$LN86@Assign_gro

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rsi, QWORD PTR [rdx*8]

; 196  :     if (_Bytes == 0) {

	test	rsi, rsi
	jne	SHORT $LN16@Assign_gro

; 197  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN15@Assign_gro
$LN16@Assign_gro:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN18@Assign_gro

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN86@Assign_gro

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN55@Assign_gro

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN15@Assign_gro
$LN18@Assign_gro:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN15@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3

; 290  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws
; 291  :             // nothrow hereafter
; 292  :             const auto _Oldcapacity = capacity();
; 293  :             if (_Oldcapacity != 0) {

	test	rax, rax
	je	SHORT $LN44@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN58@Assign_gro

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN55@Assign_gro

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN58@Assign_gro:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN44@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 299  :             const auto _Newend       = _Newvec + _Cells;

	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR [r14], rdi

; 300  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	QWORD PTR [r14+8], rax

; 301  :             _Mypair._Myval2._Myend   = _Newend;

	mov	QWORD PTR [r14+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1583 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rdi, rax

; 1980 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN99@Assign_gro
	npad	9
$LL62@Assign_gro:

; 1597 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	QWORD PTR [rdi], rbx

; 1598 :         ++_Last;

	add	rdi, 8

; 1980 :         while (_Backout._Last != _ULast) {

	cmp	rdi, rax
	jne	SHORT $LL62@Assign_gro
$LN99@Assign_gro:
	mov	rsi, QWORD PTR [rsp+80]
$LN73@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 306  :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
$LN2@Assign_gro:

; 304  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	add	rcx, 7
	xor	edi, edi
	shr	rcx, 3
	cmp	r8, r9
	cmova	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 5163 :         for (; _UFirst != _ULast; ++_UFirst) {

	test	rcx, rcx
	je	SHORT $LN73@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 304  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	mov	rdi, r8
	mov	rax, rbx
	rep stosq

; 306  :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
$LN86@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN55@Assign_gro:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN100@Assign_gro:
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::capacity, COMDAT

; 279  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 280  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 281  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 282  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 951  :     }

	add	rsp, 40					; 00000028H

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Getal, COMDAT

; 1850 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1851 :     }

	ret	0
?_Getal@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_end, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1116 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	mov	rax, rdx

; 1117 :     }

	ret	0
?_Unchecked_end@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??0param_type@?$uniform_int@J@std@@QEAA@JJ@Z
_TEXT	SEGMENT
this$ = 8
_Min0$dead$ = 16
_Max0$dead$ = 24
??0param_type@?$uniform_int@J@std@@QEAA@JJ@Z PROC	; std::uniform_int<long>::param_type::param_type, COMDAT

; 2118 :             _Min = _Min0;

	mov	DWORD PTR [rcx], 1

; 2093 :             _Init(_Min0, _Max0);
; 2094 :         }

	mov	rax, rcx

; 2119 :             _Max = _Max0;

	mov	DWORD PTR [rcx+4], 10400		; 000028a0H

; 2093 :             _Init(_Min0, _Max0);
; 2094 :         }

	ret	0
??0param_type@?$uniform_int@J@std@@QEAA@JJ@Z ENDP	; std::uniform_int<long>::param_type::param_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z
_TEXT	SEGMENT
this$ = 8
_Xx0$dead$ = 16
_Fx$dead$ = 24
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed, COMDAT

; 1171 :         // set initial values from specified value
; 1172 :         _Ty _Prev = this->_Ax[0] = _Xx0 & _WMSK;

	mov	edx, 5489				; 00001571H
	lea	r9, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx+4], edx
	mov	r8d, 1
$LL8@seed:

; 1173 :         for (size_t _Ix = 1; _Ix < _Nx; ++_Ix) {
; 1174 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	eax, edx
	lea	r9, QWORD PTR [r9+4]
	shr	eax, 30
	xor	eax, edx
	imul	edx, eax, 1812433253			; 6c078965H
	add	edx, r8d
	inc	r8
	mov	DWORD PTR [r9-4], edx
	cmp	r8, 624					; 00000270H
	jb	SHORT $LL8@seed

; 1175 :         }
; 1176 : 
; 1177 :         this->_Idx = _Nx;

	mov	DWORD PTR [rcx], 624			; 00000270H

; 1178 :     }

	ret	0
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAXII@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx

; 38   :         this->_Adopt(_Plist);
; 39   :     }

	mov	rax, rcx
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::size, COMDAT

; 270  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 271  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::allocate, COMDAT

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN34:
	sub	rsp, 40					; 00000028H

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN30@allocate

; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN8@allocate

; 197  :         return nullptr;

	xor	eax, eax

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@allocate:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN10@allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN30@allocate

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@allocate:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN30@allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN20@allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN32@allocate:
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ?_Init@param_type@?$uniform_int@J@std@@QEAAXJJ@Z
_TEXT	SEGMENT
this$ = 8
_Min0$dead$ = 16
_Max0$dead$ = 24
?_Init@param_type@?$uniform_int@J@std@@QEAAXJJ@Z PROC	; std::uniform_int<long>::param_type::_Init, COMDAT

; 2117 :             _STL_ASSERT(_Min0 <= _Max0, "invalid min and max arguments for uniform_int");
; 2118 :             _Min = _Min0;

	mov	DWORD PTR [rcx], 1

; 2119 :             _Max = _Max0;

	mov	DWORD PTR [rcx+4], 10400		; 000028a0H

; 2120 :         }

	ret	0
?_Init@param_type@?$uniform_int@J@std@@QEAAXJJ@Z ENDP	; std::uniform_int<long>::param_type::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >::allocate, COMDAT

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	ecx, 288				; 00000120H
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int_distribution@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Eng$ = 56
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int_distribution@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z PROC ; std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT

; 2283 :     _NODISCARD result_type operator()(_Engine& _Eng) _DISTRIBUTION_CONST {

$LN78:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	sub	rsp, 32					; 00000020H

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	mov	ebp, DWORD PTR [rcx]

; 2283 :     _NODISCARD result_type operator()(_Engine& _Eng) _DISTRIBUTION_CONST {

	mov	rbx, rdx

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	mov	eax, DWORD PTR [rcx+4]
	btc	ebp, 31
	btc	eax, 31

; 2203 :         if (_Umax - _Umin == static_cast<_Uty>(-1)) {

	mov	rcx, rdx
	sub	eax, ebp
	cmp	eax, -1					; ffffffffH
	jne	SHORT $LN6@operator

; 1417 :         return _Mybase::operator()();

	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2209 :         return static_cast<_Ty>(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [rax+rbp]

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	xor	eax, -2147483648			; ffffffff80000000H

; 2284 :         return _Mybase::operator()(_Eng);
; 2285 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
$LN6@operator:
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+56], rdi

; 2206 :             _Uret = static_cast<_Uty>(_Generator(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	edi, DWORD PTR [rax+1]

; 1417 :         return _Mybase::operator()();

	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	ecx, eax
	mov	esi, edi
	imul	rcx, rsi

; 1999 :         if (_Rem < _Index) {

	cmp	ecx, edi
	jae	SHORT $LN30@operator

; 2000 :             // t <- (2^L - s) mod s
; 2001 :             const auto _Threshold = (_Mask - _Index + 1) % _Index;

	mov	eax, edi
	xor	edx, edx
	neg	eax
	div	edi
	mov	edi, edx

; 2002 :             while (_Rem < _Threshold) {

	cmp	ecx, edx
	jae	SHORT $LN30@operator
$LL29@operator:

; 1417 :         return _Mybase::operator()();

	mov	rcx, rbx
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	ecx, eax
	imul	rcx, rsi

; 2002 :             while (_Rem < _Threshold) {

	cmp	ecx, edi
	jb	SHORT $LL29@operator
$LN30@operator:

; 2003 :                 _Product = _Get_random_product(_Index, _Niter);
; 2004 :                 _Rem     = static_cast<_Udiff>(_Product) & _Mask;
; 2005 :             }
; 2006 :         }
; 2007 : 
; 2008 :         unsigned int _Generated_bits;
; 2009 :         if constexpr (_Bits < _Udiff_bits) {
; 2010 :             _Generated_bits = static_cast<unsigned int>(_Popcount(_Mask));
; 2011 :         } else {
; 2012 :             _Generated_bits = _Udiff_bits;
; 2013 :         }
; 2014 : 
; 2015 :         // m / 2^L
; 2016 :         return static_cast<_Diff>(_Product >> _Generated_bits);

	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+48]

; 2284 :         return _Mybase::operator()(_Eng);
; 2285 :     }

	mov	rbx, QWORD PTR [rsp+64]

; 2016 :         return static_cast<_Diff>(_Product >> _Generated_bits);

	shr	rcx, 32					; 00000020H

; 2209 :         return static_cast<_Ty>(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [rcx+rbp]

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	xor	eax, -2147483648			; ffffffff80000000H

; 2284 :         return _Mybase::operator()(_Eng);
; 2285 :     }

	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int_distribution@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ENDP ; std::uniform_int_distribution<long>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Erase<long>, COMDAT

; 1102 :     size_type _Erase(const _Keytype& _Keyval) noexcept(_Noexcept_heterogeneous_erasure<_Keytype>()) /* strengthened */ {

$LN148:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1102 :     size_type _Erase(const _Keytype& _Keyval) noexcept(_Noexcept_heterogeneous_erasure<_Keytype>()) /* strengthened */ {

	mov	r9, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1102 :     size_type _Erase(const _Keytype& _Keyval) noexcept(_Noexcept_heterogeneous_erasure<_Keytype>()) /* strengthened */ {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]

; 2302 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rdx, QWORD PTR [r9+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	imul	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	and	rdx, r8

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r8, QWORD PTR [r9+8]
	shl	rdx, 4
	add	rdx, QWORD PTR [r9+24]
	mov	r11, QWORD PTR [rdx+8]
	mov	rbx, r11

; 1567 :         if (_Where == _End) {

	cmp	r11, r8
	je	SHORT $LN129@Erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	mov	eax, DWORD PTR [r10]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	eax, DWORD PTR [r11+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN128@Erase
$LL27@Erase:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};
; 1582 :             }
; 1583 : 
; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rcx
	je	SHORT $LN129@Erase

; 1585 :                 return {_Where, _Nodeptr{}};
; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	eax, DWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL27@Erase
	jmp	SHORT $LN128@Erase
$LN129@Erase:

; 1103 :         const size_t _Hashval = _Traitsobj(_Keyval);
; 1104 :         if constexpr (_Multi) {
; 1105 :             const auto _Where = _Equal_range(_Keyval, _Hashval);
; 1106 :             _Unchecked_erase(_Where._First._Ptr, _Where._Last._Ptr);
; 1107 :             return _Where._Distance;
; 1108 :         } else {
; 1109 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	xor	ebx, ebx
$LN128@Erase:
	test	rbx, rbx

; 1110 :             if (_Target) {

	je	SHORT $LN2@Erase

; 1665 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rdx]

; 1110 :             if (_Target) {

	mov	QWORD PTR [rsp+64], rdi

; 1665 :         if (_Bucket_hi == _Plist) {

	cmp	r11, rbx
	jne	SHORT $LN41@Erase

; 1666 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rbx
	jne	SHORT $LN43@Erase

; 1667 :                 const auto _End = _List._Mypair._Myval2._Myhead;
; 1668 : 
; 1669 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rdx], r8

; 1673 :             }

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN45@Erase
$LN43@Erase:

; 1670 :                 _Bucket_hi = _End;
; 1671 :             } else {
; 1672 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	r8, QWORD PTR [rbx+8]

; 1673 :             }

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN45@Erase
$LN41@Erase:

; 1674 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rbx
	jne	SHORT $LN45@Erase

; 1675 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdx], rax
$LN45@Erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1423 :         const auto _Result = _Pnode->_Next;

	mov	rcx, QWORD PTR [rbx]

; 1424 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1425 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR [r9+16]

; 1426 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax], rcx

; 1427 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rcx+8], rax
	lea	rcx, QWORD PTR [rbx+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rbx+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1113 :                 return 1;

	mov	rdi, QWORD PTR [rsp+64]
	mov	eax, 1

; 1117 :         }
; 1118 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Erase:

; 1114 :             }
; 1115 : 
; 1116 :             return 0;

	xor	eax, eax

; 1117 :         }
; 1118 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Erase@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAA_KAEBJ@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Erase<long>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$?RJ@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBA_KAEBJ@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval$ = 16
??$?RJ@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBA_KAEBJ@Z PROC ; std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >::operator()<long>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rdx+2]

; 2302 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	movzx	r8d, BYTE PTR [rdx]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+3]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 146  :     }

	ret	0
??$?RJ@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBA_KAEBJ@Z ENDP ; std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >::operator()<long>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ PROC ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>, COMDAT

; 345  :         : _Mybase(), _Myfirst() {}

$LN177:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2651 :         _My_data._Mysize = 0;

	xor	edi, edi
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 345  :         : _Mybase(), _Myfirst() {}

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 140  :     constexpr _Tuple_val() : _Val() {}

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 140  :     constexpr _Tuple_val() : _Val() {}

	mov	r8d, 184				; 000000b8H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+48], rdi

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+56], 15

; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+32], dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 140  :     constexpr _Tuple_val() : _Val() {}

	add	rcx, 80					; 00000050H
	call	memset
	xorps	xmm0, xmm0

; 345  :         : _Mybase(), _Myfirst() {}

	mov	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+64], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+80], rdi

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+88], 15

; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+64], dil

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+100], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+116], rdi

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+124], 15

; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+100], dil
	mov	DWORD PTR [rbx+132], -1

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+140], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+156], rdi

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+164], 15

; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+140], dil
	mov	DWORD PTR [rbx+172], -1
	mov	QWORD PTR [rbx+180], -1
	mov	QWORD PTR [rbx+188], -1

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+196], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+212], rdi

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+220], 15

; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+196], dil

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+228], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+244], rdi

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+252], 15

; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+228], dil
	mov	DWORD PTR [rbx+260], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 345  :         : _Mybase(), _Myfirst() {}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ENDP ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$get@$0A@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@YAAEAVClient@@AEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$get@$0A@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@YAAEAVClient@@AEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@@Z PROC ; std::get<0,Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 933  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 934  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

	lea	rax, QWORD PTR [rcx+64]

; 935  : }

	ret	0
??$get@$0A@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@YAAEAVClient@@AEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@@Z ENDP ; std::get<0,Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
<_Args_0>$ = 72
<_Args_1>$ = 80
<_Args_2>$ = 88
??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z PROC ; std::make_tuple<Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1001 : _NODISCARD constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { // make tuple from elements

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, r9
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	lea	rcx, QWORD PTR [rsi+32]

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	lea	rcx, QWORD PTR [rsi+64]

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, rdi
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1

; 1002 :     using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
; 1003 :     return _Ttype(_STD forward<_Types>(_Args)...);

	mov	rax, rsi

; 1004 : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z ENDP ; std::make_tuple<Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$ = 64
<_Args_0>$ = 72
<_Args_1>$ = 80
<_Args_2>$ = 88
?dtor$4@?0???$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z@4HA PROC ; `std::make_tuple<Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$4
	mov	rcx, QWORD PTR __$ReturnUdt$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$4@?0???$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z@4HA ENDP ; `std::make_tuple<Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$ = 64
<_Args_0>$ = 72
<_Args_1>$ = 80
<_Args_2>$ = 88
?dtor$2@?0???$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z@4HA PROC ; `std::make_tuple<Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$2
	mov	rcx, QWORD PTR __$ReturnUdt$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
?dtor$2@?0???$make_tuple@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV23@@std@@YA?AV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z@4HA ENDP ; `std::make_tuple<Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?4V?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??$?4V?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,Client,0>, COMDAT

; 585  :         conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r14, rdx
	mov	r15, rcx
	add	rdx, 64					; 00000040H
	add	rcx, 64					; 00000040H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR [r14+96]
	lea	rdx, QWORD PTR [r14+100]
	lea	rcx, QWORD PTR [r15+100]
	mov	DWORD PTR [r15+96], eax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR [r14+132]
	lea	rdx, QWORD PTR [r14+140]
	mov	DWORD PTR [r15+132], eax
	lea	rcx, QWORD PTR [r15+140]
	mov	eax, DWORD PTR [r14+136]
	mov	DWORD PTR [r15+136], eax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR [r14+172]
	lea	rdx, QWORD PTR [r14+196]
	mov	DWORD PTR [r15+172], eax
	lea	rcx, QWORD PTR [r15+196]
	mov	eax, DWORD PTR [r14+176]
	mov	DWORD PTR [r15+176], eax
	mov	rax, QWORD PTR [r14+180]
	mov	QWORD PTR [r15+180], rax
	mov	rax, QWORD PTR [r14+188]
	mov	QWORD PTR [r15+188], rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	rdx, QWORD PTR [r14+228]
	lea	rcx, QWORD PTR [r15+228]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR [r14+260]

; 586  :         _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);

	lea	rdx, QWORD PTR [r14+32]
	lea	rcx, QWORD PTR [r15+32]
	mov	DWORD PTR [r15+260], eax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	rdx, r14
	mov	rcx, r15
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 587  :         _Get_rest()   = _STD forward<_Mybase>(_Right._Get_rest());
; 588  :         return *this;
; 589  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, r15
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
??$?4V?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,Client,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4Client@@QEAAAEAV0@$$QEAV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4Client@@QEAAAEAV0@$$QEAV0@@Z PROC			; Client::operator=, COMDAT
$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbp, rcx
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR [rsi+32]
	lea	rdx, QWORD PTR [rsi+36]
	lea	rcx, QWORD PTR [rbp+36]
	mov	DWORD PTR [rbp+32], eax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR [rsi+68]
	lea	rdx, QWORD PTR [rsi+76]
	mov	DWORD PTR [rbp+68], eax
	lea	rcx, QWORD PTR [rbp+76]
	mov	eax, DWORD PTR [rsi+72]
	mov	DWORD PTR [rbp+72], eax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR [rsi+108]
	lea	rdx, QWORD PTR [rsi+132]
	mov	DWORD PTR [rbp+108], eax
	lea	rcx, QWORD PTR [rbp+132]
	mov	eax, DWORD PTR [rsi+112]
	mov	DWORD PTR [rbp+112], eax
	mov	rax, QWORD PTR [rsi+116]
	mov	QWORD PTR [rbp+116], rax
	mov	rax, QWORD PTR [rsi+124]
	mov	QWORD PTR [rbp+124], rax
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	rdx, QWORD PTR [rsi+164]
	lea	rcx, QWORD PTR [rbp+164]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR [rsi+196]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]
	mov	DWORD PTR [rbp+196], eax
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4Client@@QEAAAEAV0@$$QEAV0@@Z ENDP			; Client::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4ClientResponse@@QEAAAEAU0@$$QEAU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4ClientResponse@@QEAAAEAU0@$$QEAU0@@Z PROC		; ClientResponse::operator=, COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR [rdi+32], eax
	mov	eax, DWORD PTR [rbx+36]
	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi+36], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4ClientResponse@@QEAAAEAU0@$$QEAU0@@Z ENDP		; ClientResponse::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
$T6 = 128
decrypted$ = 128
decryptionKey$ = 176
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 560
__$ReturnUdt$ = 568
cipher$ = 576
cuid$ = 584
??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z PROC ; ServerInterface::DecryptClientData<ClientRequest>, COMDAT

; 147  : Data ServerInterface::DecryptClientData(BYTESTRING cipher, long cuid) {

$LN405:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-248]
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14d, r9d
	mov	rdi, r8
	mov	rbx, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	mov	QWORD PTR cipher$GSCopy$[rsp], r8
	xor	r15d, r15d

; 148  : 	if ( !ClientIsInClientList(cuid) )

	mov	edx, r9d
	call	?ClientIsInClientList@ServerInterface@@QEAAHJ@Z ; ServerInterface::ClientIsInClientList
	test	eax, eax
	jne	SHORT $LN2@DecryptCli
	xorps	xmm0, xmm0

; 149  : 		return {};

	movups	XMMWORD PTR [rbx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+16], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], r15

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], al
	jmp	$LN401@DecryptCli
$LN2@DecryptCli:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 151  : 	ClientData  clientInfo    = GetClientData(cuid);

	mov	r8d, r14d
	lea	rdx, QWORD PTR clientInfo$[rbp-256]
	mov	rcx, rsi
	call	?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z ; ServerInterface::GetClientData
	npad	1

; 152  : 	std::string decryptionKey = std::get<AES_KEY>(clientInfo);

	lea	rdx, QWORD PTR clientInfo$[rbp-224]
	lea	rcx, QWORD PTR decryptionKey$[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 153  : 	Data        decrypted     = NetCommon::DecryptInternetData<Data>(cipher, decryptionKey);

	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR decryptionKey$[rbp-256]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rsi, rax
	mov	QWORD PTR $T3[rsp], rax
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	r14, rax
	mov	QWORD PTR $T2[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 96   :         DecryptByteString(string, aesKey);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptByteString

; 97   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rdx, QWORD PTR [r14]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR decrypted$[rbp-256], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR decrypted$[rbp-252], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR decrypted$[rbp-248], rax
	add	rdx, 16
	lea	rcx, QWORD PTR decrypted$[rbp-240]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r14]
	test	rcx, rcx
	je	SHORT $LN76@DecryptCli

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [r14+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN95@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN92@DecryptCli

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN95@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [r14], r15

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], r15

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], r15
$LN76@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rsi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN118@DecryptCli

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [rsi]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN132@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN129@DecryptCli

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN132@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN118@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+16], r15

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rsi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], 0
	mov	eax, DWORD PTR decrypted$[rbp-256]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR decrypted$[rbp-252]
	mov	DWORD PTR [rbx+4], eax
	mov	rax, QWORD PTR decrypted$[rbp-248]
	mov	QWORD PTR [rbx+8], rax

; 3083 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR decrypted$[rbp-240]
	movups	XMMWORD PTR [rbx+16], xmm0
	movups	xmm1, XMMWORD PTR decrypted$[rbp-224]
	movups	XMMWORD PTR [rbx+32], xmm1

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR decryptionKey$[rbp-232]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN237@DecryptCli

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR decryptionKey$[rbp-256]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN251@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN403@DecryptCli
$LN251@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN237@DecryptCli:
	lea	rcx, QWORD PTR clientInfo$[rbp-192]
	call	??1Client@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rbp-200]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN294@DecryptCli

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rbp-224]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN308@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN354@DecryptCli
$LN308@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN294@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR clientInfo$[rbp-208], xmm0

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR clientInfo$[rbp-224], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rbp-232]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN343@DecryptCli

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rbp-256]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN357@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN354@DecryptCli
$LN357@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
$LN343@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	XMMWORD PTR clientInfo$[rbp-240], xmm0

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR clientInfo$[rbp-256], 0
$LN401@DecryptCli:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 155  : 	return decrypted;

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN370@DecryptCli
	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN389@DecryptCli
	add	rdx, 39					; 00000027H
	mov	r8, QWORD PTR [rcx-8]
	sub	rcx, r8
	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN386@DecryptCli
	mov	rcx, r8
$LN389@DecryptCli:
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	QWORD PTR [rdi], r15
	mov	QWORD PTR [rdi+8], r15
	mov	QWORD PTR [rdi+16], r15
$LN370@DecryptCli:
	mov	rax, rbx

; 156  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN354@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN386@DecryptCli:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN403@DecryptCli:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN92@DecryptCli:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN129@DecryptCli:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN400@DecryptCli:
??$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z ENDP ; ServerInterface::DecryptClientData<ClientRequest>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
$T6 = 128
decrypted$ = 128
decryptionKey$ = 176
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 560
__$ReturnUdt$ = 568
cipher$ = 576
cuid$ = 584
?dtor$0@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$0
	mov	rcx, QWORD PTR cipher$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
$T6 = 128
decrypted$ = 128
decryptionKey$ = 176
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 560
__$ReturnUdt$ = 568
cipher$ = 576
cuid$ = 584
?dtor$3@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$3
	lea	rcx, QWORD PTR clientInfo$[rdx]
	jmp	??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
?dtor$3@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
$T6 = 128
decrypted$ = 128
decryptionKey$ = 176
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 560
__$ReturnUdt$ = 568
cipher$ = 576
cuid$ = 584
?dtor$4@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$4
	lea	rcx, QWORD PTR decryptionKey$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
$T6 = 128
decrypted$ = 128
decryptionKey$ = 176
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 560
__$ReturnUdt$ = 568
cipher$ = 576
cuid$ = 584
?dtor$5@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$5
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
$T6 = 128
decrypted$ = 128
decryptionKey$ = 176
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 560
__$ReturnUdt$ = 568
cipher$ = 576
cuid$ = 584
?dtor$11@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$11
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
$T6 = 128
decrypted$ = 128
decryptionKey$ = 176
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 560
__$ReturnUdt$ = 568
cipher$ = 576
cuid$ = 584
?dtor$12@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$12
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$12@?0???$DecryptClientData@UClientRequest@@@ServerInterface@@IEAA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientRequest>'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp
;	COMDAT ??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
decryptionKey$ = 128
$T6 = 160
decrypted$ = 160
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 576
__$ReturnUdt$ = 584
cipher$ = 592
cuid$ = 600
??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z PROC ; ServerInterface::DecryptClientData<ClientResponse>, COMDAT

; 147  : Data ServerInterface::DecryptClientData(BYTESTRING cipher, long cuid) {

$LN405:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-248]
	sub	rsp, 504				; 000001f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14d, r9d
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	mov	QWORD PTR cipher$GSCopy$[rsp], r8
	xor	r13d, r13d

; 148  : 	if ( !ClientIsInClientList(cuid) )

	mov	edx, r9d
	call	?ClientIsInClientList@ServerInterface@@QEAAHJ@Z ; ServerInterface::ClientIsInClientList
	test	eax, eax
	jne	SHORT $LN2@DecryptCli

; 149  : 		return {};

	xor	eax, eax
	mov	DWORD PTR [rdi+36], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdi], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], r13

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], al
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 149  : 		return {};

	mov	DWORD PTR [rdi+32], -1
	jmp	$LN401@DecryptCli
$LN2@DecryptCli:

; 150  : 
; 151  : 	ClientData  clientInfo    = GetClientData(cuid);

	mov	r8d, r14d
	lea	rdx, QWORD PTR clientInfo$[rbp-256]
	mov	rcx, rbx
	call	?GetClientData@ServerInterface@@QEAA?BV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@J@Z ; ServerInterface::GetClientData
	npad	1

; 152  : 	std::string decryptionKey = std::get<AES_KEY>(clientInfo);

	lea	rdx, QWORD PTR clientInfo$[rbp-224]
	lea	rcx, QWORD PTR decryptionKey$[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 153  : 	Data        decrypted     = NetCommon::DecryptInternetData<Data>(cipher, decryptionKey);

	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR decryptionKey$[rbp-256]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r14, rax
	mov	QWORD PTR $T3[rsp], rax
	mov	rdx, rsi
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	r15, rax
	mov	QWORD PTR $T2[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 96   :         DecryptByteString(string, aesKey);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r15
	call	?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptByteString

; 97   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rbx, QWORD PTR [r15]
	mov	rdx, rbx
	lea	rcx, QWORD PTR decrypted$[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r12d, DWORD PTR [rbx+32]
	mov	ebx, DWORD PTR [rbx+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r15]
	test	rcx, rcx
	je	SHORT $LN76@DecryptCli

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [r15+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN95@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN92@DecryptCli

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN95@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [r15], r13

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [r15+8], r13

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [r15+16], r13
$LN76@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [r14+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN118@DecryptCli

; 4869 :             _ASAN_STRING_REMOVE(*this);
; 4870 :             auto& _Al = _Getal();
; 4871 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR [r14]

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN132@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN129@DecryptCli

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN132@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN118@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r14+16], r13

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [r14+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r14], 0

; 3083 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR decrypted$[rbp-256]
	movups	XMMWORD PTR [rdi], xmm0
	movups	xmm1, XMMWORD PTR decrypted$[rbp-240]
	movups	XMMWORD PTR [rdi+16], xmm1
	mov	DWORD PTR [rdi+32], r12d
	mov	DWORD PTR [rdi+36], ebx

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR decryptionKey$[rbp-232]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN237@DecryptCli

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR decryptionKey$[rbp-256]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN251@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN403@DecryptCli
$LN251@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN237@DecryptCli:
	lea	rcx, QWORD PTR clientInfo$[rbp-192]
	call	??1Client@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rbp-200]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN294@DecryptCli

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rbp-224]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN308@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN354@DecryptCli
$LN308@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN294@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR clientInfo$[rbp-208], xmm0

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR clientInfo$[rbp-224], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR clientInfo$[rbp-232]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN343@DecryptCli

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR clientInfo$[rbp-256]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN357@DecryptCli

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN354@DecryptCli
$LN357@DecryptCli:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
$LN343@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	XMMWORD PTR clientInfo$[rbp-240], xmm0

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR clientInfo$[rbp-256], 0
$LN401@DecryptCli:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\server.cpp

; 155  : 	return decrypted;

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN370@DecryptCli
	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN389@DecryptCli
	add	rdx, 39					; 00000027H
	mov	r8, QWORD PTR [rcx-8]
	sub	rcx, r8
	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN386@DecryptCli
	mov	rcx, r8
$LN389@DecryptCli:
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	QWORD PTR [rsi], r13
	mov	QWORD PTR [rsi+8], r13
	mov	QWORD PTR [rsi+16], r13
$LN370@DecryptCli:
	mov	rax, rdi

; 156  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 504				; 000001f8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN354@DecryptCli:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN386@DecryptCli:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN403@DecryptCli:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN92@DecryptCli:
	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN129@DecryptCli:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN400@DecryptCli:
??$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z ENDP ; ServerInterface::DecryptClientData<ClientResponse>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
decryptionKey$ = 128
$T6 = 160
decrypted$ = 160
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 576
__$ReturnUdt$ = 584
cipher$ = 592
cuid$ = 600
?dtor$0@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$0
	mov	rcx, QWORD PTR cipher$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
decryptionKey$ = 128
$T6 = 160
decrypted$ = 160
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 576
__$ReturnUdt$ = 584
cipher$ = 592
cuid$ = 600
?dtor$3@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$3
	lea	rcx, QWORD PTR clientInfo$[rdx]
	jmp	??1?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ
?dtor$3@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
decryptionKey$ = 128
$T6 = 160
decrypted$ = 160
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 576
__$ReturnUdt$ = 584
cipher$ = 592
cuid$ = 600
?dtor$4@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$4
	lea	rcx, QWORD PTR decryptionKey$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
decryptionKey$ = 128
$T6 = 160
decrypted$ = 160
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 576
__$ReturnUdt$ = 584
cipher$ = 592
cuid$ = 600
?dtor$5@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$5
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
decryptionKey$ = 128
$T6 = 160
decrypted$ = 160
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 576
__$ReturnUdt$ = 584
cipher$ = 592
cuid$ = 600
?dtor$11@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$11
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 48
$T3 = 56
$T4 = 64
$T5 = 88
cipher$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
decryptionKey$ = 128
$T6 = 160
decrypted$ = 160
clientInfo$ = 208
__$ArrayPad$ = 480
this$ = 576
__$ReturnUdt$ = 584
cipher$ = 592
cuid$ = 600
?dtor$12@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA PROC ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$12
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$12@?0???$DecryptClientData@UClientResponse@@@ServerInterface@@IEAA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@J@Z@4HA ENDP ; `ServerInterface::DecryptClientData<ClientResponse>'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$_Find_last@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBJ_K@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Keyval$ = 24
_Hashval$ = 32
??$_Find_last@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBJ_K@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Find_last<long>, COMDAT

; 1562 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

	mov	r11, r8

; 1563 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	mov	r8, QWORD PTR [rcx+48]
	and	r8, r9

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r9, QWORD PTR [rcx+8]
	shl	r8, 4
	add	r8, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [r8+8]

; 1567 :         if (_Where == _End) {

	cmp	rax, r9
	jne	SHORT $LN5@Find_last

; 1568 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR [rdx], r9

; 1589 :         }
; 1590 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx+8], 0
	ret	0
$LN5@Find_last:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	mov	ecx, DWORD PTR [r11]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r8, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN17@Find_last
	npad	7
$LL2@Find_last:

; 1582 :             }
; 1583 : 
; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rax, r8
	je	SHORT $LN18@Find_last

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL2@Find_last
$LN17@Find_last:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rdx+8], rax

; 1589 :         }
; 1590 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx
	ret	0
$LN18@Find_last:

; 1585 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR [rdx], rax

; 1589 :         }
; 1590 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx+8], 0
	ret	0
??$_Find_last@J@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBJ_K@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Find_last<long>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z
_TEXT	SEGMENT
$T1 = 32
_Newnode$ = 32
this$ = 112
__$ReturnUdt$ = 120
_Keyval_arg$ = 128
??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Try_emplace<long const &>, COMDAT

; 690  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval_arg, _Mappedty&&... _Mapval) {

$LN245:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rsi, r8
	mov	r14, rdx
	mov	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r13d, BYTE PTR [r8]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r13, rax

; 2302 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	imul	r13, rcx

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+1]
	xor	r13, rax

; 2302 :         _Val *= _FNV_prime;

	imul	r13, rcx

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+2]
	xor	r13, rax

; 2302 :         _Val *= _FNV_prime;

	imul	r13, rcx

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+3]
	xor	r13, rax

; 2302 :         _Val *= _FNV_prime;

	imul	r13, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, r13
	and	rcx, QWORD PTR [rbp+48]

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rax, QWORD PTR [rbp+24]
	mov	rbx, QWORD PTR [rax+rcx*8+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	lea	rdx, QWORD PTR [rbp+8]
	mov	r12, QWORD PTR [rdx]

; 1567 :         if (_Where == _End) {

	cmp	rbx, r12
	jne	SHORT $LN31@Try_emplac

; 1568 :             return {_End, _Nodeptr{}};

	mov	rbx, r12
	mov	r15, r12
	jmp	SHORT $LN2@Try_emplac
$LN31@Try_emplac:

; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rax+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	mov	eax, DWORD PTR [r8]
	cmp	eax, DWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN216@Try_emplac
$LL28@Try_emplac:

; 1582 :             }
; 1583 : 
; 1584 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rcx
	je	SHORT $LN217@Try_emplac

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	eax, DWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL28@Try_emplac
$LN216@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rbx
	mov	BYTE PTR [r14+8], 0
$LN241@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 708  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+136]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN217@Try_emplac:

; 1585 :                 return {_Where, _Nodeptr{}};

	mov	r12, rbx
	mov	r15, rbx
$LN2@Try_emplac:

; 1644 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 64051194700380387			; 00e38e38e38e38e3H
	cmp	QWORD PTR [rbp+16], rax
	je	$LN243@Try_emplac
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1125 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$[rsp], rdx

; 1132 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR _Newnode$[rsp+8], 0

; 1133 :         _Ptr = _Al.allocate(1);

	mov	ecx, 288				; 00000120H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR _Newnode$[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 307  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	eax, DWORD PTR [rsi]
	mov	DWORD PTR [rdi+16], eax
	lea	rcx, QWORD PTR [rdi+24]
	call	??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1650 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rbp+16]

; 1651 :         const auto _Newsize      = _Oldsize + 1;

	add	rcx, 1

; 1652 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN235@Try_emplac
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN236@Try_emplac
$LN235@Try_emplac:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN236@Try_emplac:
	mov	rsi, QWORD PTR [rbp+56]
	movss	xmm3, DWORD PTR [rbp]
	xorps	xmm2, xmm2
	test	rsi, rsi
	js	SHORT $LN233@Try_emplac
	cvtsi2ss xmm2, rsi
	jmp	SHORT $LN234@Try_emplac
$LN233@Try_emplac:
	mov	rcx, rsi
	shr	rcx, 1
	mov	rax, rsi
	and	eax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
$LN234@Try_emplac:
	movaps	xmm1, xmm0
	divss	xmm1, xmm2
	comiss	xmm1, xmm3

; 691  :         const auto& _Keyval = _Keyval_arg;
; 692  :         const auto _Hashval = _Traitsobj(_Keyval);
; 693  :         auto _Target        = _Find_last(_Keyval, _Hashval);
; 694  :         if (_Target._Duplicate) {
; 695  :             return {_Target._Duplicate, false};
; 696  :         }
; 697  : 
; 698  :         _Check_max_size();
; 699  :         _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), piecewise_construct,
; 700  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval_arg)),
; 701  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...));
; 702  :         if (_Check_rehash_required_1()) {

	jbe	$LN3@Try_emplac

; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	divss	xmm0, xmm3
	call	ceilf
	xor	ecx, ecx
	movss	xmm1, DWORD PTR __real@5f000000
	comiss	xmm0, xmm1
	jb	SHORT $LN232@Try_emplac
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN232@Try_emplac
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN232@Try_emplac:
	cvttss2si rax, xmm0
	add	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1687 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rsi, rcx
	jae	SHORT $LN184@Try_emplac

; 1688 :             // we already have enough buckets so there's no need to change the count
; 1689 :             return _Old_buckets;
; 1690 :         }
; 1691 : 
; 1692 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rsi, 512				; 00000200H
	jae	SHORT $LN186@Try_emplac
	lea	rsi, QWORD PTR [rsi*8]
	cmp	rsi, rcx
	jae	SHORT $LN184@Try_emplac
$LN186@Try_emplac:

; 1693 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1694 :             return _Old_buckets * 8;
; 1695 :         }
; 1696 : 
; 1697 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1698 :         return _Req_buckets;

	mov	rsi, rcx
$LN184@Try_emplac:

; 1658 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, rsi
	mov	rcx, rbp
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Forced_rehash

; 1564 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR [rbp+48]
	and	rcx, r13

; 1565 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rdx, QWORD PTR [rbp+24]
	mov	rax, QWORD PTR [rdx+rcx*8+8]

; 1566 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rbx, QWORD PTR [rbp+8]

; 1567 :         if (_Where == _End) {

	cmp	rax, rbx
	jne	SHORT $LN202@Try_emplac

; 1568 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp+8], 0
	jmp	SHORT $LN238@Try_emplac
$LN202@Try_emplac:

; 1569 :         }
; 1570 : 
; 1571 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [rdx+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	mov	ecx, DWORD PTR [rdi+16]
	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN218@Try_emplac
$LL199@Try_emplac:

; 1582 :             }
; 1583 : 
; 1584 :             if (_Where == _Bucket_lo) {

	mov	rbx, rax
	cmp	rax, rdx
	je	SHORT $LN219@Try_emplac

; 1586 :             }
; 1587 : 
; 1588 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1574 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL199@Try_emplac
$LN218@Try_emplac:

; 1575 :                 if constexpr (!_Traits::_Standard) {
; 1576 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1577 :                         return {_Where->_Next, _Nodeptr{}};
; 1578 :                     }
; 1579 :                 }
; 1580 : 
; 1581 :                 return {_Where->_Next, _Where};

	mov	rbx, QWORD PTR [rax]
$LN238@Try_emplac:

; 703  :             _Rehash_for_1();
; 704  :             _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	QWORD PTR $T1[rsp], rbx
$LN239@Try_emplac:
	mov	r15, rbx
	mov	r12, QWORD PTR $T1[rsp]
$LN3@Try_emplac:

; 1612 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rdx, QWORD PTR [rbx+8]

; 1613 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rbp+16]

; 1614 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rdi], r12

; 1615 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rdi+8], rdx

; 1616 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [rdx], rdi

; 1617 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rbx+8], rdi

; 1618 : 
; 1619 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1620 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rcx, QWORD PTR [rbp+24]

; 1621 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR [rbp+48]
	and	rax, r13

; 1622 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rax, rax

; 1623 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1624 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r8, QWORD PTR [rcx+rax*8]
	cmp	r8, QWORD PTR [rbp+8]
	jne	SHORT $LN117@Try_emplac

; 1625 :             // bucket is empty, set both
; 1626 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi

; 1627 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN240@Try_emplac
$LN219@Try_emplac:

; 1585 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], 0
	jmp	SHORT $LN239@Try_emplac
$LN117@Try_emplac:

; 1628 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r8, r15
	jne	SHORT $LN119@Try_emplac

; 1629 :             // new node is the lowest element in the bucket
; 1630 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi
	jmp	SHORT $LN121@Try_emplac
$LN119@Try_emplac:

; 1631 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rcx+rax*8+8], rdx
	jne	SHORT $LN121@Try_emplac
$LN240@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx+rax*8+8], rdi
$LN121@Try_emplac:
	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 707  :         return {_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()), true};

	jmp	$LN241@Try_emplac
$LN243@Try_emplac:

; 1645 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN237@Try_emplac:
??$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Try_emplace<long const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$ = 32
this$ = 112
__$ReturnUdt$ = 120
_Keyval_arg$ = 128
?dtor$1@?0???$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Try_emplace<long const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
?dtor$1@?0???$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Try_emplace<long const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$ = 32
this$ = 112
__$ReturnUdt$ = 120
_Keyval_arg$ = 128
?dtor$0@?0???$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Try_emplace<long const &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
?dtor$0@?0???$_Try_emplace@AEBJ$$V@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@1@AEBJ@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Try_emplace<long const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char * const &,unsigned char * const &>, COMDAT

; 2060 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN104:

; 2061 :         // Dispatches between the three sized constructions.
; 2062 :         // 1-arg -> value-construction, e.g. vector(5)
; 2063 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2064 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2065 :         auto& _Al       = _Getal();
; 2066 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2067 :         auto& _My_data  = _Mypair._Myval2;
; 2068 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2069 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN99@Construct_
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 2060 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r15, r9
	mov	r14, r8
	mov	rbx, rdx
	mov	rsi, rcx

; 2010 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN101@Construct_
	mov	QWORD PTR [rsp+32], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@Construct_

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN102@Construct_

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Construct_

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN14@Construct_
$LN17@Construct_:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN14@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rsi], rdi

; 1995 :         _Mylast               = _Newvec;
; 1996 :         _Myend                = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rdi]
	mov	QWORD PTR [rsi+8], rdi
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1804 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1822 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rbx+rdi]
	mov	rdi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2078 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rax

; 2087 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
$LN99@Construct_:
	ret	0
$LN27@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN101@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN102@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN98@Construct_:
??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char * const &,unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>, COMDAT

; 1075 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1076 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1077 :         for (; _First != _Last; ++_First) {
; 1078 :             _STD _Destroy_in_place(*_First);
; 1079 :         }
; 1080 :     }
; 1081 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Head$ = 56
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN88:
	push	rsi
	sub	rsp, 32					; 00000020H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rsi, QWORD PTR [rdx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rsi, rsi
	je	SHORT $LN82@Free_non_h
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+64], rdi
$LL4@Free_non_h:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rdi, QWORD PTR [rsi]
	lea	rcx, QWORD PTR [rsi+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rsi+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rsi, rdi
	test	rdi, rdi
	jne	SHORT $LL4@Free_non_h
	mov	rdi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]
$LN82@Free_non_h:

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }
; 331  :     }

	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > * const &>, COMDAT

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >, COMDAT

; 1583 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rcx, rdx

; 1965 :     // copy _Val throughout raw [_First, _Last)
; 1966 :     _STD _Adl_verify_range(_First, _Last);
; 1967 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1968 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1969 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1970 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1971 :     } else {
; 1972 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1973 :             if (_STD _Is_all_bits_zero(_Val)) {
; 1974 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1975 :                 return;
; 1976 :             }
; 1977 :         }
; 1978 : 
; 1979 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 1980 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN3@uninitiali
	npad	11
$LL2@uninitiali:

; 1597 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax

; 1598 :         ++_Last;

	add	rcx, 8

; 1965 :     // copy _Val throughout raw [_First, _Last)
; 1966 :     _STD _Adl_verify_range(_First, _Last);
; 1967 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1968 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1969 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1970 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1971 :     } else {
; 1972 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1973 :             if (_STD _Is_all_bits_zero(_Val)) {
; 1974 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1975 :                 return;
; 1976 :             }
; 1977 :         }
; 1978 : 
; 1979 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 1980 :         while (_Backout._Last != _ULast) {

	cmp	rcx, rdx
	jne	SHORT $LL2@uninitiali
$LN3@uninitiali:

; 1981 :             _Backout._Emplace_back(_Val);
; 1982 :         }
; 1983 : 
; 1984 :         _Backout._Release();
; 1985 :     }
; 1986 : }

	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Val$ = 32
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >, COMDAT

; 5140 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN21:
	sub	rsp, 8
	mov	r10, rdx

; 5141 :     // copy _Val through [_First, _Last)
; 5142 :     _STD _Adl_verify_range(_First, _Last);
; 5143 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5144 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5145 :     } else {
; 5146 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	xor	eax, eax
	sub	rdx, rcx
	mov	r9, rcx
	add	rdx, 7
	shr	rdx, 3
	cmp	rcx, r10
	cmova	rdx, rax

; 5147 :         const auto _ULast = _STD _Get_unwrapped(_Last);
; 5148 : #if _HAS_CXX20
; 5149 :         if (!_STD is_constant_evaluated())
; 5150 : #endif // _HAS_CXX20
; 5151 :         {
; 5152 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5153 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5154 :                 return;
; 5155 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5156 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5157 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5158 :                     return;
; 5159 :                 }
; 5160 :             }
; 5161 :         }
; 5162 : 
; 5163 :         for (; _UFirst != _ULast; ++_UFirst) {

	test	rdx, rdx
	je	SHORT $LN10@fill
	cmp	rdx, 2
	jb	SHORT $LN10@fill

; 5164 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	add	rcx, -8
	lea	rcx, QWORD PTR [rcx+rdx*8]
	cmp	r9, r8
	ja	SHORT $LN11@fill

; 5141 :     // copy _Val through [_First, _Last)
; 5142 :     _STD _Adl_verify_range(_First, _Last);
; 5143 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5144 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5145 :     } else {
; 5146 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	cmp	rcx, r8
	jae	SHORT $LN10@fill
$LN11@fill:
	mov	QWORD PTR [rsp], rdi
	and	rdx, -2
	mov	rdi, r9
	lea	rdx, QWORD PTR [rdx*8]
	mov	rcx, rdx
	shr	rcx, 3
	rep stosq
	add	r9, rdx
	mov	rdi, QWORD PTR [rsp]
$LN10@fill:

; 5147 :         const auto _ULast = _STD _Get_unwrapped(_Last);
; 5148 : #if _HAS_CXX20
; 5149 :         if (!_STD is_constant_evaluated())
; 5150 : #endif // _HAS_CXX20
; 5151 :         {
; 5152 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5153 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5154 :                 return;
; 5155 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5156 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5157 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5158 :                     return;
; 5159 :                 }
; 5160 :             }
; 5161 :         }
; 5162 : 
; 5163 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r9, r10
	je	SHORT $LN3@fill
	npad	9
$LL9@fill:

; 5164 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [r9], rax
	add	r9, 8
	cmp	r9, r10
	jne	SHORT $LL9@fill
$LN3@fill:

; 5165 :         }
; 5166 :     }
; 5167 : }

	add	rsp, 8
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BCA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$dead$ = 8
??$_Get_size_of_n@$0BCA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<288>, COMDAT

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {
; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	mov	eax, 288				; 00000120H

; 90   : }

	ret	0
??$_Get_size_of_n@$0BCA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<288>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0ClientRequest@@QEAA@$$QEAU0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0ClientRequest@@QEAA@$$QEAU0@@Z PROC			; ClientRequest::ClientRequest, COMDAT
	mov	eax, DWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+16], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+32], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+40], rax

; 3083 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	xmm1, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm1
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], 15
	mov	BYTE PTR [rdx+16], al
	mov	rax, rcx
	ret	0
??0ClientRequest@@QEAA@$$QEAU0@@Z ENDP			; ClientRequest::ClientRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0ClientResponse@@QEAA@$$QEAU0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0ClientResponse@@QEAA@$$QEAU0@@Z PROC			; ClientResponse::ClientResponse, COMDAT

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax

; 3083 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], al
	mov	eax, DWORD PTR [rdx+32]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+36]
	mov	DWORD PTR [rcx+36], eax
	mov	rax, rcx
	ret	0
??0ClientResponse@@QEAA@$$QEAU0@@Z ENDP			; ClientResponse::ClientResponse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::_Release, COMDAT

; 1602 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1603 :         return _Last;
; 1604 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>, COMDAT

; 1591 :         _STD _Destroy_range(_First, _Last);
; 1592 :     }

	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>, COMDAT

; 1583 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >, COMDAT

; 53   :     _CONSTEXPR20 ~_Tidy_guard() {

$LN37:
	push	rbx
	sub	rsp, 32					; 00000020H

; 54   :         if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN6@Tidy_guard
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN6@Tidy_guard

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@Tidy_guard

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@Tidy_guard

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@Tidy_guard:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN6@Tidy_guard:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 57   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@Tidy_guard:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN34@Tidy_guard:
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >, COMDAT

; 588  :     ~_List_node_emplace_op2() {

$LN58:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 589  :         if (this->_Ptr != pointer{}) {

	mov	rbx, QWORD PTR [rcx+8]
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN11@List_node_
	lea	rcx, QWORD PTR [rbx+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rbx+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
$LN11@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1137 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN35@List_node_

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	call	??3@YAXPEAX_K@Z				; operator delete
$LN35@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 592  :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_Release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1129 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??0?$_Tuple_val@VClient@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Tuple_val@VClient@@@std@@QEAA@XZ PROC		; std::_Tuple_val<Client>::_Tuple_val<Client>, COMDAT

; 140  :     constexpr _Tuple_val() : _Val() {}

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	DWORD PTR [rcx+32], eax
	xorps	xmm1, xmm1
	movups	XMMWORD PTR [rcx+52], xmm0
	mov	QWORD PTR [rcx+68], rax
	movups	XMMWORD PTR [rcx+92], xmm0
	mov	QWORD PTR [rcx+108], rax
	movups	XMMWORD PTR [rcx+148], xmm0
	movups	XMMWORD PTR [rcx+180], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+36], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+52], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+60], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+36], al
	mov	DWORD PTR [rcx+68], -1

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+76], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+92], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+100], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+76], al
	mov	DWORD PTR [rcx+108], -1
	mov	QWORD PTR [rcx+116], -1
	mov	QWORD PTR [rcx+124], -1

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+132], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+148], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+156], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+132], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+164], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+180], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+188], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+164], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 140  :     constexpr _Tuple_val() : _Val() {}

	mov	rax, rcx
	mov	DWORD PTR [rcx+196], -1
	ret	0
??0?$_Tuple_val@VClient@@@std@@QEAA@XZ ENDP		; std::_Tuple_val<Client>::_Tuple_val<Client>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ?_Get_rest@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_rest@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@XZ PROC ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get_rest, COMDAT

; 746  :         return *this;

	mov	rax, rcx

; 747  :     }

	ret	0
?_Get_rest@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAAAEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@XZ ENDP ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Plist$ = 16
_Bucket$ = 24
?_Erase_bucket@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Erase_bucket, COMDAT

; 1662 :         // remove the node _Plist from its bucket
; 1663 :         _Nodeptr& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r9, QWORD PTR [rcx+24]
	shl	r8, 4
	add	r9, r8

; 1664 :         _Nodeptr& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1665 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [r9]
	cmp	QWORD PTR [r9+8], rdx
	jne	SHORT $LN2@Erase_buck

; 1666 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rdx
	jne	SHORT $LN4@Erase_buck

; 1667 :                 const auto _End = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR [rcx+8]

; 1668 : 
; 1669 :                 _Bucket_lo = _End;

	mov	QWORD PTR [r9], rax

; 1673 :             }

	mov	QWORD PTR [r9+8], rax

; 1676 :         }
; 1677 :     }

	ret	0
$LN4@Erase_buck:

; 1670 :                 _Bucket_hi = _End;
; 1671 :             } else {
; 1672 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	rax, QWORD PTR [rdx+8]

; 1673 :             }

	mov	QWORD PTR [r9+8], rax

; 1676 :         }
; 1677 :     }

	ret	0
$LN2@Erase_buck:

; 1674 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rdx
	jne	SHORT $LN6@Erase_buck

; 1675 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r9], rax
$LN6@Erase_buck:

; 1676 :         }
; 1677 :     }

	ret	0
?_Erase_bucket@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Erase_bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Rehash_for_1, COMDAT

; 1655 :     void _Rehash_for_1() {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1656 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;
; 1657 :         const auto _Newsize = _Oldsize + 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	rdi, rcx
	add	rdx, 1

; 1685 :         const size_type _Old_buckets = bucket_count();

	mov	rbx, QWORD PTR [rcx+56]

; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	js	SHORT $LN18@Rehash_for
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN19@Rehash_for
$LN18@Rehash_for:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN19@Rehash_for:
	divss	xmm0, DWORD PTR [rcx]
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN17@Rehash_for
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN17@Rehash_for
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN17@Rehash_for:
	cvttss2si rax, xmm0
	add	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1687 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rbx, rcx
	jae	SHORT $LN3@Rehash_for

; 1688 :             // we already have enough buckets so there's no need to change the count
; 1689 :             return _Old_buckets;
; 1690 :         }
; 1691 : 
; 1692 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rbx, 512				; 00000200H
	jae	SHORT $LN5@Rehash_for
	lea	rbx, QWORD PTR [rbx*8]
	cmp	rbx, rcx
	jae	SHORT $LN3@Rehash_for
$LN5@Rehash_for:

; 1693 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1694 :             return _Old_buckets * 8;
; 1695 :         }
; 1696 : 
; 1697 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1698 :         return _Req_buckets;

	mov	rbx, rcx
$LN3@Rehash_for:

; 1658 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, rbx
	mov	rcx, rdi

; 1659 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1658 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	jmp	?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Forced_rehash
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Check_rehash_required_1, COMDAT

; 1650 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1651 :         const auto _Newsize      = _Oldsize + 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	r8, rcx
	add	rdx, 1

; 1652 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN9@Check_reha
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN10@Check_reha
$LN9@Check_reha:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN10@Check_reha:
	mov	rcx, QWORD PTR [rcx+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN7@Check_reha
	cvtsi2ss xmm1, rcx
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [r8]
	seta	al

; 1653 :     }

	ret	0
$LN7@Check_reha:

; 1652 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [r8]
	seta	al

; 1653 :     }

	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Check_max_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Check_max_size, COMDAT

; 1642 :     void _Check_max_size() const {

$LN7:
	sub	rsp, 40					; 00000028H

; 1643 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1644 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 64051194700380387			; 00e38e38e38e38e3H
	cmp	QWORD PTR [rcx+16], rax
	je	SHORT $LN6@Check_max_

; 1646 :         }
; 1647 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Check_max_:

; 1645 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN4@Check_max_:
?_Check_max_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
this$ = 8
_Hashval$ = 16
_Insert_before$ = 24
_Newnode$ = 32
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Insert_new_node_before, COMDAT

; 1612 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	r11, QWORD PTR [r8+8]

; 1613 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rcx+16]

; 1614 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [r9], r8

; 1615 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [r9+8], r11

; 1616 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [r11], r9

; 1617 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [r8+8], r9

; 1618 : 
; 1619 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1620 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;
; 1621 :         const size_type _Bucket         = _Hashval & _Mask;

	and	rdx, QWORD PTR [rcx+48]

; 1622 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	shl	rdx, 4
	add	rdx, QWORD PTR [rcx+24]

; 1623 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1624 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rax, QWORD PTR [rdx]
	cmp	rax, QWORD PTR [rcx+8]
	jne	SHORT $LN2@Insert_new

; 1625 :             // bucket is empty, set both
; 1626 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx], r9

; 1632 :             // new node is the highest element in the bucket
; 1633 :             _Bucket_hi._Ptr = _Newnode;
; 1634 :         }
; 1635 : 
; 1636 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1637 :         _Stl_internal_check_container_invariants();
; 1638 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1639 :         return _Newnode;
; 1640 :     }

	mov	rax, r9
	mov	QWORD PTR [rdx+8], r9
	ret	0
$LN2@Insert_new:

; 1627 :             _Bucket_hi._Ptr = _Newnode;
; 1628 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	rax, r8
	jne	SHORT $LN4@Insert_new

; 1629 :             // new node is the lowest element in the bucket
; 1630 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx], r9

; 1632 :             // new node is the highest element in the bucket
; 1633 :             _Bucket_hi._Ptr = _Newnode;
; 1634 :         }
; 1635 : 
; 1636 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1637 :         _Stl_internal_check_container_invariants();
; 1638 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1639 :         return _Newnode;
; 1640 :     }

	mov	rax, r9
	ret	0
$LN4@Insert_new:

; 1631 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rdx+8], r11
	jne	SHORT $LN9@Insert_new

; 1632 :             // new node is the highest element in the bucket
; 1633 :             _Bucket_hi._Ptr = _Newnode;
; 1634 :         }
; 1635 : 
; 1636 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1637 :         _Stl_internal_check_container_invariants();
; 1638 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1639 :         return _Newnode;
; 1640 :     }

	mov	QWORD PTR [rdx+8], r9
$LN9@Insert_new:
	mov	rax, r9
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Unchecked_erase@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
?_Unchecked_erase@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@@Z PROC ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_erase, COMDAT

; 1422 :     _Nodeptr _Unchecked_erase(const _Nodeptr _Pnode) noexcept { // erase element at _Pnode

$LN79:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1423 :         const auto _Result = _Pnode->_Next;

	mov	rdi, QWORD PTR [rdx]
	mov	rsi, rdx

; 1424 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1425 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR [rcx+8]

; 1426 :         _Pnode->_Prev->_Next = _Result;

	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rsi+88]
	mov	QWORD PTR [rdx], rdi

; 1427 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rdx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rdi+8], rdx
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rsi+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1430 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rdi
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Unchecked_erase@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@@Z ENDP ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::deallocate, COMDAT

; 682  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	mov	rcx, rdx

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@J@std@@V?$_Compressed_pair@U?$equal_to@J@std@@M$00@2@$00@std@@QEBAAEBU?$hash@J@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@J@std@@V?$_Compressed_pair@U?$equal_to@J@std@@M$00@2@$00@std@@QEBAAEBU?$hash@J@2@XZ PROC ; std::_Compressed_pair<std::hash<long>,std::_Compressed_pair<std::equal_to<long>,float,1>,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@J@std@@V?$_Compressed_pair@U?$equal_to@J@std@@M$00@2@$00@std@@QEBAAEBU?$hash@J@2@XZ ENDP ; std::_Compressed_pair<std::hash<long>,std::_Compressed_pair<std::equal_to<long>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@J$00@std@@QEBA_KAEBJ@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval$ = 16
??R?$_Conditionally_enabled_hash@J$00@std@@QEBA_KAEBJ@Z PROC ; std::_Conditionally_enabled_hash<long,1>::operator(), COMDAT

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rdx+2]

; 2302 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	movzx	r8d, BYTE PTR [rdx]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+3]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9

; 2347 :         return hash<_Kty>::_Do_hash(_Keyval);
; 2348 :     }

	ret	0
??R?$_Conditionally_enabled_hash@J$00@std@@QEBA_KAEBJ@Z ENDP ; std::_Conditionally_enabled_hash<long,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero, COMDAT

; 1999 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2000 :         // allocate array with _Newcapacity elements
; 2001 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2002 :         auto& _My_data    = _Mypair._Myval2;
; 2003 :         pointer& _Myfirst = _My_data._Myfirst;
; 2004 :         pointer& _Mylast  = _My_data._Mylast;
; 2005 :         pointer& _Myend   = _My_data._Myend;
; 2006 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2007 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2008 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2009 : 
; 2010 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN44@Buy_nonzer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN11@Buy_nonzer

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN10@Buy_nonzer
$LN11@Buy_nonzer:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN13@Buy_nonzer

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN45@Buy_nonzer

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN23@Buy_nonzer

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN10@Buy_nonzer
$LN13@Buy_nonzer:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN10@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rax, rbx

; 2015 :     }

	mov	rbx, QWORD PTR [rsp+64]

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rax

; 2015 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN44@Buy_nonzer:

; 2011 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN45@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN23@Buy_nonzer:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN42@Buy_nonzer:
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 3022 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN67:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 3023 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN64@operator

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN17@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN31@operator

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN28@operator

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN31@operator:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN17@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15
	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al

; 3083 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 3024 :             return *this;
; 3025 :         }
; 3026 : 
; 3027 :         auto& _Al                 = _Getal();
; 3028 :         auto& _Right_al           = _Right._Getal();
; 3029 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 3030 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 3031 :             if (_Al != _Right_al) {
; 3032 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 3033 :                 _Mypair._Myval2._Orphan_all();
; 3034 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 3035 :             }
; 3036 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 3037 :             if (_Al != _Right_al) {
; 3038 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3039 :                 return *this;
; 3040 :             }
; 3041 :         }
; 3042 : 
; 3043 :         _Tidy_deallocate();
; 3044 :         _Pocma(_Al, _Right_al);
; 3045 :         _Take_contents(_Right);
; 3046 :         return *this;

	mov	QWORD PTR [rdi+16], rax
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], al
$LN64@operator:

; 3047 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN63@operator:
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >, COMDAT

; 1137 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN7@Alloc_cons

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN7@Alloc_cons:

; 1138 :             _Al.deallocate(_Ptr, 1);
; 1139 :         }
; 1140 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Buckets$ = 72
?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Forced_rehash, COMDAT

; 1705 :     void _Forced_rehash(size_type _Buckets) {

$LN291:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 40   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1705 :     void _Forced_rehash(size_type _Buckets) {

	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 40   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1713 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	edi, 1
	mov	eax, edi
	shl	rax, cl

; 1714 :         if (_Buckets > _Max_storage_buckets) {

	cmp	rdx, rax
	ja	$LN289@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 51   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	rax, QWORD PTR [rdx-1]
	mov	QWORD PTR [rsp+80], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbx, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rax, rdi

; 40   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1725 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	r8, rbx
	mov	QWORD PTR [rsp+32], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xbit_ops.h

; 51   :     return 1 + _Floor_of_log_2(_Value - 1);

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1722 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	shl	rdi, cl

; 1725 :         _Vec._Assign_grow(_Buckets << 1, _End);

	lea	rcx, QWORD PTR [rsi+24]
	lea	rdx, QWORD PTR [rdi+rdi]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::_Assign_grow

; 1726 :         _Mask   = _Buckets - 1;

	lea	rax, QWORD PTR [rdi-1]

; 1727 :         _Maxidx = _Buckets;

	mov	QWORD PTR [rsi+56], rdi
	mov	QWORD PTR [rsi+48], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1108 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rsi+8]

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1734 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1734 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	je	$LN286@Forced_reh
	mov	QWORD PTR [rsp+88], rbp
	mov	rdi, 1099511628211			; 00000100000001b3H
	mov	rbp, -3750763034362895579		; cbf29ce484222325H
$LL4@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	edx, BYTE PTR [rax+17]
	movzx	r11d, BYTE PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r11, rbp

; 2302 :         _Val *= _FNV_prime;

	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+18]
	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+19]
	imul	r11, rdi
	xor	r11, rdx
	imul	r11, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	and	r11, QWORD PTR [rsi+48]

; 1735 :             ++_Next_inserted;
; 1736 : 
; 1737 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);
; 1738 :             const size_type _Bucket = bucket(_Inserted_key);
; 1739 : 
; 1740 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1741 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1742 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	shl	r11, 4
	add	r11, QWORD PTR [rsi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	mov	r9, QWORD PTR [r11]
	cmp	r9, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1745 :             if (_Bucket_lo == _End) {

	jne	SHORT $LN9@Forced_reh

; 1746 :                 // The bucket was empty, set it to the inserted element.
; 1747 :                 _Bucket_lo = _Inserted;

	mov	QWORD PTR [r11], rax

; 1748 :                 _Bucket_hi = _Inserted;

	mov	QWORD PTR [r11+8], rax

; 1749 :                 continue;

	jmp	SHORT $LN2@Forced_reh
$LN9@Forced_reh:

; 1750 :             }
; 1751 : 
; 1752 :             // Search the bucket for the insertion location and move element if necessary.
; 1753 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rdx, QWORD PTR [r11+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	mov	r8d, DWORD PTR [rax+16]
	cmp	r8d, DWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1754 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	jne	SHORT $LN10@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	r10, QWORD PTR [rdx]
	cmp	r10, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1758 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	je	SHORT $LN276@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 474  :         const auto _First_prev  = _First->_Prev;

	mov	r9, QWORD PTR [rax+8]

; 475  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r9], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	r8, QWORD PTR [rcx+8]

; 477  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r8], r10

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rdx, QWORD PTR [r10+8]

; 479  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rdx], rax

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r10+8], r8

; 483  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r9

; 484  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], rdx
$LN276@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1762 :                 _Bucket_hi = _Inserted;

	mov	QWORD PTR [r11+8], rax

; 1763 :                 continue;

	jmp	SHORT $LN2@Forced_reh
$LN10@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1769 :                 if (_Bucket_lo == _Insert_before) {

	je	SHORT $LN259@Forced_reh
$LL5@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rdx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	cmp	r8d, DWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1779 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	je	SHORT $LN260@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1769 :                 if (_Bucket_lo == _Insert_before) {

	jne	SHORT $LL5@Forced_reh
$LN259@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 474  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rax+8]

; 475  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [rcx+8]

; 477  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rdx

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	r8, QWORD PTR [rdx+8]

; 479  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [r8], rax

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rdx+8], r9

; 483  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r10

; 484  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1775 :                     _Bucket_lo = _Inserted;

	mov	QWORD PTR [r11], rax
$LN2@Forced_reh:

; 1734 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1734 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	jne	$LL4@Forced_reh
	mov	rbp, QWORD PTR [rsp+88]
$LN286@Forced_reh:
	mov	rbx, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+32]

; 1785 :                     break;
; 1786 :                 }
; 1787 :             }
; 1788 :         }
; 1789 : 
; 1790 :         _Guard._Target = nullptr;
; 1791 : 
; 1792 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1793 :         _Stl_internal_check_container_invariants();
; 1794 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1795 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
$LN260@Forced_reh:

; 1780 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1781 :                     ++_Insert_before;
; 1782 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1783 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1784 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r10, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 474  :         const auto _First_prev  = _First->_Prev;

	mov	r9, QWORD PTR [rax+8]

; 475  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r9], rcx

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	r8, QWORD PTR [rcx+8]

; 477  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r8], r10

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rdx, QWORD PTR [r10+8]

; 479  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rdx], rax

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r10+8], r8

; 483  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r9

; 484  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], rdx
	jmp	SHORT $LN2@Forced_reh
$LN289@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1715 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN287@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 48
_For_size$ = 56
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Desired_grow_bucket_count, COMDAT

; 1684 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1685 :         const size_type _Old_buckets = bucket_count();

	mov	rbx, QWORD PTR [rcx+56]

; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN16@Desired_gr
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN17@Desired_gr
$LN16@Desired_gr:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN17@Desired_gr:
	divss	xmm0, DWORD PTR [rcx]
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	eax, eax
	comiss	xmm0, xmm1
	jb	SHORT $LN15@Desired_gr
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN15@Desired_gr
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
$LN15@Desired_gr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	edx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	cvttss2si rcx, xmm0
	add	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rdx
	cmova	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1687 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rbx, rdx
	jb	SHORT $LN2@Desired_gr

; 1688 :             // we already have enough buckets so there's no need to change the count
; 1689 :             return _Old_buckets;

	mov	rax, rbx

; 1693 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1694 :             return _Old_buckets * 8;
; 1695 :         }
; 1696 : 
; 1697 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1698 :         return _Req_buckets;
; 1699 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Desired_gr:

; 1690 :         }
; 1691 : 
; 1692 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rbx, 512				; 00000200H
	jae	SHORT $LN3@Desired_gr
	lea	rax, QWORD PTR [rbx*8]
	cmp	rax, rdx
	cmovae	rdx, rax
$LN3@Desired_gr:

; 1693 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1694 :             return _Old_buckets * 8;
; 1695 :         }
; 1696 : 
; 1697 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1698 :         return _Req_buckets;
; 1699 :     }

	mov	rax, rdx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?max_load_factor@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::max_load_factor, COMDAT

; 908  :         return _Max_bucket_size();

	movss	xmm0, DWORD PTR [rcx]

; 909  :     }

	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::bucket_count, COMDAT

; 843  :         return _Maxidx;

	mov	rax, QWORD PTR [rcx+56]

; 844  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Orphan_ptr2, COMDAT

; 356  : #if _ITERATOR_DEBUG_LEVEL == 2
; 357  :         _Lockit _Lock(_LOCK_DEBUG);
; 358  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 359  :         const auto _Head          = _Myhead;
; 360  :         while (*_Pnext) {
; 361  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 362  :             const auto _Pnextptr          = static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr;
; 363  :             if (_Pnextptr == _Head || _Pnextptr != _Ptr) {
; 364  :                 // iterator is end() or doesn't point at the one we are orphaning, move on
; 365  :                 _Pnext = _Pnextnext;
; 366  :             } else { // orphan the iterator
; 367  :                 (*_Pnext)->_Myproxy = nullptr;
; 368  :                 *_Pnext             = *_Pnextnext;
; 369  :             }
; 370  :         }
; 371  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 372  :         (void) _Ptr;
; 373  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 374  :     }

	ret	0
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Orphan_ptr2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::max_size, COMDAT

; 1195 :         return (_STD min)(

	mov	rax, 64051194700380387			; 00e38e38e38e38e3H

; 1196 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1197 :     }

	ret	0
?max_size@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ?_Do_hash@?$hash@J@std@@SA_KAEBJ@Z
_TEXT	SEGMENT
_Keyval$ = 8
?_Do_hash@?$hash@J@std@@SA_KAEBJ@Z PROC			; std::hash<long>::_Do_hash, COMDAT

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rcx]

; 2302 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2364 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

	mov	rdx, rcx

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+1]
	movzx	ecx, BYTE PTR [rcx+2]

; 2302 :         _Val *= _FNV_prime;

	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+3]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9

; 2365 :         return _Hash_representation(_Keyval);
; 2366 :     }

	ret	0
?_Do_hash@?$hash@J@std@@SA_KAEBJ@Z ENDP			; std::hash<long>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw, COMDAT

; 1983 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN8@Buy_raw

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN7@Buy_raw
$LN8@Buy_raw:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN10@Buy_raw

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN39@Buy_raw

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@Buy_raw

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN7@Buy_raw
$LN10@Buy_raw:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN7@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1994 :         _Myfirst              = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1995 :         _Mylast               = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1996 :         _Myend                = _Newvec + _Newcapacity;

	add	rax, rbx

; 1997 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN39@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN20@Buy_raw:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN37@Buy_raw:
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 479  :         ~_Clear_guard() {

$LN118:
	push	rsi
	sub	rsp, 48					; 00000030H

; 480  :             if (_Target) {

	mov	rsi, QWORD PTR [rcx]
	test	rsi, rsi
	je	$LN5@Clear_guar

; 1155 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rsi+16]

; 1156 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	$LN5@Clear_guar

; 1157 :             return;
; 1158 :         }
; 1159 : 
; 1160 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1161 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1162 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1163 :             // as many buckets as elements, remove element-by-element.
; 1164 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rsi+56]
	shr	rax, 3
	cmp	rax, rcx
	jbe	SHORT $LN7@Clear_guar

; 1165 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rdx, QWORD PTR [rsi+8]

; 1166 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	rcx, rsi
	mov	r8, rdx
	mov	rdx, QWORD PTR [rdx]

; 481  :                 _Target->clear();
; 482  :             }
; 483  :         }

	add	rsp, 48					; 00000030H
	pop	rsi

; 1166 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_erase
$LN7@Clear_guar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1492 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rsp+88], r14

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	r14, QWORD PTR [rcx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	r14, r14
	je	SHORT $LN109@Clear_guar
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rdi
	npad	7
$LL16@Clear_guar:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rdi, QWORD PTR [r14]
	lea	rcx, QWORD PTR [r14+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [r14+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	r14, rdi
	test	rdi, rdi
	jne	SHORT $LL16@Clear_guar
	mov	rdi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+72]
$LN109@Clear_guar:

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1494 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rax+8], rax

; 1495 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rsi+16], 0

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rsi+32]
	mov	rcx, QWORD PTR [rsi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	mov	r14, QWORD PTR [rsp+88]
$LN5@Clear_guar:

; 481  :                 _Target->clear();
; 482  :             }
; 483  :         }

	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 474  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator++, COMDAT

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 107  :         _Mybase::operator++();
; 108  :         return *this;

	mov	rax, rcx

; 50   :         _Ptr = _Ptr->_Next;

	mov	QWORD PTR [rcx], rdx

; 109  :     }

	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator*, COMDAT

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 99   :         return const_cast<reference>(_Mybase::operator*());
; 100  :     }

	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator==, COMDAT

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 73   :     }

	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator--, COMDAT

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+8]

; 62   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 63   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator++, COMDAT

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 51   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator*, COMDAT

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::max_size, COMDAT

; 274  :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 275  :             _Aliter_traits::max_size(_Mypair._Get_first()));
; 276  :     }

	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Max_bucket_size, COMDAT

; 1802 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, rcx

; 1803 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 48
_For_size$ = 56
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Min_load_factor_buckets, COMDAT

; 1679 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN12:
	sub	rsp, 40					; 00000028H

; 1680 :         // returns the minimum number of buckets necessary for the elements in _List
; 1681 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN8@Min_load_f
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN9@Min_load_f
$LN8@Min_load_f:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN9@Min_load_f:
	divss	xmm0, DWORD PTR [rcx]
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN7@Min_load_f
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN7@Min_load_f
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN7@Min_load_f:
	cvttss2si rax, xmm0
	add	rax, rcx

; 1682 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBJ@Z
_TEXT	SEGMENT
this$ = 8
_Keyval$ = 16
?bucket@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBJ@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::bucket, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2302 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, r9
	xor	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR [rcx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	imul	r8, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	and	rax, r8

; 853  :     }

	ret	0
?bucket@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBJ@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_end, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 808  :         return _List._Unchecked_end();

	mov	rax, rdx

; 809  :     }

	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_begin, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1108 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx+8]

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 800  :         return _List._Unchecked_begin();

	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 801  :     }

	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Before$ = 8
_First$ = 16
_Last$ = 24
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_splice, COMDAT

; 469  :         // splice [_First, _Last) before _Before; returns _Last
; 470  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 471  :         // 3 reads and 6 writes
; 472  : 
; 473  :         // fixup the _Next values
; 474  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rdx+8]

; 475  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], r8

; 476  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [r8+8]

; 477  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rcx

; 478  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [rcx+8]

; 479  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdx

; 480  : 
; 481  :         // fixup the _Prev values
; 482  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rcx+8], r9

; 483  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [r8+8], r10

; 484  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdx+8], rax

; 485  : 
; 486  :         return _Last;

	mov	rax, r8

; 487  :     }

	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Getal, COMDAT

; 1854 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1855 :     }

	ret	0
?_Getal@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 64051194700380387			; 00e38e38e38e38e3H

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::clear, COMDAT

; 1147 :     void clear() noexcept {

$LN112:
	push	rsi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx

; 1148 :         // TRANSITION, ABI:
; 1149 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1150 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1151 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1152 :         //   (2) The hash function operator() may throw exceptions, and
; 1153 :         //   (3) clear() is a noexcept function.
; 1154 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1155 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 1156 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	$LN1@clear

; 1157 :             return;
; 1158 :         }
; 1159 : 
; 1160 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1161 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1162 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1163 :             // as many buckets as elements, remove element-by-element.
; 1164 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rsi+56]
	shr	rax, 3
	cmp	rax, rcx
	jbe	SHORT $LN3@clear

; 1165 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rdx, QWORD PTR [rsi+8]

; 1166 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	rcx, rsi
	mov	r8, rdx
	mov	rdx, QWORD PTR [rdx]

; 1174 :     }

	add	rsp, 48					; 00000030H
	pop	rsi

; 1166 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_erase
$LN3@clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1492 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rsp+88], r14

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	r14, QWORD PTR [rcx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	r14, r14
	je	SHORT $LN104@clear
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rdi
$LL12@clear:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rdi, QWORD PTR [r14]
	lea	rcx, QWORD PTR [r14+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [r14+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	r14, rdi
	test	rdi, rdi
	jne	SHORT $LL12@clear
	mov	rdi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+72]
$LN104@clear:

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1494 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rax+8], rax

; 1495 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rsi+16], 0

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rsi+32]
	mov	rcx, QWORD PTR [rsi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1173 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
	mov	r14, QWORD PTR [rsp+88]
$LN1@clear:

; 1174 :     }

	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
?clear@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_begin, COMDAT

; 1108 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx]

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]

; 1108 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, rdx

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx

; 1109 :     }

	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBAAEBMXZ PROC ; std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >::_Get_max_bucket_size, COMDAT

; 160  :         return _Mypair._Myval2._Myval2;

	mov	rax, rcx

; 161  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBAAEBMXZ ENDP ; std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
_Eraser$$sroa$507$1$ = 32
_Bucket_lo$1$ = 40
tv787 = 48
tv781 = 56
_Bucket_bounds$1$ = 64
_End$1$ = 72
this$ = 128
_First$ = 136
_Last$ = 144
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_erase, COMDAT

; 1023 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN275:
	mov	rax, rsp
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	r15, r8
	mov	r13, rdx
	mov	r14, rcx

; 1024 :         if (_First == _Last) {

	cmp	rdx, r8
	je	$LN272@Unchecked_

; 1029 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	rdx, QWORD PTR [rcx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	mov	r8, 1099511628211			; 00000100000001b3H
	mov	QWORD PTR [rax+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1003 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	rbx, r13
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax+32], rsi
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-40], r12

; 1028 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	r12, QWORD PTR [rcx+8]

; 1003 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	rax, QWORD PTR [r13+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [r13+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1003 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR _Eraser$$sroa$507$1$[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1028 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	QWORD PTR _End$1$[rsp], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r13+17]

; 2302 :         _Val *= _FNV_prime;

	imul	rcx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1029 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	QWORD PTR _Bucket_bounds$1$[rsp], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rcx, rax
	movzx	eax, BYTE PTR [r13+18]

; 2302 :         _Val *= _FNV_prime;

	imul	rcx, r8
	xor	rcx, rax
	movzx	eax, BYTE PTR [r13+19]
	imul	rcx, r8
	xor	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR [r14+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2302 :         _Val *= _FNV_prime;

	imul	rcx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	and	rax, rcx

; 1030 :         _Range_eraser _Eraser{_List, _First};
; 1031 :         {
; 1032 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1033 :             const auto _Predecessor = _First->_Prev;
; 1034 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws
; 1035 :             // nothrow hereafter this block
; 1036 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	rax, 4
	add	rax, rdx
	mov	QWORD PTR _Bucket_lo$1$[rsp], rax

; 1037 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1038 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rcx, QWORD PTR [rax]

; 1039 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv781[rsp], rax
	mov	QWORD PTR tv787[rsp], rcx
	npad	7
$LL2@Unchecked_:

; 1006 :             const auto _Oldnext = _Next;

	mov	rsi, rbx

; 1040 :             for (;;) { // remove elements until we hit the end of the bucket
; 1041 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rbp, rbx

; 1007 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rsi+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1009 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [r14+16]

; 1042 :                 _Eraser._Bump_erased();
; 1043 :                 if (_At_bucket_back) {

	cmp	rsi, QWORD PTR tv781[rsp]
	je	SHORT $LN240@Unchecked_

; 1044 :                     break;
; 1045 :                 }
; 1046 : 
; 1047 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, r15
	jne	SHORT $LL2@Unchecked_

; 1048 :                     if (_Update_lo) {

	cmp	QWORD PTR tv787[rsp], r13
	jne	$LN246@Unchecked_

; 1049 :                         // erased the bucket's prefix
; 1050 :                         _Bucket_lo = _Eraser._Next;

	mov	rax, QWORD PTR _Bucket_lo$1$[rsp]
	mov	QWORD PTR [rax], rbx

; 1051 :                     }
; 1052 : 
; 1053 :                     return _Last;

	jmp	$LN246@Unchecked_
$LN240@Unchecked_:

; 1054 :                 }
; 1055 :             }
; 1056 : 
; 1057 :             if (_Update_lo) {

	mov	rax, QWORD PTR _Bucket_lo$1$[rsp]
	cmp	QWORD PTR tv787[rsp], r13
	jne	SHORT $LN14@Unchecked_

; 1058 :                 // emptied the bucket
; 1059 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rax], r12

; 1060 :                 _Bucket_hi = _End;
; 1061 :             } else {

	jmp	SHORT $LN236@Unchecked_
$LN14@Unchecked_:

; 1062 :                 _Bucket_hi = _Predecessor;

	mov	r12, QWORD PTR _Eraser$$sroa$507$1$[rsp]
$LN236@Unchecked_:

; 1063 :             }
; 1064 :         }
; 1065 : 
; 1066 :         // hereafter we are always erasing buckets' prefixes
; 1067 :         while (_Eraser._Next != _Last) {

	mov	QWORD PTR [rax+8], r12
	cmp	rbx, r15
	je	$LN246@Unchecked_
	npad	13
$LL5@Unchecked_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rbx+16]

; 2302 :         _Val *= _FNV_prime;

	mov	rdx, 1099511628211			; 00000100000001b3H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r13, QWORD PTR [r14+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+17]

; 2302 :         _Val *= _FNV_prime;

	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+18]
	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+19]
	imul	rcx, rdx
	xor	rcx, rax
	imul	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 852  :         return _Traitsobj(_Keyval) & _Mask;

	and	r13, rcx

; 1068 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws
; 1069 :             // nothrow hereafter this block
; 1070 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r13, 4
	add	r13, QWORD PTR _Bucket_bounds$1$[rsp]

; 1071 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1072 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	r12, QWORD PTR [r13+8]
	npad	12
$LL7@Unchecked_:

; 1006 :             const auto _Oldnext = _Next;

	mov	rsi, rbx

; 1073 :             for (;;) { // remove elements until we hit the end of the bucket
; 1074 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rbp, rbx

; 1007 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rsi+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1009 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [r14+16]

; 1075 :                 _Eraser._Bump_erased();
; 1076 :                 if (_At_bucket_back) {

	cmp	rsi, r12
	je	SHORT $LN242@Unchecked_

; 1077 :                     break;
; 1078 :                 }
; 1079 : 
; 1080 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, r15
	jne	SHORT $LL7@Unchecked_

; 1081 :                     // erased the bucket's prefix
; 1082 :                     _Bucket_lo = _Eraser._Next;

	mov	QWORD PTR [r13], rbx
$LN246@Unchecked_:

; 1013 :             _Predecessor->_Next = _Next;

	mov	rax, QWORD PTR _Eraser$$sroa$507$1$[rsp]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+152]
	mov	rbp, QWORD PTR [rsp+144]
	mov	r12, QWORD PTR [rsp+80]
	mov	QWORD PTR [rax], rbx

; 1014 :             _Next->_Prev        = _Predecessor;

	mov	QWORD PTR [rbx+8], rax
	mov	rbx, QWORD PTR [rsp+136]
$LN272@Unchecked_:

; 1090 :         }
; 1091 : 
; 1092 :         return _Last;
; 1093 :     }

	mov	rax, r15
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r13
	ret	0
$LN242@Unchecked_:

; 1083 :                     return _Last;
; 1084 :                 }
; 1085 :             }
; 1086 : 
; 1087 :             // emptied the bucket
; 1088 :             _Bucket_lo = _End;

	mov	rdx, QWORD PTR _End$1$[rsp]
	mov	QWORD PTR [r13], rdx

; 1089 :             _Bucket_hi = _End;

	mov	QWORD PTR [r13+8], rdx
	cmp	rbx, r15
	jne	$LL5@Unchecked_

; 1063 :             }
; 1064 :         }
; 1065 : 
; 1066 :         // hereafter we are always erasing buckets' prefixes
; 1067 :         while (_Eraser._Next != _Last) {

	jmp	SHORT $LN246@Unchecked_
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::clear, COMDAT

; 1489 :     void clear() noexcept { // erase all

$LN92:
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 1490 :         auto& _My_data = _Mypair._Myval2;
; 1491 :         _My_data._Orphan_non_end();
; 1492 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	r14, rcx

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rsi, QWORD PTR [rdx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rsi, rsi
	je	SHORT $LN86@clear
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rdi
	npad	2
$LL7@clear:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rdi, QWORD PTR [rsi]
	lea	rcx, QWORD PTR [rsi+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rsi+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rsi, rdi
	test	rdi, rdi
	jne	SHORT $LL7@clear
	mov	rdi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]
$LN86@clear:

; 1493 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [r14]

; 1494 :         _My_data._Myhead->_Prev = _My_data._Myhead;
; 1495 :         _My_data._Mysize        = 0;
; 1496 :     }

	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rax], rax
	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rax+8], rax
	mov	QWORD PTR [r14+8], 0
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?clear@?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1013 :             _Predecessor->_Next = _Next;

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx], rax

; 1014 :             _Next->_Prev        = _Predecessor;

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+8], rax

; 1015 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1005 :         void _Bump_erased() noexcept {

$LN79:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1006 :             const auto _Oldnext = _Next;

	mov	rdi, QWORD PTR [rcx+16]
	mov	rsi, rcx

; 1007 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx+16], rax
	lea	rcx, QWORD PTR [rdi+88]
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rdi+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 1009 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rsi]

; 1010 :         }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	dec	QWORD PTR [rax+8]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1003 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Orphan_non_end, COMDAT

; 377  : #if _ITERATOR_DEBUG_LEVEL == 2
; 378  :         _Lockit _Lock(_LOCK_DEBUG);
; 379  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 380  :         const auto _Head          = _Myhead;
; 381  :         while (*_Pnext) {
; 382  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 383  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 384  :                 _Pnext = _Pnextnext;
; 385  :             } else { // orphan the iterator
; 386  :                 (*_Pnext)->_Myproxy = nullptr;
; 387  :                 *_Pnext             = *_Pnextnext;
; 388  :             }
; 389  :         }
; 390  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 391  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash
;	COMDAT ??$?RJJ@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBA_NAEBJ0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval1$ = 16
_Keyval2$ = 24
??$?RJJ@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBA_NAEBJ0@Z PROC ; std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >::operator()<long,long>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 517  :         return _Left == _Right;

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xhash

; 152  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	setne	al

; 153  :     }

	ret	0
??$?RJJ@?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@std@@QEBA_NAEBJ0@Z ENDP ; std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >::operator()<long,long>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Eng$ = 56
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z PROC ; std::uniform_int<long>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT

; 2159 :     _NODISCARD result_type operator()(_Engine& _Eng) _DISTRIBUTION_CONST {

$LN76:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	sub	rsp, 32					; 00000020H

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	mov	ebp, DWORD PTR [rcx]

; 2159 :     _NODISCARD result_type operator()(_Engine& _Eng) _DISTRIBUTION_CONST {

	mov	rbx, rdx

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	mov	eax, DWORD PTR [rcx+4]
	btc	ebp, 31
	btc	eax, 31

; 2203 :         if (_Umax - _Umin == static_cast<_Uty>(-1)) {

	mov	rcx, rdx
	sub	eax, ebp
	cmp	eax, -1					; ffffffffH
	jne	SHORT $LN4@operator

; 1417 :         return _Mybase::operator()();

	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2209 :         return static_cast<_Ty>(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [rax+rbp]

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	xor	eax, -2147483648			; ffffffff80000000H

; 2160 :         return _Eval(_Eng, _Par._Min, _Par._Max);
; 2161 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
$LN4@operator:
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+56], rdi

; 2206 :             _Uret = static_cast<_Uty>(_Generator(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	edi, DWORD PTR [rax+1]

; 1417 :         return _Mybase::operator()();

	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	ecx, eax
	mov	esi, edi
	imul	rcx, rsi

; 1999 :         if (_Rem < _Index) {

	cmp	ecx, edi
	jae	SHORT $LN28@operator

; 2000 :             // t <- (2^L - s) mod s
; 2001 :             const auto _Threshold = (_Mask - _Index + 1) % _Index;

	mov	eax, edi
	xor	edx, edx
	neg	eax
	div	edi
	mov	edi, edx

; 2002 :             while (_Rem < _Threshold) {

	cmp	ecx, edx
	jae	SHORT $LN28@operator
$LL27@operator:

; 1417 :         return _Mybase::operator()();

	mov	rcx, rbx
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	ecx, eax
	imul	rcx, rsi

; 2002 :             while (_Rem < _Threshold) {

	cmp	ecx, edi
	jb	SHORT $LL27@operator
$LN28@operator:

; 2003 :                 _Product = _Get_random_product(_Index, _Niter);
; 2004 :                 _Rem     = static_cast<_Udiff>(_Product) & _Mask;
; 2005 :             }
; 2006 :         }
; 2007 : 
; 2008 :         unsigned int _Generated_bits;
; 2009 :         if constexpr (_Bits < _Udiff_bits) {
; 2010 :             _Generated_bits = static_cast<unsigned int>(_Popcount(_Mask));
; 2011 :         } else {
; 2012 :             _Generated_bits = _Udiff_bits;
; 2013 :         }
; 2014 : 
; 2015 :         // m / 2^L
; 2016 :         return static_cast<_Diff>(_Product >> _Generated_bits);

	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+48]

; 2160 :         return _Eval(_Eng, _Par._Min, _Par._Max);
; 2161 :     }

	mov	rbx, QWORD PTR [rsp+64]

; 2016 :         return static_cast<_Diff>(_Product >> _Generated_bits);

	shr	rcx, 32					; 00000020H

; 2209 :         return static_cast<_Ty>(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [rcx+rbp]

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	xor	eax, -2147483648			; ffffffff80000000H

; 2160 :         return _Eval(_Eng, _Par._Min, _Par._Max);
; 2161 :     }

	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@QEAAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ENDP ; std::uniform_int<long>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2651 :         _My_data._Mysize = 0;

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+48], rax

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+56], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 345  :         : _Mybase(), _Myfirst() {}

	mov	rax, rcx
	ret	0
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEAVClient@@@std@@YAAEAVClient@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAVClient@@@std@@YAAEAVClient@@AEAV1@@Z PROC ; std::forward<Client &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEAVClient@@@std@@YAAEAVClient@@AEAV1@@Z ENDP ; std::forward<Client &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
_TEXT	SEGMENT
this$ = 48
_This_arg$ = 56
<_Rest_arg_0>$ = 64
<_Rest_arg_1>$ = 72
??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z PROC ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>, COMDAT

; 359  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, r9
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	lea	rcx, QWORD PTR [rsi+32]

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	lea	rcx, QWORD PTR [rsi+64]

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, rdi
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1

; 359  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z ENDP ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_This_arg$ = 56
<_Rest_arg_0>$ = 64
<_Rest_arg_1>$ = 72
?dtor$3@?0???$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z@4HA PROC ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$3@?0???$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z@4HA ENDP ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_This_arg$ = 56
<_Rest_arg_0>$ = 64
<_Rest_arg_1>$ = 72
?dtor$1@?0???$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z@4HA PROC ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
?dtor$1@?0???$?0AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV12@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z@4HA ENDP ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@VClient@@@std@@YA$$QEAVClient@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VClient@@@std@@YA$$QEAVClient@@AEAV1@@Z PROC	; std::forward<Client>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@VClient@@@std@@YA$$QEAVClient@@AEAV1@@Z ENDP	; std::forward<Client>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YA$$QEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YA$$QEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@AEAV10@@Z PROC ; std::forward<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YA$$QEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT

; 585  :         conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 586  :         _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);

	add	rdx, 32					; 00000020H
	add	rcx, 32					; 00000020H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	rdx, rbx
	mov	rcx, rdi
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 587  :         _Get_rest()   = _STD forward<_Mybase>(_Right._Get_rest());
; 588  :         return *this;
; 589  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$get@$00VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$get@$00VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@@Z PROC ; std::get<1,Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 933  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 934  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

	lea	rax, QWORD PTR [rcx+32]

; 935  : }

	ret	0
??$get@$00VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@0@@Z ENDP ; std::get<1,Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
_TEXT	SEGMENT
$T1 = 48
string$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
aesKey$GSCopy$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 144
string$ = 152
aesKey$ = 160
??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; NetCommon::DecryptInternetData<ClientRequest>, COMDAT

; 95   :     inline Data DecryptInternetData(BYTESTRING string, std::string aesKey) {

$LN80:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR string$GSCopy$[rsp], rdx
	mov	QWORD PTR aesKey$GSCopy$[rsp], rbx
	xor	ebp, ebp

; 96   :         DecryptByteString(string, aesKey);

	mov	rdx, r8
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rdi
	call	?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptByteString

; 97   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rdx, QWORD PTR [rdi]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rsi], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rsi+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsi+8], rax
	lea	rcx, QWORD PTR [rsi+16]
	add	rdx, 16
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN15@DecryptInt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@DecryptInt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@DecryptInt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN34@DecryptInt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [rdi], rbp

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rbp

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rbp
$LN15@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN57@DecryptInt

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN71@DecryptInt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN68@DecryptInt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN71@DecryptInt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN57@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rbp

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 97   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rax, rsi

; 98   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 112				; 00000070H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN31@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN68@DecryptInt:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN77@DecryptInt:
??$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; NetCommon::DecryptInternetData<ClientRequest>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
string$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
aesKey$GSCopy$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 144
string$ = 152
aesKey$ = 160
?dtor$0@?0???$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<ClientRequest>'::`1'::dtor$0
	mov	rcx, QWORD PTR aesKey$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<ClientRequest>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
string$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
aesKey$GSCopy$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 144
string$ = 152
aesKey$ = 160
?dtor$1@?0???$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<ClientRequest>'::`1'::dtor$1
	mov	rcx, QWORD PTR string$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???$DecryptInternetData@UClientRequest@@@NetCommon@@YA?AUClientRequest@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<ClientRequest>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
_TEXT	SEGMENT
$T1 = 48
string$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
aesKey$GSCopy$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 160
string$ = 168
aesKey$ = 176
??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; NetCommon::DecryptInternetData<ClientResponse>, COMDAT

; 95   :     inline Data DecryptInternetData(BYTESTRING string, std::string aesKey) {

$LN80:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR string$GSCopy$[rsp], rdx
	mov	QWORD PTR aesKey$GSCopy$[rsp], r8
	xor	r14d, r14d

; 96   :         DecryptByteString(string, aesKey);

	mov	rdx, r8
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rsi
	call	?DecryptByteString@NetCommon@@YAXAEAV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::DecryptByteString

; 97   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rbx, QWORD PTR [rsi]
	mov	rdx, rbx
	mov	rcx, rbp
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR [rbp+32], eax
	mov	eax, DWORD PTR [rbx+36]
	mov	DWORD PTR [rbp+36], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN15@DecryptInt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@DecryptInt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@DecryptInt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN34@DecryptInt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	mov	QWORD PTR [rsi], r14

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], r14

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], r14
$LN15@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN57@DecryptInt

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN71@DecryptInt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN68@DecryptInt

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN71@DecryptInt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN57@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], r14

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 97   :         return *reinterpret_cast< Data* >( string.data() );

	mov	rax, rbp

; 98   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN31@DecryptInt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN68@DecryptInt:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN77@DecryptInt:
??$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; NetCommon::DecryptInternetData<ClientResponse>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
string$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
aesKey$GSCopy$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 160
string$ = 168
aesKey$ = 176
?dtor$0@?0???$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<ClientResponse>'::`1'::dtor$0
	mov	rcx, QWORD PTR aesKey$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<ClientResponse>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
string$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
aesKey$GSCopy$ = 88
__$ArrayPad$ = 96
__$ReturnUdt$ = 160
string$ = 168
aesKey$ = 176
?dtor$1@?0???$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::DecryptInternetData<ClientResponse>'::`1'::dtor$1
	mov	rcx, QWORD PTR string$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???$DecryptInternetData@UClientResponse@@@NetCommon@@YA?AUClientResponse@@V?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::DecryptInternetData<ClientResponse>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\unordered_map
;	COMDAT ??$_Kfn@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@SAAEBJAEBU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@SAAEBJAEBU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z PROC ; std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0>::_Kfn<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 55   :         return _Val.first;

	mov	rax, rcx

; 56   :     }

	ret	0
??$_Kfn@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@?$_Umap_traits@JV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@V?$_Uhash_compare@JU?$hash@J@std@@U?$equal_to@J@2@@2@V?$allocator@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@2@$0A@@std@@SAAEBJAEBU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z ENDP ; std::_Umap_traits<long,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Uhash_compare<long,std::hash<long>,std::equal_to<long> >,std::allocator<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,0>::_Kfn<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBJ@std@@YAAEBJAEBJ@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBJ@std@@YAAEBJAEBJ@Z PROC			; std::forward<long const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBJ@std@@YAAEBJAEBJ@Z ENDP			; std::forward<long const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$forward_as_tuple@AEBJ@std@@YA?AV?$tuple@AEBJ@0@AEBJ@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
<_Args_0>$ = 16
??$forward_as_tuple@AEBJ@std@@YA?AV?$tuple@AEBJ@0@AEBJ@Z PROC ; std::forward_as_tuple<long const &>, COMDAT

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 1014 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 1015 : }

	ret	0
??$forward_as_tuple@AEBJ@std@@YA?AV?$tuple@AEBJ@0@AEBJ@Z ENDP ; std::forward_as_tuple<long const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 8
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ PROC	; std::forward_as_tuple<>, COMDAT

; 1014 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 1015 : }

	ret	0
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ENDP	; std::forward_as_tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<> >, COMDAT

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN49:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1125 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1132 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 1133 :         _Ptr = _Al.allocate(1);

	mov	ecx, 288				; 00000120H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 362  :     tuple(tuple&&)      = default;

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 307  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	edx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+16], edx
	lea	rcx, QWORD PTR [rax+24]
	call	??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 586  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$?0AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool>::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool><std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * &,bool,0>, COMDAT

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 248  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool>::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool><std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$?0PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool>::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool><std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool,0>, COMDAT

; 247  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 248  :     }

	mov	rax, rcx
	ret	0
??$?0PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool>::pair<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool><std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z PROC		; std::forward<unsigned char * const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z ENDP		; std::forward<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z PROC ; std::ranges::_Unwrap_iter<unsigned char *,unsigned char *>, COMDAT

; 2640 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2641 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2642 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2643 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2644 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2645 :         } else {
; 2646 :             return static_cast<_Iter&&>(_It);
; 2647 :         }
; 2648 :     }

	ret	0
??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ENDP ; std::ranges::_Unwrap_iter<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z PROC ; std::ranges::_Unwrap_sent<unsigned char *,unsigned char *>, COMDAT

; 2653 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2654 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2655 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2656 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2657 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2658 :         } else {
; 2659 :             return static_cast<_Sent&&>(_Se);
; 2660 :         }
; 2661 :     }

	ret	0
??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ENDP ; std::ranges::_Unwrap_sent<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1797 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN24:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1797 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1828 :             return _Dest;

	sub	rsi, rbx
	lea	rax, QWORD PTR [rdi+rsi]

; 1829 :         }
; 1830 :     }
; 1831 : 
; 1832 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1833 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1834 :         _Backout._Emplace_back(*_UFirst);
; 1835 :     }
; 1836 : 
; 1837 :     return _Backout._Release();
; 1838 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN75:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rcx, QWORD PTR [rdx+88]
	mov	rdi, rdx
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rdi+24]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 288				; 00000120H
	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\list

; 319  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *>, COMDAT

; 290  :     if constexpr (is_array_v<_Ty>) {
; 291  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 292  :     } else {
; 293  :         _Obj.~_Ty();
; 294  :     }
; 295  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>, COMDAT

; 1278 :     // check that [_First, _Last) forms an iterator range
; 1279 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1280 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1281 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1282 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1283 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1284 :         _Verify_range(_First, _Last);
; 1285 :     }
; 1286 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &>, COMDAT

; 1596 :         // construct a new element at *_Last and increment
; 1597 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1598 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1599 :     }

	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::destroy<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 705  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN27:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rbx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rbx+64]
	call	??1Client@@QEAA@XZ
	mov	rcx, rbx

; 706  : #if _HAS_CXX20
; 707  :         _STD destroy_at(_Ptr);
; 708  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 709  :         _Ptr->~_Uty();
; 710  : #endif // ^^^ !_HAS_CXX20 ^^^
; 711  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
??$destroy@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::destroy<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,std::nullptr_t>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * const &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1048 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1049 :         _Left = _STD move(_Right);
; 1050 :     }
; 1051 : }

	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$_Hash_representation@J@std@@YA_KAEBJ@Z
_TEXT	SEGMENT
_Keyval$ = 8
??$_Hash_representation@J@std@@YA_KAEBJ@Z PROC		; std::_Hash_representation<long>, COMDAT

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rcx]

; 2302 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2325 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

	mov	rdx, rcx

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+1]
	movzx	ecx, BYTE PTR [rcx+2]

; 2302 :         _Val *= _FNV_prime;

	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+3]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9

; 2326 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
; 2327 : }

	ret	0
??$_Hash_representation@J@std@@YA_KAEBJ@Z ENDP		; std::_Hash_representation<long>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_Allocate, COMDAT

; 1131 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1132 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 1133 :         _Ptr = _Al.allocate(1);

	mov	ecx, 288				; 00000120H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rbx+8], rax

; 1134 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >, COMDAT

; 1125 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ?_Get_rest@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_rest@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get_rest, COMDAT

; 746  :         return *this;

	mov	rax, rcx

; 747  :     }

	ret	0
?_Get_rest@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAAAEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 140  :     constexpr _Tuple_val() : _Val() {}

	xorps	xmm0, xmm0
	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 140  :     constexpr _Tuple_val() : _Val() {}

	ret	0
??0?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@J@std@@M$00@std@@QEBAAEBU?$equal_to@J@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@J@std@@M$00@std@@QEBAAEBU?$equal_to@J@2@XZ PROC ; std::_Compressed_pair<std::equal_to<long>,float,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@J@std@@M$00@std@@QEBAAEBU?$equal_to@J@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<long>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??R?$equal_to@J@std@@QEBA_NAEBJ0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Left$ = 16
_Right$ = 24
??R?$equal_to@J@std@@QEBA_NAEBJ0@Z PROC			; std::equal_to<long>::operator(), COMDAT

; 517  :         return _Left == _Right;

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
	sete	al

; 518  :     }

	ret	0
??R?$equal_to@J@std@@QEBA_NAEBJ0@Z ENDP			; std::equal_to<long>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@AEBAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@JJ@Z
_TEXT	SEGMENT
this$dead$ = 48
_Eng$ = 56
_Min$ = 64
_Max$ = 72
??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@AEBAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@JJ@Z PROC ; std::uniform_int<long>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT

; 2193 :     result_type _Eval(_Engine& _Eng, _Ty _Min, _Ty _Max) const { // compute next value in range [_Min, _Max]

$LN74:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	sub	rsp, 32					; 00000020H

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	btc	r9d, 31

; 2193 :     result_type _Eval(_Engine& _Eng, _Ty _Min, _Ty _Max) const { // compute next value in range [_Min, _Max]

	mov	ebp, r8d

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	btc	ebp, 31

; 2193 :     result_type _Eval(_Engine& _Eng, _Ty _Min, _Ty _Max) const { // compute next value in range [_Min, _Max]

	mov	rbx, rdx

; 2194 :         conditional_t<_Has_static_min_max<_Engine>::value, _Rng_from_urng_v2<_Uty, _Engine>,
; 2195 :             _Rng_from_urng<_Uty, _Engine>>
; 2196 :             _Generator(_Eng);
; 2197 : 
; 2198 :         const _Uty _Umin = _Adjust(static_cast<_Uty>(_Min));
; 2199 :         const _Uty _Umax = _Adjust(static_cast<_Uty>(_Max));
; 2200 : 
; 2201 :         _Uty _Uret;
; 2202 : 
; 2203 :         if (_Umax - _Umin == static_cast<_Uty>(-1)) {

	sub	r9d, ebp
	mov	rcx, rdx
	cmp	r9d, -1					; ffffffffH
	jne	SHORT $LN2@Eval

; 1417 :         return _Mybase::operator()();

	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2207 :         }
; 2208 : 
; 2209 :         return static_cast<_Ty>(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [rax+rbp]

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	btc	eax, 31

; 2210 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
$LN2@Eval:
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+56], rdi

; 2204 :             _Uret = static_cast<_Uty>(_Generator._Get_all_bits());
; 2205 :         } else {
; 2206 :             _Uret = static_cast<_Uty>(_Generator(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	edi, DWORD PTR [r9+1]

; 1417 :         return _Mybase::operator()();

	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	ecx, eax
	mov	esi, edi
	imul	rcx, rsi

; 1999 :         if (_Rem < _Index) {

	cmp	ecx, edi
	jae	SHORT $LN26@Eval

; 2000 :             // t <- (2^L - s) mod s
; 2001 :             const auto _Threshold = (_Mask - _Index + 1) % _Index;

	mov	eax, edi
	xor	edx, edx
	neg	eax
	div	edi
	mov	edi, edx

; 2002 :             while (_Rem < _Threshold) {

	cmp	ecx, edx
	jae	SHORT $LN26@Eval
	npad	7
$LL25@Eval:

; 1417 :         return _Mybase::operator()();

	mov	rcx, rbx
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	ecx, eax
	imul	rcx, rsi

; 2002 :             while (_Rem < _Threshold) {

	cmp	ecx, edi
	jb	SHORT $LL25@Eval
$LN26@Eval:

; 2003 :                 _Product = _Get_random_product(_Index, _Niter);
; 2004 :                 _Rem     = static_cast<_Udiff>(_Product) & _Mask;
; 2005 :             }
; 2006 :         }
; 2007 : 
; 2008 :         unsigned int _Generated_bits;
; 2009 :         if constexpr (_Bits < _Udiff_bits) {
; 2010 :             _Generated_bits = static_cast<unsigned int>(_Popcount(_Mask));
; 2011 :         } else {
; 2012 :             _Generated_bits = _Udiff_bits;
; 2013 :         }
; 2014 : 
; 2015 :         // m / 2^L
; 2016 :         return static_cast<_Diff>(_Product >> _Generated_bits);

	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+48]

; 2210 :     }

	mov	rbx, QWORD PTR [rsp+64]

; 2016 :         return static_cast<_Diff>(_Product >> _Generated_bits);

	shr	rcx, 32					; 00000020H

; 2207 :         }
; 2208 : 
; 2209 :         return static_cast<_Ty>(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [rcx+rbp]

; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	btc	eax, 31

; 2210 :     }

	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@J@std@@AEBAJAEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@JJ@Z ENDP ; std::uniform_int<long>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT

; 345  :         : _Mybase(), _Myfirst() {}

	xorps	xmm0, xmm0
	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2651 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2652 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 2653 :         _My_data._Activate_SSO_buffer();
; 2654 : 
; 2655 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2656 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 345  :         : _Mybase(), _Myfirst() {}

	ret	0
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
_This_arg$ = 64
<_Rest_arg_0>$ = 72
<_Rest_arg_1>$ = 80
??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z PROC ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>, COMDAT

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

$LN23:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rcx

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, QWORD PTR <_Rest_arg_1>$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	lea	rcx, QWORD PTR [rsi+32]

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	lea	rcx, QWORD PTR [rsi+64]

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, rdi
	call	??0Client@@QEAA@AEBV0@@Z
	npad	1

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z ENDP ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$dead$ = 56
_This_arg$ = 64
<_Rest_arg_0>$ = 72
<_Rest_arg_1>$ = 80
?dtor$2@?0???$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z@4HA PROC ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$2@?0???$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z@4HA ENDP ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$dead$ = 56
_This_arg$ = 64
<_Rest_arg_0>$ = 72
<_Rest_arg_1>$ = 80
?dtor$0@?0???$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z@4HA PROC ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
?dtor$0@?0???$?0U_Exact_args_t@std@@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV31@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@U_Exact_args_t@1@AEAVClient@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@2@Z@4HA ENDP ; `std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,Client &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z PROC ; std::forward<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT

; 585  :         conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 586  :         _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);

	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 587  :         _Get_rest()   = _STD forward<_Mybase>(_Right._Get_rest());
; 588  :         return *this;

	mov	rax, rbx

; 589  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?4V?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0AEBJ$0A@@?$tuple@AEBJ@std@@QEAA@AEBJ@Z
_TEXT	SEGMENT
this$ = 8
_This_arg$ = 16
??$?0AEBJ$0A@@?$tuple@AEBJ@std@@QEAA@AEBJ@Z PROC	; std::tuple<long const &>::tuple<long const &><long const &,0>, COMDAT

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 351  :         : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

	mov	rax, rcx
	ret	0
??$?0AEBJ$0A@@?$tuple@AEBJ@std@@QEAA@AEBJ@Z ENDP	; std::tuple<long const &>::tuple<long const &><long const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z PROC ; std::forward<std::piecewise_construct_t const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBUpiecewise_construct_t@std@@@std@@YAAEBUpiecewise_construct_t@0@AEBU10@@Z ENDP ; std::forward<std::piecewise_construct_t const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$tuple@AEBJ@std@@@std@@YA$$QEAV?$tuple@AEBJ@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@AEBJ@std@@@std@@YA$$QEAV?$tuple@AEBJ@0@AEAV10@@Z PROC ; std::forward<std::tuple<long const &> >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$tuple@AEBJ@std@@@std@@YA$$QEAV?$tuple@AEBJ@0@AEAV10@@Z ENDP ; std::forward<std::tuple<long const &> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$tuple@$$V@std@@@std@@YA$$QEAV?$tuple@$$V@0@AEAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$dead$ = 24
<_Args_1>$ = 32
<_Args_2>$dead$ = 40
??$construct@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::construct<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 362  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 307  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	ecx, DWORD PTR [rax]
	mov	DWORD PTR [rdx], ecx
	lea	rcx, QWORD PTR [rdx+8]
	jmp	??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>
??$construct@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBJ@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> > >::construct<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z PROC		; std::move<unsigned char * &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z ENDP		; std::move<unsigned char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char &>, COMDAT

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 1781 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1782 :     }

	ret	0
??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAXQEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@@Z
_TEXT	SEGMENT
_Location$ = 48
??$destroy_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAXQEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@@Z PROC ; std::destroy_at<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 299  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rbx, QWORD PTR [rcx+8]
	lea	rcx, QWORD PTR [rbx+64]
	call	??1Client@@QEAA@XZ
	mov	rcx, rbx

; 300  : #if _HAS_CXX20
; 301  :     if constexpr (is_array_v<_Ty>) {
; 302  :         _STD _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 303  :     } else
; 304  : #endif // _HAS_CXX20
; 305  :     {
; 306  :         _Location->~_Ty();
; 307  :     }
; 308  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
??$destroy_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@YAXQEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@@Z ENDP ; std::destroy_at<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@XZ PROC ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rbx, QWORD PTR [rcx+8]
	lea	rcx, QWORD PTR [rbx+64]
	call	??1Client@@QEAA@XZ
	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
??1?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@XZ ENDP ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> *,std::_List_node<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@J@std@@YA_K_KAEBJ@Z
_TEXT	SEGMENT
_Val$dead$ = 8
_Keyval$ = 16
??$_Fnv1a_append_value@J@std@@YA_K_KAEBJ@Z PROC		; std::_Fnv1a_append_value<long>, COMDAT

; 2301 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rdx+2]

; 2302 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	movzx	r8d, BYTE PTR [rdx]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+3]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9

; 2320 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2321 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
; 2322 : }

	ret	0
??$_Fnv1a_append_value@J@std@@YA_K_KAEBJ@Z ENDP		; std::_Fnv1a_append_value<long>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAAPEAXI@Z PROC ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::`scalar deleting destructor', COMDAT
$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	add	rcx, 72					; 00000048H
	call	??1Client@@QEAA@XZ
	lea	rcx, QWORD PTR [rdi+8]
	call	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@XZ
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAAPEAXI@Z ENDP ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ?_Get_all_bits@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAIXZ
_TEXT	SEGMENT
this$ = 8
?_Get_all_bits@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAIXZ PROC ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_all_bits, COMDAT

; 1417 :         return _Mybase::operator()();

	mov	rcx, QWORD PTR [rcx]
	jmp	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
?_Get_all_bits@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAIXZ ENDP ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_all_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??R?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAKK@Z
_TEXT	SEGMENT
this$ = 48
_Index$ = 56
??R?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAKK@Z PROC ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::operator(), COMDAT

; 1970 :     _Diff operator()(_Diff _Index) { // adapt _Urng closed range to [0, _Index)

$LN42:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx

; 1417 :         return _Mybase::operator()();

	mov	rcx, QWORD PTR [rcx]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	r8d, eax
	mov	esi, ebx
	imul	r8, rbx

; 1971 :         // From Daniel Lemire, "Fast Random Integer Generation in an Interval", ACM Trans. Model. Comput. Simul. 29 (1),
; 1972 :         // 2019.
; 1973 :         //
; 1974 :         // Algorithm 5 <-> This Code:
; 1975 :         //   m <-> _Product
; 1976 :         //   l <-> _Rem
; 1977 :         //   s <-> _Index
; 1978 :         //   t <-> _Threshold
; 1979 :         //   L <-> _Generated_bits
; 1980 :         //   2^L - 1 <-> _Mask
; 1981 : 
; 1982 :         _Udiff _Mask        = _Bmask;
; 1983 :         unsigned int _Niter = 1;
; 1984 : 
; 1985 :         if constexpr (_Bits < _Udiff_bits) {
; 1986 :             while (_Mask < static_cast<_Udiff>(_Index - 1)) {
; 1987 :                 _Mask <<= _Bits;
; 1988 :                 _Mask |= _Bmask;
; 1989 :                 ++_Niter;
; 1990 :             }
; 1991 :         }
; 1992 : 
; 1993 :         // x <- random integer in [0, 2^L)
; 1994 :         // m <- x * s
; 1995 :         auto _Product = _Get_random_product(_Index, _Niter);
; 1996 :         // l <- m mod 2^L
; 1997 :         auto _Rem = static_cast<_Udiff>(_Product) & _Mask;
; 1998 : 
; 1999 :         if (_Rem < _Index) {

	cmp	r8d, ebx
	jae	SHORT $LN3@operator

; 2000 :             // t <- (2^L - s) mod s
; 2001 :             const auto _Threshold = (_Mask - _Index + 1) % _Index;

	mov	eax, ebx
	xor	edx, edx
	neg	eax
	div	ebx
	mov	ebx, edx

; 2002 :             while (_Rem < _Threshold) {

	cmp	r8d, edx
	jae	SHORT $LN3@operator
	npad	7
$LL2@operator:

; 1417 :         return _Mybase::operator()();

	mov	rcx, QWORD PTR [rdi]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	r8d, eax
	imul	r8, rsi

; 2002 :             while (_Rem < _Threshold) {

	cmp	r8d, ebx
	jb	SHORT $LL2@operator
$LN3@operator:

; 2003 :                 _Product = _Get_random_product(_Index, _Niter);
; 2004 :                 _Rem     = static_cast<_Udiff>(_Product) & _Mask;
; 2005 :             }
; 2006 :         }
; 2007 : 
; 2008 :         unsigned int _Generated_bits;
; 2009 :         if constexpr (_Bits < _Udiff_bits) {
; 2010 :             _Generated_bits = static_cast<unsigned int>(_Popcount(_Mask));
; 2011 :         } else {
; 2012 :             _Generated_bits = _Udiff_bits;
; 2013 :         }
; 2014 : 
; 2015 :         // m / 2^L
; 2016 :         return static_cast<_Diff>(_Product >> _Generated_bits);
; 2017 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	shr	r8, 32					; 00000020H
	mov	eax, r8d
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAAKK@Z ENDP ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??0?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAA@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Func$ = 16
??0?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAA@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z PROC ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT

; 1968 :     explicit _Rng_from_urng_v2(_Urng& _Func) noexcept : _Ref(_Func) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QEAA@AEAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ENDP ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ?_Get_rest@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV?$tuple@$$V@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_rest@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV?$tuple@$$V@2@XZ PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get_rest, COMDAT

; 746  :         return *this;

	mov	rax, rcx

; 747  :     }

	ret	0
?_Get_rest@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV?$tuple@$$V@2@XZ ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ?_Adjust@?$uniform_int@J@std@@CAKK@Z
_TEXT	SEGMENT
_Uval$ = 8
?_Adjust@?$uniform_int@J@std@@CAKK@Z PROC		; std::uniform_int<long>::_Adjust, COMDAT

; 2213 :         if constexpr (is_signed_v<_Ty>) {
; 2214 :             constexpr _Uty _Adjuster = (static_cast<_Uty>(-1) >> 1) + 1; // 2^(N-1)
; 2215 :             return static_cast<_Uty>(_Uval ^ _Adjuster);

	btc	ecx, 31
	mov	eax, ecx

; 2216 :         } else { // _Ty is already unsigned, do nothing
; 2217 :             return _Uval;
; 2218 :         }
; 2219 :     }

	ret	0
?_Adjust@?$uniform_int@J@std@@CAKK@Z ENDP		; std::uniform_int<long>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ?_Get_random_product@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KKI@Z
_TEXT	SEGMENT
this$ = 48
_Index$ = 56
_Niter$dead$ = 64
?_Get_random_product@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KKI@Z PROC ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_random_product, COMDAT

; 2057 :     _Uprod _Get_random_product(const _Diff _Index, unsigned int _Niter) {

$LN17:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1417 :         return _Mybase::operator()();

	mov	rcx, QWORD PTR [rcx]

; 2057 :     _Uprod _Get_random_product(const _Diff _Index, unsigned int _Niter) {

	mov	ebx, edx

; 1417 :         return _Mybase::operator()();

	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 2058 :         _Udiff _Ret = _Get_bits();
; 2059 :         if constexpr (_Bits < _Udiff_bits) {
; 2060 :             while (--_Niter > 0) {
; 2061 :                 _Ret <<= _Bits;
; 2062 :                 _Ret |= _Get_bits();
; 2063 :             }
; 2064 :         }
; 2065 : 
; 2066 :         if constexpr (is_same_v<_Udiff, uint64_t>) {
; 2067 :             uint64_t _High;
; 2068 :             const auto _Low = _Base128::_UMul128(_Ret, static_cast<_Udiff>(_Index), _High);
; 2069 :             return _Uprod{_Low, _High};
; 2070 :         } else {
; 2071 :             return _Uprod{_Ret} * _Uprod{_Index};

	mov	eax, eax
	imul	rax, rbx

; 2072 :         }
; 2073 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Get_random_product@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAA_KKI@Z ENDP ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_random_product
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ?_Get_bits@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAAIXZ
_TEXT	SEGMENT
this$ = 8
?_Get_bits@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAAIXZ PROC ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits, COMDAT

; 1417 :         return _Mybase::operator()();

	mov	rcx, QWORD PTR [rcx]
	jmp	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
?_Get_bits@?$_Rng_from_urng_v2@KV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AEAAIXZ ENDP ; std::_Rng_from_urng_v2<unsigned long,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ
_TEXT	SEGMENT
this$ = 8
??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::operator(), COMDAT

; 1417 :         return _Mybase::operator()();

	jmp	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
??R?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QEAAIXZ ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ
_TEXT	SEGMENT
this$ = 16
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator(), COMDAT

; 1229 :     _NODISCARD result_type operator()() {

$LN37:
	sub	rsp, 8
	mov	r9, rcx

; 1230 :         if (this->_Idx == _Nx) {

	mov	r10d, 624				; 00000270H
	mov	ecx, DWORD PTR [rcx]
	cmp	ecx, r10d
	jne	SHORT $LN2@operator

; 1292 :         for (size_t _Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

	lea	r8, QWORD PTR [r9+8]
	npad	8
$LL9@operator:

; 1293 :             const _Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);

	mov	edx, DWORD PTR [r8-4]
	xor	edx, DWORD PTR [r8]
	lea	r8, QWORD PTR [r8+4]
	btr	edx, 31
	xor	edx, DWORD PTR [r8-8]

; 1294 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

	mov	eax, edx
	and	al, 1
	neg	al
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [r8+1580]
	xor	ecx, edx
	mov	DWORD PTR [r8+2488], ecx
	sub	r10, 1
	jne	SHORT $LL9@operator

; 1295 :         }
; 1296 :     }

	mov	ecx, DWORD PTR [r9]
	jmp	$LN4@operator
$LN2@operator:

; 1231 :             _Refill_upper();
; 1232 :         } else if (2 * _Nx <= this->_Idx) {

	cmp	ecx, 1248				; 000004e0H
	jb	$LN4@operator

; 1269 :             for (size_t _Ix = 0; _Ix < _Wrap_bound_m; ++_Ix) { // fill in lower region

	lea	r10, QWORD PTR [r9+2500]

; 1231 :             _Refill_upper();
; 1232 :         } else if (2 * _Nx <= this->_Idx) {

	mov	QWORD PTR [rsp], rbx

; 1269 :             for (size_t _Ix = 0; _Ix < _Wrap_bound_m; ++_Ix) { // fill in lower region

	mov	r11d, DWORD PTR [r10]
	mov	ebx, 227				; 000000e3H
$LL14@operator:

; 1270 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);

	mov	eax, r11d
	mov	r8, r10
	mov	r11d, DWORD PTR [r10+4]
	add	r10, 4
	mov	edx, r11d
	xor	edx, eax
	btr	edx, 31
	xor	edx, eax

; 1271 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _M_mod_n];

	mov	eax, edx
	and	al, 1
	neg	al
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [r8+1588]
	xor	ecx, edx
	mov	DWORD PTR [r8-2496], ecx
	sub	rbx, 1
	jne	SHORT $LL14@operator

; 1272 :             }
; 1273 : 
; 1274 :             for (size_t _Ix = _Wrap_bound_m; _Ix < _Wrap_bound_one; ++_Ix) {

	lea	r10, QWORD PTR [r9+3408]
	mov	ebx, 396				; 0000018cH
	mov	r11d, DWORD PTR [r10]
	npad	2
$LL17@operator:

; 1275 :                 // fill in upper region (avoids modulus operation)
; 1276 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);

	mov	eax, r11d
	mov	r8, r10
	mov	r11d, DWORD PTR [r10+4]
	mov	edx, eax
	xor	edx, r11d
	add	r10, 4
	btr	edx, 31
	xor	edx, eax

; 1277 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

	mov	eax, edx
	and	al, 1
	neg	al
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [r8-3404]
	xor	ecx, edx
	mov	DWORD PTR [r8-2496], ecx
	sub	rbx, 1
	jne	SHORT $LL17@operator

; 1278 :             }
; 1279 : 
; 1280 :             if constexpr (_One_mod_n == 1) { // fill in _Ax[_Nx - 1]
; 1281 :                 constexpr size_t _Ix = _Wrap_bound_one;
; 1282 : 
; 1283 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);

	mov	eax, DWORD PTR [r9+4992]
	mov	edx, eax
	xor	edx, DWORD PTR [r9+4]
	mov	rbx, QWORD PTR [rsp]
	btr	edx, 31
	xor	edx, eax

; 1284 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

	mov	eax, edx
	and	al, 1
	neg	al
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [r9+1588]
	xor	ecx, edx
	mov	DWORD PTR [r9+2496], ecx

; 1285 :             }
; 1286 :         }
; 1287 : 
; 1288 :         this->_Idx = 0;

	xor	ecx, ecx
	mov	DWORD PTR [r9], ecx
$LN4@operator:

; 1233 :             _Refill_lower();
; 1234 :         }
; 1235 : 
; 1236 :         _Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

	mov	eax, ecx
	mov	edx, DWORD PTR [r9+rax*4+4]
	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [r9], eax

; 1237 :         _Res ^= (_Res >> _Ux) & _Dxval;

	mov	ecx, edx
	mov	eax, DWORD PTR [r9+4996]
	shr	ecx, 11
	and	eax, ecx
	xor	edx, eax

; 1238 :         _Res ^= (_Res << _Sx) & _Bx;

	mov	eax, edx
	and	eax, -12953427				; ff3a58adH
	shl	eax, 7
	xor	edx, eax

; 1239 :         _Res ^= (_Res << _Tx) & _Cx;

	mov	eax, edx
	and	eax, -8308				; ffffdf8cH
	shl	eax, 15
	xor	edx, eax

; 1240 :         _Res ^= (_Res & _WMSK) >> _Lx;

	mov	eax, edx
	shr	eax, 18
	xor	eax, edx

; 1241 :         return _Res;
; 1242 :     }

	add	rsp, 8
	ret	0
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper, COMDAT

; 1292 :         for (size_t _Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

	lea	rax, QWORD PTR [rcx+8]
	mov	r9d, 624				; 00000270H
	npad	6
$LL4@Refill_upp:

; 1293 :             const _Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);

	mov	r8d, DWORD PTR [rax-4]
	xor	r8d, DWORD PTR [rax]
	lea	rax, QWORD PTR [rax+4]
	btr	r8d, 31
	xor	r8d, DWORD PTR [rax-8]

; 1294 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

	mov	ecx, r8d
	and	cl, 1
	neg	cl
	sbb	edx, edx
	shr	r8d, 1
	and	edx, -1727483681			; 9908b0dfH
	xor	edx, DWORD PTR [rax+1580]
	xor	edx, r8d
	mov	DWORD PTR [rax+2488], edx
	sub	r9, 1
	jne	SHORT $LL4@Refill_upp

; 1295 :         }
; 1296 :     }

	ret	0
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\random
;	COMDAT ?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower, COMDAT

; 1251 :     _Post_satisfies_(this->_Idx == 0) void _Refill_lower() {

$LN20:
	mov	QWORD PTR [rsp+8], rbx

; 1252 :         // compute values for the lower half of the history array
; 1253 :         constexpr size_t _Wrap_bound_one = _Nx - _One_mod_n;
; 1254 :         constexpr size_t _Wrap_bound_m   = _Nx - _M_mod_n;
; 1255 : 
; 1256 :         if constexpr (_M_mod_n == 0) {
; 1257 :             for (size_t _Ix = 0; _Ix < _Wrap_bound_one; ++_Ix) { // fill in values
; 1258 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);
; 1259 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _M_mod_n];
; 1260 :             }
; 1261 : 
; 1262 :             if constexpr (_One_mod_n == 1) { // fill in _Ax[_Nx - 1]
; 1263 :                 constexpr size_t _Ix = _Wrap_bound_one;
; 1264 : 
; 1265 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);
; 1266 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _M_mod_n];
; 1267 :             }
; 1268 :         } else {
; 1269 :             for (size_t _Ix = 0; _Ix < _Wrap_bound_m; ++_Ix) { // fill in lower region

	lea	r10, QWORD PTR [rcx+2500]
	mov	r9, rcx
	mov	r11d, DWORD PTR [r10]
	mov	ebx, 227				; 000000e3H
	npad	9
$LL4@Refill_low:

; 1270 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);

	mov	eax, r11d
	mov	r8, r10
	mov	r11d, DWORD PTR [r10+4]
	mov	edx, eax
	xor	edx, r11d
	add	r10, 4
	btr	edx, 31
	xor	edx, eax

; 1271 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _M_mod_n];

	mov	eax, edx
	and	al, 1
	neg	al
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [r8+1588]
	xor	ecx, edx
	mov	DWORD PTR [r8-2496], ecx
	sub	rbx, 1
	jne	SHORT $LL4@Refill_low

; 1272 :             }
; 1273 : 
; 1274 :             for (size_t _Ix = _Wrap_bound_m; _Ix < _Wrap_bound_one; ++_Ix) {

	lea	r10, QWORD PTR [r9+3408]
	mov	ebx, 396				; 0000018cH
	mov	r11d, DWORD PTR [r10]
	npad	2
$LL7@Refill_low:

; 1275 :                 // fill in upper region (avoids modulus operation)
; 1276 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + _One_mod_n] & _LMSK);

	mov	eax, r11d
	mov	r8, r10
	mov	r11d, DWORD PTR [r10+4]
	mov	edx, eax
	xor	edx, r11d
	add	r10, 4
	btr	edx, 31
	xor	edx, eax

; 1277 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];

	mov	eax, edx
	and	al, 1
	neg	al
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [r8-3404]
	xor	ecx, edx
	mov	DWORD PTR [r8-2496], ecx
	sub	rbx, 1
	jne	SHORT $LL7@Refill_low

; 1278 :             }
; 1279 : 
; 1280 :             if constexpr (_One_mod_n == 1) { // fill in _Ax[_Nx - 1]
; 1281 :                 constexpr size_t _Ix = _Wrap_bound_one;
; 1282 : 
; 1283 :                 const _Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + _One_mod_n] & _LMSK);

	mov	eax, DWORD PTR [r9+4992]
	mov	edx, eax
	xor	edx, DWORD PTR [r9+4]
	btr	edx, 31

; 1284 :                 this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _M_mod_n];
; 1285 :             }
; 1286 :         }
; 1287 : 
; 1288 :         this->_Idx = 0;

	mov	DWORD PTR [r9], ebx

; 1289 :     }

	mov	rbx, QWORD PTR [rsp+8]
	xor	edx, eax
	mov	eax, edx
	and	al, 1
	neg	al
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [r9+1588]
	xor	ecx, edx
	mov	DWORD PTR [r9+2496], ecx
	ret	0
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IEAAXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
_This_arg$ = 64
<_Rest_arg_0>$ = 72
??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>, COMDAT

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

$LN16:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rcx

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, r9
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	lea	rcx, QWORD PTR [rdi+32]

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$dead$ = 56
_This_arg$ = 64
<_Rest_arg_0>$ = 72
?dtor$0@?0???$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z@4HA PROC ; `std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAV21@$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@1@Z@4HA ENDP ; `std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0AEAVClient@@@?$_Tuple_val@VClient@@@std@@QEAA@AEAVClient@@@Z
_TEXT	SEGMENT
this$ = 48
_Arg$ = 56
??$?0AEAVClient@@@?$_Tuple_val@VClient@@@std@@QEAA@AEAVClient@@@Z PROC ; std::_Tuple_val<Client>::_Tuple_val<Client><Client &>, COMDAT

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??0Client@@QEAA@AEBV0@@Z
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0AEAVClient@@@?$_Tuple_val@VClient@@@std@@QEAA@AEAVClient@@@Z ENDP ; std::_Tuple_val<Client>::_Tuple_val<Client><Client &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AEBJ$$V$0A@@?$tuple@AEBJ@std@@QEAA@U_Exact_args_t@1@AEBJ@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_This_arg$ = 24
??$?0U_Exact_args_t@std@@AEBJ$$V$0A@@?$tuple@AEBJ@std@@QEAA@U_Exact_args_t@1@AEBJ@Z PROC ; std::tuple<long const &>::tuple<long const &><std::_Exact_args_t,long const &,0>, COMDAT

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], r8

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	rax, rcx
	ret	0
??$?0U_Exact_args_t@std@@AEBJ$$V$0A@@?$tuple@AEBJ@std@@QEAA@U_Exact_args_t@1@AEBJ@Z ENDP ; std::tuple<long const &>::tuple<long const &><std::_Exact_args_t,long const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBJ@0@$$QEAV?$tuple@$$V@0@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$dead$ = 56
<_Args_1>$ = 64
<_Args_2>$dead$ = 72
??$construct_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBJ@0@$$QEAV?$tuple@$$V@0@@Z PROC ; std::construct_at<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<>,0>, COMDAT

; 374  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple

; 362  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 374  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 307  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	edx, DWORD PTR [rax]
	mov	DWORD PTR [rcx], edx
	add	rcx, 8
	call	??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rbx

; 376  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct_at@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBJ@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBJ@0@$$QEAV?$tuple@$$V@0@@Z ENDP ; std::construct_at<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::piecewise_construct_t const &,std::tuple<long const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEAE@std@@YAAEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAE@std@@YAAEAEAEAE@Z PROC			; std::forward<unsigned char &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEAE@std@@YAAEAEAEAE@Z ENDP			; std::forward<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z PROC ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ENDP ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??0?$tuple@AEBJ@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$tuple@AEBJ@std@@QEAA@$$QEAV01@@Z PROC		; std::tuple<long const &>::tuple<long const &>, COMDAT

; 362  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0?$tuple@AEBJ@std@@QEAA@$$QEAV01@@Z ENDP		; std::tuple<long const &>::tuple<long const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$?0AEBJ$$Z$$V@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
_Val1$ = 64
_Val2$dead$ = 72
??$?0AEBJ$$Z$$V@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@Z PROC ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > ><long const &>, COMDAT

; 311  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H

; 307  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR [r8]

; 311  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rbx, rcx

; 307  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	edx, DWORD PTR [rax]
	mov	DWORD PTR [rcx], edx
	add	rcx, 8
	call	??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>

; 311  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0AEBJ$$Z$$V@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBJ@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > ><long const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$V$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
_This_arg$ = 64
??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$V$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>, COMDAT

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	rdx, r8

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	rbx, rcx

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 313  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0U_Exact_args_t@std@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$V$0A@@?$tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U_Exact_args_t@1@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::_Exact_args_t,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Arg$ = 56
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT

; 247  :     constexpr tuple(_Tag) noexcept /* strengthened */ {}

	mov	rax, rcx
	ret	0
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QEAA@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$?0AEBJ@?$_Tuple_val@AEBJ@std@@QEAA@AEBJ@Z
_TEXT	SEGMENT
this$ = 8
_Arg$ = 16
??$?0AEBJ@?$_Tuple_val@AEBJ@std@@QEAA@AEBJ@Z PROC	; std::_Tuple_val<long const &>::_Tuple_val<long const &><long const &>, COMDAT

; 143  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??$?0AEBJ@?$_Tuple_val@AEBJ@std@@QEAA@AEBJ@Z ENDP	; std::_Tuple_val<long const &>::_Tuple_val<long const &><long const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z PROC	; std::construct_at<unsigned char,unsigned char &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z ENDP	; std::construct_at<unsigned char,unsigned char &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$?0V?$tuple@AEBJ@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@AEAV?$tuple@AEBJ@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$dead$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$?0V?$tuple@AEBJ@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@AEAV?$tuple@AEBJ@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > ><std::tuple<long const &>,std::tuple<>,0>, COMDAT

; 307  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rdx]
	mov	rbx, rcx
	mov	edx, DWORD PTR [rax]
	mov	DWORD PTR [rcx], edx
	add	rcx, 8
	call	??$?0VClient@@$0A@@?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@QEAA@XZ ; std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Client,0>
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0V?$tuple@AEBJ@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBJV?$tuple@VClient@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@std@@@std@@QEAA@AEAV?$tuple@AEBJ@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pair<long const ,std::tuple<Client,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > ><std::tuple<long const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\tuple
;	COMDAT ??$_Tuple_get@$0A@AEBJ@std@@YA$$QEA_P$$QEAV?$tuple@AEBJ@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$_Tuple_get@$0A@AEBJ@std@@YA$$QEA_P$$QEAV?$tuple@AEBJ@0@@Z PROC ; std::_Tuple_get<0,long const &>, COMDAT

; 959  :     // used by pair's piecewise constructor
; 960  :     using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
; 961  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 962  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

	mov	rax, QWORD PTR [rcx]

; 963  : }

	ret	0
??$_Tuple_get@$0A@AEBJ@std@@YA$$QEA_P$$QEAV?$tuple@AEBJ@0@@Z ENDP ; std::_Tuple_get<0,long const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAV?$tuple@AEBJ@std@@@std@@YA$$QEAV?$tuple@AEBJ@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$tuple@AEBJ@std@@@std@@YA$$QEAV?$tuple@AEBJ@0@AEAV10@@Z PROC ; std::move<std::tuple<long const &> &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAV?$tuple@AEBJ@std@@@std@@YA$$QEAV?$tuple@AEBJ@0@AEAV10@@Z ENDP ; std::move<std::tuple<long const &> &>
_TEXT	ENDS
END
