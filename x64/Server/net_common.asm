; Listing generated by Microsoft (R) Optimizing Compiler Version 19.40.33811.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	?BindSocket@@3P6AH_KPEBUsockaddr@@H@ZEA		; BindSocket
PUBLIC	?SocketListen@@3P6AH_KH@ZEA			; SocketListen
PUBLIC	?CleanWSA@@3P6AHXZEA				; CleanWSA
PUBLIC	?StartWSA@@3P6AHGPEAUWSAData@@@ZEA		; StartWSA
PUBLIC	?CreateSocket@@3P6A_KHHH@ZEA			; CreateSocket
PUBLIC	?WSAInitialized@NetCommon@@3HA			; NetCommon::WSAInitialized
;	COMDAT ?BindSocket@@3P6AH_KPEBUsockaddr@@H@ZEA
_BSS	SEGMENT
?BindSocket@@3P6AH_KPEBUsockaddr@@H@ZEA DQ 01H DUP (?)	; BindSocket
_BSS	ENDS
;	COMDAT ?SocketListen@@3P6AH_KH@ZEA
_BSS	SEGMENT
?SocketListen@@3P6AH_KH@ZEA DQ 01H DUP (?)		; SocketListen
_BSS	ENDS
;	COMDAT ?CleanWSA@@3P6AHXZEA
_BSS	SEGMENT
?CleanWSA@@3P6AHXZEA DQ 01H DUP (?)			; CleanWSA
_BSS	ENDS
;	COMDAT ?StartWSA@@3P6AHGPEAUWSAData@@@ZEA
_BSS	SEGMENT
?StartWSA@@3P6AHGPEAUWSAData@@@ZEA DQ 01H DUP (?)	; StartWSA
_BSS	ENDS
;	COMDAT ?CreateSocket@@3P6A_KHHH@ZEA
_BSS	SEGMENT
?CreateSocket@@3P6A_KHHH@ZEA DQ 01H DUP (?)		; CreateSocket
_BSS	ENDS
;	COMDAT ?WSAInitialized@NetCommon@@3HA
_BSS	SEGMENT
?WSAInitialized@NetCommon@@3HA DD 01H DUP (?)		; NetCommon::WSAInitialized
_BSS	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
PUBLIC	??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z	; std::construct_at<unsigned char,unsigned char,0>
PUBLIC	??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z	; std::construct_at<unsigned char,0>
PUBLIC	??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
PUBLIC	??$forward@E@std@@YA$$QEAEAEAE@Z		; std::forward<unsigned char>
PUBLIC	??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z	; std::construct_at<unsigned char,unsigned char const &,0>
PUBLIC	??$addressof@E@std@@YAPEAEAEAE@Z		; std::addressof<unsigned char>
PUBLIC	??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>
PUBLIC	??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
PUBLIC	??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$move@AEAE@std@@YA$$QEAEAEAE@Z		; std::move<unsigned char &>
PUBLIC	??$to_address@E@std@@YAPEAEQEAE@Z		; std::to_address<unsigned char>
PUBLIC	??$to_address@D@std@@YAPEADQEAD@Z		; std::to_address<char>
PUBLIC	?allocate@?$allocator@E@std@@QEAAPEAE_K@Z	; std::allocator<unsigned char>::allocate
PUBLIC	??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z ; std::_Refancy_maybe_null<unsigned char *,0>
PUBLIC	??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
PUBLIC	??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z	; std::_Construct_in_place<unsigned char,unsigned char const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>
PUBLIC	??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Unfancy@E@std@@YAPEAEPEAE@Z			; std::_Unfancy<unsigned char>
PUBLIC	??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z	; std::_Get_unwrapped<unsigned char * const &>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
PUBLIC	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z	; std::_To_address<unsigned char *>
PUBLIC	??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z	; std::_To_address<char *>
PUBLIC	??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z ; std::_Copy_memmove<char *,unsigned char *>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::__autoclassinit2
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z	; std::forward<unsigned char *>
PUBLIC	??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::forward<std::allocator<unsigned char> >
PUBLIC	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>
PUBLIC	??$forward@AEBE@std@@YAAEBEAEBE@Z		; std::forward<unsigned char const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
PUBLIC	??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z ; std::_Copy_unchecked<char *,char *,unsigned char *>
PUBLIC	??0?$allocator@E@std@@QEAA@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
PUBLIC	??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>
PUBLIC	??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ; std::exchange<unsigned char *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::move<std::allocator<unsigned char> &>
PUBLIC	??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z	; std::_Unfancy_maybe_null<unsigned char>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &,__int64>
PUBLIC	??$_Idl_distance@PEADPEAD@std@@YA?A_PAEBQEAD0@Z	; std::_Idl_distance<char *,char *>
PUBLIC	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z	; std::_Get_unwrapped<char * &>
PUBLIC	??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z ; std::copy<char *,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
PUBLIC	??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,int)>
PUBLIC	??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>
PUBLIC	??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>
PUBLIC	??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>
PUBLIC	??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
PUBLIC	??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>
PUBLIC	??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>
PUBLIC	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
PUBLIC	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?KEY_256_ASSIST_1@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z ; Cipher::Aes<256>::KEY_256_ASSIST_1
PUBLIC	?KEY_256_ASSIST_2@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z ; Cipher::Aes<256>::KEY_256_ASSIST_2
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ; Cipher::Aes<256>::AES_256_Key_Expansion
PUBLIC	?data@?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEBAPEBDXZ ; ay::obfuscator<13,-8505844796237434571,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ ; ay::obfuscated_data<13,-8505844796237434571,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,-4962681195322312931,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,-4962681195322312931,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,-1502061074894816457,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,-1502061074894816457,char>::decrypt
PUBLIC	?data@?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@ay@@QEBAPEBDXZ ; ay::obfuscator<5,-769018879138130635,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAXXZ ; ay::obfuscated_data<5,-769018879138130635,char>::decrypt
PUBLIC	?data@?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEBAPEBDXZ ; ay::obfuscator<12,-17003346941488231,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ ; ay::obfuscated_data<12,-17003346941488231,char>::decrypt
PUBLIC	?data@?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<7,-7217698246706230297,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<7,-7217698246706230297,char>::decrypt
PUBLIC	?data@?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@ay@@QEBAPEBDXZ ; ay::obfuscator<5,4171390554486297459,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAXXZ ; ay::obfuscated_data<5,4171390554486297459,char>::decrypt
PUBLIC	?data@?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<7,-7558938099074472137,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<7,-7558938099074472137,char>::decrypt
PUBLIC	?data@?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEBAPEBDXZ ; ay::obfuscator<9,-4071404544105560167,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ ; ay::obfuscated_data<9,-4071404544105560167,char>::decrypt
PUBLIC	?data@?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEBAPEBDXZ ; ay::obfuscator<5,-3929642162503730297,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAXXZ ; ay::obfuscated_data<5,-3929642162503730297,char>::decrypt
PUBLIC	?data@?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEBAPEBDXZ ; ay::obfuscator<11,9007561748555066333,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ ; ay::obfuscated_data<11,9007561748555066333,char>::decrypt
PUBLIC	?data@?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@ay@@QEBAPEBDXZ ; ay::obfuscator<8,-8716755408375925265,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ ; ay::obfuscated_data<8,-8716755408375925265,char>::decrypt
PUBLIC	?data@?$obfuscator@$06$0HPNDKNLBIBOBFLON@D@ay@@QEBAPEBDXZ ; ay::obfuscator<7,9210896640802642925,char>::data
PUBLIC	?decrypt@?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAAXXZ ; ay::obfuscated_data<7,9210896640802642925,char>::decrypt
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::data
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
PUBLIC	??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z		; Cipher::Aes<256>::Aes<256>
PUBLIC	??1?$Aes@$0BAA@@Cipher@@QEAA@XZ			; Cipher::Aes<256>::~Aes<256>
PUBLIC	?encrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z	; Cipher::Aes<256>::encrypt_block
PUBLIC	??0?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@1@@Z ; ay::obfuscated_data<13,-8505844796237434571,char>::obfuscated_data<13,-8505844796237434571,char>
PUBLIC	??1?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@XZ ; ay::obfuscated_data<13,-8505844796237434571,char>::~obfuscated_data<13,-8505844796237434571,char>
PUBLIC	??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<13,-8505844796237434571,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@1@@Z ; ay::obfuscated_data<11,-4962681195322312931,char>::obfuscated_data<11,-4962681195322312931,char>
PUBLIC	??1?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,-4962681195322312931,char>::~obfuscated_data<11,-4962681195322312931,char>
PUBLIC	??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,-4962681195322312931,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@1@@Z ; ay::obfuscated_data<11,-1502061074894816457,char>::obfuscated_data<11,-1502061074894816457,char>
PUBLIC	??1?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,-1502061074894816457,char>::~obfuscated_data<11,-1502061074894816457,char>
PUBLIC	??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,-1502061074894816457,char>::operator char *
PUBLIC	??0?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@AEBV?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@1@@Z ; ay::obfuscated_data<5,-769018879138130635,char>::obfuscated_data<5,-769018879138130635,char>
PUBLIC	??1?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@XZ ; ay::obfuscated_data<5,-769018879138130635,char>::~obfuscated_data<5,-769018879138130635,char>
PUBLIC	??B?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<5,-769018879138130635,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@1@@Z ; ay::obfuscated_data<12,-17003346941488231,char>::obfuscated_data<12,-17003346941488231,char>
PUBLIC	??1?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@XZ ; ay::obfuscated_data<12,-17003346941488231,char>::~obfuscated_data<12,-17003346941488231,char>
PUBLIC	??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<12,-17003346941488231,char>::operator char *
PUBLIC	??0?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@1@@Z ; ay::obfuscated_data<7,-7217698246706230297,char>::obfuscated_data<7,-7217698246706230297,char>
PUBLIC	??1?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<7,-7217698246706230297,char>::~obfuscated_data<7,-7217698246706230297,char>
PUBLIC	??B?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<7,-7217698246706230297,char>::operator char *
PUBLIC	??0?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@AEBV?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@1@@Z ; ay::obfuscated_data<5,4171390554486297459,char>::obfuscated_data<5,4171390554486297459,char>
PUBLIC	??1?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@XZ ; ay::obfuscated_data<5,4171390554486297459,char>::~obfuscated_data<5,4171390554486297459,char>
PUBLIC	??B?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<5,4171390554486297459,char>::operator char *
PUBLIC	??0?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@1@@Z ; ay::obfuscated_data<7,-7558938099074472137,char>::obfuscated_data<7,-7558938099074472137,char>
PUBLIC	??1?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<7,-7558938099074472137,char>::~obfuscated_data<7,-7558938099074472137,char>
PUBLIC	??B?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<7,-7558938099074472137,char>::operator char *
PUBLIC	??0?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@AEBV?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@1@@Z ; ay::obfuscated_data<9,-4071404544105560167,char>::obfuscated_data<9,-4071404544105560167,char>
PUBLIC	??1?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@XZ ; ay::obfuscated_data<9,-4071404544105560167,char>::~obfuscated_data<9,-4071404544105560167,char>
PUBLIC	??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<9,-4071404544105560167,char>::operator char *
PUBLIC	??0?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@1@@Z ; ay::obfuscated_data<5,-3929642162503730297,char>::obfuscated_data<5,-3929642162503730297,char>
PUBLIC	??1?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@XZ ; ay::obfuscated_data<5,-3929642162503730297,char>::~obfuscated_data<5,-3929642162503730297,char>
PUBLIC	??B?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<5,-3929642162503730297,char>::operator char *
PUBLIC	??0?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@1@@Z ; ay::obfuscated_data<11,9007561748555066333,char>::obfuscated_data<11,9007561748555066333,char>
PUBLIC	??1?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@XZ ; ay::obfuscated_data<11,9007561748555066333,char>::~obfuscated_data<11,9007561748555066333,char>
PUBLIC	??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<11,9007561748555066333,char>::operator char *
PUBLIC	??0?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@1@@Z ; ay::obfuscated_data<8,-8716755408375925265,char>::obfuscated_data<8,-8716755408375925265,char>
PUBLIC	??1?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@XZ ; ay::obfuscated_data<8,-8716755408375925265,char>::~obfuscated_data<8,-8716755408375925265,char>
PUBLIC	??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<8,-8716755408375925265,char>::operator char *
PUBLIC	??0?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAA@AEBV?$obfuscator@$06$0HPNDKNLBIBOBFLON@D@1@@Z ; ay::obfuscated_data<7,9210896640802642925,char>::obfuscated_data<7,9210896640802642925,char>
PUBLIC	??1?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAA@XZ ; ay::obfuscated_data<7,9210896640802642925,char>::~obfuscated_data<7,9210896640802642925,char>
PUBLIC	??B?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAAPEADXZ ; ay::obfuscated_data<7,9210896640802642925,char>::operator char *
PUBLIC	??0NET_BLOB@@QEAA@AEBU0@@Z			; NET_BLOB::NET_BLOB
PUBLIC	?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z ; NetCommon::AESEncryptBlob
PUBLIC	??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	??__Fobfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
PUBLIC	?LoadWSAFunctions@NetCommon@@YAXXZ		; NetCommon::LoadWSAFunctions
PUBLIC	??0ClientRequest@@QEAA@AEBU0@@Z			; ClientRequest::ClientRequest
PUBLIC	??0ProcessInformation@@QEAA@AEBU0@@Z		; ProcessInformation::ProcessInformation
PUBLIC	??0ServerCommand@@QEAA@AEBU0@@Z			; ServerCommand::ServerCommand
PUBLIC	??1ProcessInformation@@QEAA@XZ			; ProcessInformation::~ProcessInformation
PUBLIC	??1ServerCommand@@QEAA@XZ			; ServerCommand::~ServerCommand
PUBLIC	??1ClientRequest@@QEAA@XZ			; ClientRequest::~ClientRequest
PUBLIC	??1NET_BLOB@@QEAA@XZ				; NET_BLOB::~NET_BLOB
PUBLIC	?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z	; NetCommon::IsBlobValid
PUBLIC	?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2
PUBLIC	?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::SerializeString
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
;	COMDAT ?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A DQ 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A DB 0cH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A DB 06H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A DB 06H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A DB 0bH DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51 DD 01H DUP (?) ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A DB 06H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A DB 09H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4V45@A DQ 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A DB 0cH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A DB 0aH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A DB 0cH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A DB 0eH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A DQ 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::obfuscated_data
_TLS	ENDS
;	COMDAT ??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
_TLS	SEGMENT
??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51 DD 01H DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`local static thread guard'
_TLS	ENDS
;	COMDAT ?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A
_TLS	SEGMENT
?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A DB 0dH DUP (?) ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::obfuscated_data
?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::kernel32
?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::ntdll
?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 020H DUP (?) ; ProcessUtilities::freqDLLS::advapi32
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD imagerel $LN30
	DD	imagerel $LN30+88
	DD	imagerel $unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD imagerel $LN24
	DD	imagerel $LN24+49
	DD	imagerel $unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z DD imagerel $LN33
	DD	imagerel $LN33+91
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+131
	DD	imagerel $unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD imagerel $LN128
	DD	imagerel $LN128+64
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD imagerel $LN128+64
	DD	imagerel $LN128+305
	DD	imagerel $chain$2$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD imagerel $LN128+305
	DD	imagerel $LN128+317
	DD	imagerel $chain$4$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD imagerel $LN128+317
	DD	imagerel $LN128+323
	DD	imagerel $chain$5$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z DD imagerel $LN29
	DD	imagerel $LN29+41
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN108
	DD	imagerel $LN108+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN108+34
	DD	imagerel $LN108+244
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN108+244
	DD	imagerel $LN108+256
	DD	imagerel $chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN108+256
	DD	imagerel $LN108+262
	DD	imagerel $chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN99
	DD	imagerel $LN99+242
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN38
	DD	imagerel $LN38+125
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z DD imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD imagerel $LN23
	DD	imagerel $LN23+61
	DD	imagerel $unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+87
	DD	imagerel $unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN123
	DD	imagerel $LN123+276
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD imagerel $LN35
	DD	imagerel $LN35+87
	DD	imagerel $unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+125
	DD	imagerel $unwind$?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0NET_BLOB@@QEAA@AEBU0@@Z DD imagerel $LN19
	DD	imagerel $LN19+239
	DD	imagerel $unwind$??0NET_BLOB@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DD imagerel $LN294
	DD	imagerel $LN294+662
	DD	imagerel $unwind$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ DD imagerel ??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ
	DD	imagerel ??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ+91
	DD	imagerel $unwind$??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DD imagerel ??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
	DD	imagerel ??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ+100
	DD	imagerel $unwind$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DD imagerel ??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
	DD	imagerel ??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ+98
	DD	imagerel $unwind$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DD imagerel ??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
	DD	imagerel ??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ+90
	DD	imagerel $unwind$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DD imagerel ??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
	DD	imagerel ??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ+97
	DD	imagerel $unwind$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DD imagerel ??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
	DD	imagerel ??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ+91
	DD	imagerel $unwind$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DD imagerel ??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
	DD	imagerel ??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ+90
	DD	imagerel $unwind$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DD imagerel ??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
	DD	imagerel ??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ+91
	DD	imagerel $unwind$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DD imagerel ??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
	DD	imagerel ??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ+107
	DD	imagerel $unwind$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DD imagerel ??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
	DD	imagerel ??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ+90
	DD	imagerel $unwind$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DD imagerel ??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ+98
	DD	imagerel $unwind$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DD imagerel ??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ+98
	DD	imagerel $unwind$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DD imagerel ??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ+104
	DD	imagerel $unwind$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LoadWSAFunctions@NetCommon@@YAXXZ DD imagerel $LN1149
	DD	imagerel $LN1149+3314
	DD	imagerel $unwind$?LoadWSAFunctions@NetCommon@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$30@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$30@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$30@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$30@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$39@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$39@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$39@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$39@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$51@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$51@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$51@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$51@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$57@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$57@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$57@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$57@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$63@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$63@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$63@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$63@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$69@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$69@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$69@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$69@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$75@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$75@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$75@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$75@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$78@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD imagerel ?dtor$78@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DD	imagerel ?dtor$78@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$78@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ+202
	DD	imagerel $unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ+104
	DD	imagerel $unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ+191
	DD	imagerel $unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DD imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ+101
	DD	imagerel $unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ+99
	DD	imagerel $unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ+202
	DD	imagerel $unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ+104
	DD	imagerel $unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA+59
	DD	imagerel $unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ClientRequest@@QEAA@AEBU0@@Z DD imagerel $LN6
	DD	imagerel $LN6+49
	DD	imagerel $unwind$??0ClientRequest@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ProcessInformation@@QEAA@AEBU0@@Z DD imagerel $LN6
	DD	imagerel $LN6+47
	DD	imagerel $unwind$??0ProcessInformation@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ServerCommand@@QEAA@AEBU0@@Z DD imagerel $LN11
	DD	imagerel $LN11+105
	DD	imagerel $unwind$??0ServerCommand@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ProcessInformation@@QEAA@XZ DD imagerel $LN48
	DD	imagerel $LN48+96
	DD	imagerel $unwind$??1ProcessInformation@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ServerCommand@@QEAA@XZ DD imagerel $LN134
	DD	imagerel $LN134+250
	DD	imagerel $unwind$??1ServerCommand@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ClientRequest@@QEAA@XZ DD imagerel $LN48
	DD	imagerel $LN48+96
	DD	imagerel $unwind$??1ClientRequest@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1NET_BLOB@@QEAA@XZ DD imagerel $LN94
	DD	imagerel $LN94+195
	DD	imagerel $unwind$??1NET_BLOB@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z DD imagerel $LN14
	DD	imagerel $LN14+69
	DD	imagerel $unwind$?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD imagerel $LN96
	DD	imagerel $LN96+284
	DD	imagerel $unwind$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA DD imagerel ?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA
	DD	imagerel ?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 04H
	DB	085H, 02H
	DB	04H
	DB	0baH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	imagerel $ip2state$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 082119H
	DD	0f5412H
	DD	0e3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1NET_BLOB@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ClientRequest@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ServerCommand@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ProcessInformation@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ServerCommand@@QEAA@AEBU0@@Z DB 06H
	DB	'h'
	DB	00H
	DB	01cH
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ServerCommand@@QEAA@AEBU0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ServerCommand@@QEAA@AEBU0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0ServerCommand@@QEAA@AEBU0@@Z
	DD	imagerel $ip2state$??0ServerCommand@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ServerCommand@@QEAA@AEBU0@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ServerCommand@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ProcessInformation@@QEAA@AEBU0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ClientRequest@@QEAA@AEBU0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	09eH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	09eH
	DB	02H
	DB	0caH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	098H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	098H
	DB	02H
	DB	0baH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	09eH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 04H
	DB	09eH
	DB	02H
	DB	0caH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
	DD	imagerel $ip2state$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$78@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$75@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$69@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$63@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$57@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$51@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$39@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$30@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?LoadWSAFunctions@NetCommon@@YAXXZ DB 'R'
	DB	09aH
	DB	00H
	DB	'h'
	DB	02H
	DB	'V'
	DB	00H
	DB	0ccH
	DB	04H
	DB	':'
	DB	00H
	DB	019H, 02H
	DB	06H
	DB	0a4H
	DB	00H
	DB	','
	DB	08H
	DB	')', 02H
	DB	0aH
	DB	0b6H
	DB	00H
	DB	'2'
	DB	0cH
	DB	015H, 02H
	DB	0eH
	DB	0a4H
	DB	00H
	DB	'`'
	DB	010H
	DB	'\'
	DB	00H
	DB	0c2H
	DB	0cH
	DB	'6'
	DB	00H
	DB	0d8H
	DB	012H
	DB	0b4H
	DB	00H
	DB	'2'
	DB	0cH
	DB	015H, 02H
	DB	014H
	DB	0a4H
	DB	00H
	DB	'2'
	DB	0cH
	DB	0faH
	DB	016H
	DB	0b4H
	DB	00H
	DB	'2'
	DB	0cH
	DB	0dH, 02H
	DB	018H
	DB	0a8H
	DB	00H
	DB	'2'
	DB	0cH
	DB	0f8H
	DB	01aH
	DB	0a0H
	DB	00H
	DB	'2'
	DB	0cH
	DB	011H, 02H
	DB	01cH
	DB	0a8H
	DB	00H
	DB	'2'
	DB	0cH
	DB	'=', 02H
	DB	01eH
	DB	0a8H
	DB	00H
	DB	'R'
	DB	' '
	DB	'<'
	DB	00H
	DB	0d0H
	DB	0cH
	DB	':'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?LoadWSAFunctions@NetCommon@@YAXXZ DB 020H
	DB	0eH
	DD	imagerel ?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
	DB	066H
	DD	imagerel ?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	08aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	0beH
	DD	imagerel ?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0e4H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	02dH
	DB	02H
	DD	imagerel ?dtor$30@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	08dH
	DB	02H
	DD	imagerel ?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0edH
	DB	02H
	DD	imagerel ?dtor$39@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	04dH
	DB	03H
	DD	imagerel ?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0adH
	DB	03H
	DD	imagerel ?dtor$51@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0dH
	DB	04H
	DD	imagerel ?dtor$57@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	06dH
	DB	04H
	DD	imagerel ?dtor$63@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	0cdH
	DB	04H
	DD	imagerel ?dtor$69@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	02dH
	DB	05H
	DD	imagerel ?dtor$75@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
	DB	08dH
	DB	05H
	DD	imagerel ?dtor$78@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?LoadWSAFunctions@NetCommon@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?LoadWSAFunctions@NetCommon@@YAXXZ
	DD	imagerel $ip2state$?LoadWSAFunctions@NetCommon@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LoadWSAFunctions@NetCommon@@YAXXZ DD 0b3419H
	DD	04e7423H
	DD	04d6423H
	DD	04c3423H
	DD	0480123H
	DD	0e012f014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?LoadWSAFunctions@NetCommon@@YAXXZ
	DD	0232H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DB 02H
	DB	09eH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DB 02H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DB 02H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DB 02H
	DB	082H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DB 02H
	DB	0a4H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DB 02H
	DB	084H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DB 02H
	DB	082H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DB 02H
	DB	084H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DB 02H
	DB	090H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DB 02H
	DB	082H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DB 02H
	DB	092H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DB 02H
	DB	096H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4HA DD 010201H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ DB 02H
	DB	084H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ
	DD	imagerel $ip2state$??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DB 08H
	DB	08aH
	DB	02H
	DB	0beH
	DB	04H
	DB	0c9H, 05H
	DB	02H
	DB	0aeH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1NET_BLOB@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
	DD	imagerel $ip2state$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z DD 092e19H
	DD	03b641dH
	DD	03a341dH
	DD	034011dH
	DD	0700ce00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
	DD	0192H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0NET_BLOB@@QEAA@AEBU0@@Z DB 0aH
	DB	'h'
	DB	00H
	DB	'^'
	DB	02H
	DB	01cH
	DB	04H
	DB	'"'
	DB	06H
	DB	0a8H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0NET_BLOB@@QEAA@AEBU0@@Z DB 08H
	DB	0cH
	DD	imagerel ??1ClientRequest@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$4@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA
	DB	086H
	DD	imagerel ?dtor$1@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0NET_BLOB@@QEAA@AEBU0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0NET_BLOB@@QEAA@AEBU0@@Z
	DD	imagerel $ip2state$??0NET_BLOB@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0NET_BLOB@@QEAA@AEBU0@@Z DD 061411H
	DD	096414H
	DD	083414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0NET_BLOB@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0ceH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 041919H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 060c01H
	DD	0b340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN108
	DD	imagerel $LN108+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060021H
	DD	04f400H
	DD	057400H
	DD	0c6400H
	DD	imagerel $LN108
	DD	imagerel $LN108+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 061221H
	DD	04f412H
	DD	05740dH
	DD	0c6405H
	DD	imagerel $LN108
	DD	imagerel $LN108+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040901H
	DD	0e0055209H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD 021H
	DD	imagerel $LN128
	DD	imagerel $LN128+64
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD 060021H
	DD	04c400H
	DD	056400H
	DD	0e3400H
	DD	imagerel $LN128
	DD	imagerel $LN128+64
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD 061521H
	DD	04c415H
	DD	05640aH
	DD	0e3405H
	DD	imagerel $LN128
	DD	imagerel $LN128+64
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD 060d01H
	DD	0f009520dH
	DD	0d005e007H
	DD	050027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
?kernel32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::kernel32$initializer$
?ntdll$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::ntdll$initializer$
?advapi32$initializer$@freqDLLS@ProcessUtilities@@3P6AXXZEA DQ FLAT:??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::advapi32$initializer$
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1150 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1151 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1156 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
_TEXT	SEGMENT
c$1 = 32
$T2 = 36
__$ReturnUdt$GSCopy$ = 40
s$GSCopy$ = 48
__$ArrayPad$ = 56
__$ReturnUdt$ = 96
s$ = 104
?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; NetCommon::SerializeString, COMDAT

; 61   :     inline BYTESTRING SerializeString(std::string s) {

$LN96:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR s$GSCopy$[rsp], rdx
	xor	r14d, r14d
	mov	DWORD PTR $T2[rsp], r14d
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], r14
	mov	QWORD PTR [rcx+8], r14
	mov	QWORD PTR [rcx+16], r14
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 62   :         BYTESTRING bs;

	mov	DWORD PTR $T2[rsp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN90@SerializeS

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdx]
	mov	rcx, rdi
	mov	rdx, rdi
	jmp	SHORT $LN35@SerializeS
$LN90@SerializeS:
	mov	rdi, rsi
	mov	rcx, rsi
$LN35@SerializeS:

; 3987 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	rbp, QWORD PTR [rsi+16]
	add	rbp, rcx
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 63   :         for ( BYTE c : s )

	cmp	rdx, rbp
	je	SHORT $LN3@SerializeS
	npad	10
$LL4@SerializeS:
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR c$1[rsp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 775  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+8]
	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN44@SerializeS

; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], al

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;
; 800  :         ++_Mylast;

	inc	QWORD PTR [rbx+8]

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@SerializeS
$LN44@SerializeS:

; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR c$1[rsp]
	mov	rcx, rbx
	call	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
$LN2@SerializeS:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 63   :         for ( BYTE c : s )

	inc	rdi
	cmp	rdi, rbp
	jne	SHORT $LL4@SerializeS
$LN3@SerializeS:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rsi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN65@SerializeS

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rsi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN79@SerializeS

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN76@SerializeS

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN79@SerializeS:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN65@SerializeS:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rsi+16], r14

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rsi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rsi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 65   :         return bs;

	mov	rax, rbx

; 66   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN76@SerializeS:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN93@SerializeS:
?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; NetCommon::SerializeString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
c$1 = 32
$T2 = 36
__$ReturnUdt$GSCopy$ = 40
s$GSCopy$ = 48
__$ArrayPad$ = 56
__$ReturnUdt$ = 96
s$ = 104
?dtor$0@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::SerializeString'::`1'::dtor$0
	mov	rcx, QWORD PTR s$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::SerializeString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
c$1 = 32
$T2 = 36
__$ReturnUdt$GSCopy$ = 40
s$GSCopy$ = 48
__$ArrayPad$ = 56
__$ReturnUdt$ = 96
s$ = 104
?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA PROC ; `NetCommon::SerializeString'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$1
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
$LN8@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z@4HA ENDP ; `NetCommon::SerializeString'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
;	COMDAT ?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z
_TEXT	SEGMENT
b$ = 48
?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z PROC		; NetCommon::IsBlobValid, COMDAT

; 104  :     inline BOOL IsBlobValid(NET_BLOB b) {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4279 :         return _Mypair._Myval2._Mysize == 0;

	cmp	QWORD PTR [rcx+236], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 105  :         return !b.aesKey.empty() && b.cr.valid || b.sr.valid || b.udp.isValid;

	je	SHORT $LN3@IsBlobVali
	cmp	DWORD PTR [rcx], 0
	jne	SHORT $LN4@IsBlobVali
$LN3@IsBlobVali:
	cmp	BYTE PTR [rcx+48], 0
	jne	SHORT $LN4@IsBlobVali
	cmp	DWORD PTR [rcx+216], 0
	jne	SHORT $LN4@IsBlobVali
	xor	ebx, ebx
	call	??1NET_BLOB@@QEAA@XZ
	mov	eax, ebx

; 106  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@IsBlobVali:

; 105  :         return !b.aesKey.empty() && b.cr.valid || b.sr.valid || b.udp.isValid;

	mov	ebx, 1
	call	??1NET_BLOB@@QEAA@XZ
	mov	eax, ebx

; 106  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?IsBlobValid@NetCommon@@YAHUNET_BLOB@@@Z ENDP		; NetCommon::IsBlobValid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1NET_BLOB@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1NET_BLOB@@QEAA@XZ PROC				; NET_BLOB::~NET_BLOB, COMDAT
$LN94:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+244]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@NET_BLOB
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+220]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@NET_BLOB

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN75@NET_BLOB

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@NET_BLOB:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@NET_BLOB:
	lea	rcx, QWORD PTR [rbx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+236], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+244], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+220], 0
	call	??1ServerCommand@@QEAA@XZ

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+40]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN64@NET_BLOB
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN78@NET_BLOB

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN75@NET_BLOB

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN78@NET_BLOB:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN64@NET_BLOB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN75@NET_BLOB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN91@NET_BLOB:
??1NET_BLOB@@QEAA@XZ ENDP				; NET_BLOB::~NET_BLOB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1ClientRequest@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ClientRequest@@QEAA@XZ PROC				; ClientRequest::~ClientRequest, COMDAT
$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+40]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@ClientRequ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@ClientRequ

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN32@ClientRequ

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@ClientRequ:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@ClientRequ:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN32@ClientRequ:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN45@ClientRequ:
??1ClientRequest@@QEAA@XZ ENDP				; ClientRequest::~ClientRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1ServerCommand@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ServerCommand@@QEAA@XZ PROC				; ServerCommand::~ServerCommand, COMDAT
$LN134:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+112]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@ServerComm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@ServerComm

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN112@ServerComm

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@ServerComm:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@ServerComm:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+104], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+112], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+88], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+80]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN59@ServerComm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN73@ServerComm

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN112@ServerComm

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN73@ServerComm:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN59@ServerComm:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+72], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+80], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+56], 0

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+48]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN101@ServerComm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN115@ServerComm

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN112@ServerComm

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN115@ServerComm:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN101@ServerComm:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+40], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+48], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+24], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN112@ServerComm:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN131@ServerComm:
??1ServerCommand@@QEAA@XZ ENDP				; ServerCommand::~ServerCommand
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1ProcessInformation@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ProcessInformation@@QEAA@XZ PROC			; ProcessInformation::~ProcessInformation, COMDAT
$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+40]
	mov	rbx, rcx
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@ProcessInf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@ProcessInf

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN32@ProcessInf

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@ProcessInf:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@ProcessInf:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+32], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+40], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+16], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN32@ProcessInf:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN45@ProcessInf:
??1ProcessInformation@@QEAA@XZ ENDP			; ProcessInformation::~ProcessInformation
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ServerCommand@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ServerCommand@@QEAA@AEBU0@@Z PROC			; ServerCommand::ServerCommand, COMDAT
$LN11:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+12], eax
	mov	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rcx+16], eax
	add	rcx, 24
	add	rdx, 24
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+56]
	lea	rdx, QWORD PTR [rbx+56]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+88]
	lea	rdx, QWORD PTR [rbx+88]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rbx+120]
	mov	DWORD PTR [rdi+120], eax
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0ServerCommand@@QEAA@AEBU0@@Z ENDP			; ServerCommand::ServerCommand
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA PROC	; `ServerCommand::ServerCommand'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1ProcessInformation@@QEAA@XZ
?dtor$0@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA ENDP	; `ServerCommand::ServerCommand'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$1@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA PROC	; `ServerCommand::ServerCommand'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???0ServerCommand@@QEAA@AEBU0@@Z@4HA ENDP	; `ServerCommand::ServerCommand'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ProcessInformation@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ProcessInformation@@QEAA@AEBU0@@Z PROC		; ProcessInformation::ProcessInformation, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rbx, rcx
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+8]
	add	rdx, 16
	mov	DWORD PTR [rcx+8], eax
	add	rcx, 16
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0ProcessInformation@@QEAA@AEBU0@@Z ENDP		; ProcessInformation::ProcessInformation
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ClientRequest@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ClientRequest@@QEAA@AEBU0@@Z PROC			; ClientRequest::ClientRequest, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rbx, rcx
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, QWORD PTR [rdx+8]
	add	rdx, 16
	mov	QWORD PTR [rcx+8], rax
	add	rcx, 16
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0ClientRequest@@QEAA@AEBU0@@Z ENDP			; ClientRequest::ClientRequest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_1>::operator(), COMDAT

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 26548175		; 019517cfH
	mov	DWORD PTR [rbx], 366034020		; 15d13c64H
	mov	DWORD PTR [rbx+4], 1567007216		; 5d66a1f0H
	mov	WORD PTR [rbx+8], 15649			; 00003d21H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'', COMDAT

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN51@dynamic
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 26548175		; 019517cfH
	mov	DWORD PTR [rbx], 366034020		; 15d13c64H
	mov	DWORD PTR [rbx+4], 1567007216		; 5d66a1f0H
	mov	WORD PTR [rbx+8], 15649			; 00003d21H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN4@dynamic
$LN51@dynamic:
	lea	rbx, QWORD PTR [r8+rcx]
$LN4@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	SHORT $LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 13
	mov	r8, 8022544353138530575			; 6f55cd957ba3590fH
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, xmm0
	xorps	xmm1, xmm1

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	movdqu	XMMWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm1

; 398  :             return __builtin_strlen(_First);

	mov	r8, -1
	npad	8
$LL52@dynamic:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL52@dynamic

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 33   : 		static const std::string kernel32 = std::string(HIDE("kernel32.dll"));	

	lea	rcx, OFFSET FLAT:??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Ekernel32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'kernel32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fkernel32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'kernel32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@4V45@A
	add	rcx, QWORD PTR [rax]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0GPFFMNJFHLKDFJAP@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_2>::operator(), COMDAT

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN21@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 379			; 0000017bH
	mov	DWORD PTR [rbx], 1231884053		; 496d0f15H
	mov	DWORD PTR [rbx+4], -1879768175		; 8ff50391H
	mov	BYTE PTR [rbx+8], 23
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'', COMDAT

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN46@dynamic
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+9], 379			; 0000017bH
	mov	DWORD PTR [rbx], 1231884053		; 496d0f15H
	mov	DWORD PTR [rbx+4], -1879768175		; 8ff50391H
	mov	BYTE PTR [rbx+8], 23
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN4@dynamic
$LN46@dynamic:
	lea	rbx, QWORD PTR [r8+rcx]
$LN4@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+10], 0
	je	SHORT $LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 10
	mov	r8, -2048805790205510789		; e3912dfd25097b7bH
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+10], 0
$LN15@dynamic:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, xmm0
	xorps	xmm1, xmm1

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	movdqu	XMMWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm1

; 398  :             return __builtin_strlen(_First);

	mov	r8, -1
$LL47@dynamic:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL47@dynamic

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 34   : 		static const std::string ntdll    = std::string(HIDE("ntdll.dll"));

	lea	rcx, OFFSET FLAT:??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Entdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Entdll@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'ntdll'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?ntdll@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fntdll@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'ntdll''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rdx+rcx], 0
	mov	WORD PTR [rdx+rcx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$09$0?BMGONCACNKPGIEIF@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ PROC ; ProcessUtilities::freqDLLS::<lambda_3>::operator(), COMDAT

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32315145		; 01ed1709H
	mov	DWORD PTR [rbx], 437478856		; 1a1365c8H
	mov	DWORD PTR [rbx+4], 1707624605		; 65c8489dH
	mov	WORD PTR [rbx+8], 25991			; 00006587H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ ENDP ; ProcessUtilities::freqDLLS::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4HA ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$di	SEGMENT
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'', COMDAT

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN51@dynamic
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 32315145		; 01ed1709H
	mov	DWORD PTR [rbx], 437478856		; 1a1365c8H
	mov	DWORD PTR [rbx+4], 1707624605		; 65c8489dH
	mov	WORD PTR [rbx+8], 25991			; 00006587H
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN4@dynamic
$LN51@dynamic:
	lea	rbx, QWORD PTR [r8+rcx]
$LN4@dynamic:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	SHORT $LN15@dynamic

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 13
	mov	r8, 6339698204315287977			; 57fb21ed7b6501a9H
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN15@dynamic:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, xmm0
	xorps	xmm1, xmm1

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	movdqu	XMMWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm1

; 398  :             return __builtin_strlen(_First);

	mov	r8, -1
	npad	8
$LL52@dynamic:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL52@dynamic

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 35   : 		static const std::string advapi32 = std::string(HIDE("advapi32.dll"));

	lea	rcx, OFFSET FLAT:??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	atexit
??__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA PROC ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???__Eadvapi32@freqDLLS@ProcessUtilities@@YAXXZ@4HA ENDP ; `ProcessUtilities::freqDLLS::`dynamic initializer for 'advapi32'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ
text$yd	SEGMENT
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ PROC	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN20@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@dynamic

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN43@dynamic
$LN34@dynamic:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 4876 :         _My_data._Myres  = _Small_string_capacity;
; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?advapi32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN43@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN41@dynamic:
??__Fadvapi32@freqDLLS@ProcessUtilities@@YAXXZ ENDP	; ProcessUtilities::freqDLLS::`dynamic atexit destructor for 'advapi32''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ PROC ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@4V45@A
	add	rcx, QWORD PTR [rax]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@freqDLLS@ProcessUtilities@@QEBAAEAV?$obfuscated_data@$0N@$0FHPLCBONHLGFABKJ@D@ay@@XZ@YAXXZ ENDP ; `ProcessUtilities::freqDLLS::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ?LoadWSAFunctions@NetCommon@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?LoadWSAFunctions@NetCommon@@YAXXZ PROC			; NetCommon::LoadWSAFunctions, COMDAT

; 7    : void NetCommon::LoadWSAFunctions() {

$LN1149:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-320]
	sub	rsp, 576				; 00000240H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 8    :     if ( WSAInitialized )

	cmp	DWORD PTR ?WSAInitialized@NetCommon@@3HA, 0 ; NetCommon::WSAInitialized
	jne	$LN3@LoadWSAFun

; 9    :         return;
; 10   : 
; 11   :     HMODULE kernel32 = ProcessUtilities::GetModHandle(ProcessUtilities::freqDLLS::kernel32); // load winsock

	lea	rdx, OFFSET FLAT:?kernel32@freqDLLS@ProcessUtilities@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	lea	rcx, QWORD PTR $T34[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetModHandle@ProcessUtilities@@YAPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetModHandle
	mov	r14, rax

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	mov	rcx, QWORD PTR gs:88
	mov	rdi, QWORD PTR [rcx]
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	ecx, DWORD PTR [rax+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A
	test	cl, 1
	jne	SHORT $LN1103@LoadWSAFun
	or	ecx, 1
	mov	DWORD PTR [rax+rdi], ecx
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 20514000		; 013904d0H
	mov	DWORD PTR [rbx], 566812281		; 21c8de79H
	mov	DWORD PTR [rbx+4], -73973131		; fb974275H
	mov	WORD PTR [rbx+8], 50004			; 0000c354H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN20@LoadWSAFun
$LN1103@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN20@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+13], 0
	je	SHORT $LN31@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 13
	mov	r8, -8505844796237434571		; 89f52b3945a9b135H
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN31@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	r15d, r15d
	mov	QWORD PTR $T12[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T12[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	rsi, -1
	mov	r8, rsi
$LL1134@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], r15b
	jne	SHORT $LL1134@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T12[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	lea	rax, QWORD PTR $T12[rsp]
	mov	QWORD PTR $T22[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T12[rsp]
	lea	rcx, QWORD PTR $T32[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T12[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN72@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T12[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN86@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1137@LoadWSAFun
$LN86@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN72@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T12[rsp+16], r15

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR $T12[rsp+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T12[rsp], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1104@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 21830513		; 014d1b71H
	mov	DWORD PTR [rbx], 1417610314		; 547f044aH
	mov	DWORD PTR [rbx+4], -552652404		; df0f318cH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN95@LoadWSAFun
$LN1104@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN95@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN106@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 11
	mov	r8, -4962681195322312931		; bb2103bf0b4d771dH
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN106@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T33[rsp], xmm0
	xorps	xmm1, xmm1

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	movdqu	XMMWORD PTR $T33[rbp-240], xmm1

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
$LL1133@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1133@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T33[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T33[rsp]

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR $T33[rbp-232], 15

; 2236 :         if (_Large_mode_engaged()) {

	cmova	rcx, QWORD PTR $T33[rsp]
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	call	r14
	mov	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T33[rbp-232]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN153@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T33[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN167@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1138@LoadWSAFun
$LN167@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN153@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T33[rbp-240], xmm0

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T33[rsp], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1105@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 32738114		; 01f38b42H
	mov	DWORD PTR [rbx], 1286776928		; 4cb2a860H
	mov	DWORD PTR [rbx+4], -1621755363		; 9f55fa1dH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN174@LoadWSAFun
$LN1105@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN174@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN185@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 11
	mov	r8, -1502061074894816457		; eb279b691ff3fb37H
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN185@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T11[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T11[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
	npad	7
$LL1132@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1132@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T11[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	lea	rax, QWORD PTR $T11[rsp]
	mov	QWORD PTR $T21[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T11[rsp]
	lea	rcx, QWORD PTR $T31[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T11[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN226@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T11[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN240@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1139@LoadWSAFun
$LN240@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN226@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	mov	QWORD PTR ?StartWSA@@3P6AHGPEAUWSAData@@@ZEA, rbx ; StartWSA

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1106@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 23529225		; 01670709H
	mov	WORD PTR [rbx], 31831			; 00007c57H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN248@LoadWSAFun
$LN1106@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN248@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+5], 0
	je	SHORT $LN259@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 53			; 00000035H
	xor	BYTE PTR [rbx+1], 21
	xor	BYTE PTR [rbx+2], 103			; 00000067H
	xor	BYTE PTR [rbx+3], 99			; 00000063H
	xor	BYTE PTR [rbx+4], 103			; 00000067H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+5], 0
$LN259@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T10[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T10[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T10[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
	npad	2
$LL1131@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1131@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T10[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, r14
	call	??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
	mov	QWORD PTR ?BindSocket@@3P6AH_KPEBUsockaddr@@H@ZEA, rax ; BindSocket

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1108@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+11], 457			; 000001c9H
	mov	DWORD PTR [rbx], -1159708678		; bae03ffaH
	mov	DWORD PTR [rbx+4], -1666390802		; 9cace4eeH
	mov	WORD PTR [rbx+8], 14066			; 000036f2H
	mov	BYTE PTR [rbx+10], -5
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN285@LoadWSAFun
$LN1108@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN285@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+12], 0
	je	SHORT $LN296@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 12
	mov	r8, -17003346941488231			; ffc3978bc98f5399H
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+12], 0
$LN296@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T9[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T9[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T9[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
	npad	4
$LL1130@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1130@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T9[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	lea	rax, QWORD PTR $T9[rsp]
	mov	QWORD PTR $T20[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T9[rsp]
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T9[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN337@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T9[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN351@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1140@LoadWSAFun
$LN351@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN337@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1109@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 30794186		; 01d5e1caH
	mov	DWORD PTR [rbx], -293673836		; ee7ee494H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN359@LoadWSAFun
$LN1109@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN359@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+7], 0
	je	SHORT $LN370@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -25
	xor	BYTE PTR [rbx+1], -117			; ffffffffffffff8bH
	xor	BYTE PTR [rbx+2], 29
	xor	BYTE PTR [rbx+3], -123			; ffffffffffffff85H
	xor	BYTE PTR [rbx+4], -81			; ffffffffffffffafH
	xor	BYTE PTR [rbx+5], -107			; ffffffffffffff95H
	xor	BYTE PTR [rbx+6], -43			; ffffffffffffffd5H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+7], 0
$LN370@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T8[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T8[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
	npad	2
$LL1129@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1129@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T8[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	lea	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR $T19[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR $T29[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T8[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN416@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T8[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN430@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1141@LoadWSAFun
$LN430@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN416@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	mov	QWORD PTR ?CreateSocket@@3P6A_KHHH@ZEA, rbx ; CreateSocket

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1111@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 26988016		; 019bcdf0H
	mov	WORD PTR [rbx], 13825			; 00003601H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN438@LoadWSAFun
$LN1111@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN438@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+5], 0
	je	SHORT $LN449@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 115			; 00000073H
	xor	BYTE PTR [rbx+1], 83			; 00000053H
	xor	BYTE PTR [rbx+2], -109			; ffffffffffffff93H
	xor	BYTE PTR [rbx+3], -69			; ffffffffffffffbbH
	xor	BYTE PTR [rbx+4], -101			; ffffffffffffff9bH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+5], 0
$LN449@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T7[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T7[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
	npad	2
$LL1128@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1128@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T7[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR $T18[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR $T28[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T7[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN495@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T7[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN509@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1142@LoadWSAFun
$LN509@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN495@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1113@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 18427565		; 01192eadH
	mov	DWORD PTR [rbx], 1762755140		; 69118244H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN517@LoadWSAFun
$LN1113@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN517@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+7], 0
	je	SHORT $LN528@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], 55			; 00000037H
	xor	BYTE PTR [rbx+1], -25
	xor	BYTE PTR [rbx+2], 127			; 0000007fH
	xor	BYTE PTR [rbx+3], 13
	xor	BYTE PTR [rbx+4], -39			; ffffffffffffffd9H
	xor	BYTE PTR [rbx+5], 65			; 00000041H
	xor	BYTE PTR [rbx+6], 25

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+7], 0
$LN528@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T6[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T6[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
	npad	2
$LL1127@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1127@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T17[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T6[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN574@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN588@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1143@LoadWSAFun
$LN588@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN574@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1115@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+6], 26847760		; 0199aa10H
	mov	DWORD PTR [rbx], 500048619		; 1dce22ebH
	mov	WORD PTR [rbx+4], 1349			; 00000545H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN596@LoadWSAFun
$LN1115@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN596@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+9], 0
	je	SHORT $LN607@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 9
	mov	r8, -4071404544105560167		; c77f77236bad4799H
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+9], 0
$LN607@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T5[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T5[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
$LL1126@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1126@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T16[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T5[rsp]
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T5[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN648@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN662@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1144@LoadWSAFun
$LN662@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN648@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1116@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdi+rdx]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 21339647		; 01459dffH
	mov	WORD PTR [rbx], 24308			; 00005ef4H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN670@LoadWSAFun
$LN1116@LoadWSAFun:
	lea	rbx, QWORD PTR [rdi+rdx]
$LN670@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+5], 0
	je	SHORT $LN681@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -121			; ffffffffffffff87H
	xor	BYTE PTR [rbx+1], 59			; 0000003bH
	xor	BYTE PTR [rbx+2], -111			; ffffffffffffff91H
	xor	BYTE PTR [rbx+3], -7
	xor	BYTE PTR [rbx+4], 69			; 00000045H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+5], 0
$LN681@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T4[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T4[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
$LL1125@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1125@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T4[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T15[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T25[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T4[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN727@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN741@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1145@LoadWSAFun
$LN741@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN727@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1118@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 17111976		; 01051ba8H
	mov	DWORD PTR [rbx], -398182262		; e844388aH
	mov	DWORD PTR [rbx+4], 325070019		; 13602cc3H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN749@LoadWSAFun
$LN1118@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN749@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+11], 0
	je	SHORT $LN760@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 11
	mov	r8, 9007561748555066333			; 7d0149afab056bddH
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN760@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T3[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T3[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
$LL1124@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1124@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T14[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T3[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN801@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T3[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN815@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1146@LoadWSAFun
$LN815@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN801@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	mov	QWORD PTR ?CleanWSA@@3P6AHXZEA, rbx	; CleanWSA

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1119@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+7], 391			; 00000187H
	mov	DWORD PTR [rbx], -542647668		; dfa7da8cH
	mov	WORD PTR [rbx+4], 48710			; 0000be46H
	mov	BYTE PTR [rbx+6], 115			; 00000073H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN823@LoadWSAFun
$LN1119@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN823@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+8], 0
	je	SHORT $LN834@LoadWSAFun

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 8
	mov	r8, -8716755408375925265		; 8707dd23b1c9b5efH
	mov	rcx, rbx
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+8], 0
$LN834@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T2[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T2[rsp+24], r15

; 398  :             return __builtin_strlen(_First);

	mov	r8, rsi
$LL1123@LoadWSAFun:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL1123@LoadWSAFun

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, r14
	call	??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>

; 27   :     SocketListen = ProcessUtilities::GetFunctionAddress<_listen>(WINSOCK, std::string(HIDE("listen")));

	mov	ecx, OFFSET FLAT:??__J?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@51
	mov	eax, DWORD PTR [rcx+rdi]
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN1120@LoadWSAFun
	or	eax, 1
	mov	DWORD PTR [rcx+rdi], eax
	lea	rbx, QWORD PTR [rdx+rdi]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 30655444		; 01d3c3d4H
	mov	DWORD PTR [rbx], -174968191		; f5923281H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 27   :     SocketListen = ProcessUtilities::GetFunctionAddress<_listen>(WINSOCK, std::string(HIDE("listen")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	jmp	SHORT $LN855@LoadWSAFun
$LN1120@LoadWSAFun:
	lea	rbx, QWORD PTR [rdx+rdi]
$LN855@LoadWSAFun:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rbx+7], 0
	je	SHORT $LN866@LoadWSAFun

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rbx], -19
	xor	BYTE PTR [rbx+1], 91			; 0000005bH
	xor	BYTE PTR [rbx+2], -31
	xor	BYTE PTR [rbx+3], -127			; ffffffffffffff81H
	xor	BYTE PTR [rbx+4], -79			; ffffffffffffffb1H
	xor	BYTE PTR [rbx+5], -83			; ffffffffffffffadH
	xor	BYTE PTR [rbx+6], -45			; ffffffffffffffd3H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+7], 0
$LN866@LoadWSAFun:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rsp], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR $T1[rsp+16], r15

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR $T1[rsp+24], r15
	npad	8
$LL1122@LoadWSAFun:

; 398  :             return __builtin_strlen(_First);

	inc	rsi
	cmp	BYTE PTR [rbx+rsi], 0
	jne	SHORT $LL1122@LoadWSAFun
	mov	r8, rsi

; 2560 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 27   :     SocketListen = ProcessUtilities::GetFunctionAddress<_listen>(WINSOCK, std::string(HIDE("listen")));

	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T13[rsp], rax
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, r14
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T1[rsp+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN912@LoadWSAFun

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN926@LoadWSAFun

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN1147@LoadWSAFun
$LN926@LoadWSAFun:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN912@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T1[rsp+16], r15

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR $T1[rsp+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 27   :     SocketListen = ProcessUtilities::GetFunctionAddress<_listen>(WINSOCK, std::string(HIDE("listen")));

	mov	QWORD PTR ?SocketListen@@3P6AH_KH@ZEA, rbx ; SocketListen

; 28   : 
; 29   :     WORD version = MAKEWORD(2, 2);
; 30   :     WSAData data = { 0 };

	xor	edx, edx
	mov	r8d, 408				; 00000198H
	lea	rcx, QWORD PTR data$[rbp-256]
	call	memset

; 31   : 
; 32   :     if ( StartWSA(version, &data) == 0 )

	mov	rax, QWORD PTR ?StartWSA@@3P6AHGPEAUWSAData@@@ZEA ; StartWSA
	mov	ecx, 514				; 00000202H
	lea	rdx, QWORD PTR data$[rbp-256]
	call	rax
	test	eax, eax
	jne	SHORT $LN3@LoadWSAFun

; 33   :         WSAInitialized = TRUE;

	mov	DWORD PTR ?WSAInitialized@NetCommon@@3HA, 1 ; NetCommon::WSAInitialized
$LN3@LoadWSAFun:

; 34   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+576]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN1147@LoadWSAFun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1137@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1138@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1139@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1140@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1141@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1142@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1143@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1144@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1145@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1146@LoadWSAFun:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN1135@LoadWSAFun:
?LoadWSAFunctions@NetCommon@@YAXXZ ENDP			; NetCommon::LoadWSAFunctions
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$14
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$14@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$17
	mov	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$17@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$20
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$20@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$2@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$2
	lea	rcx, QWORD PTR $T33[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$24
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$24@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$27@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$27
	mov	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$27@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$30@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$30
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$30@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$33
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$33@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$33
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$36
	mov	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$36@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$36
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$39@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$39
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$39@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$39
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$42@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$42
	mov	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$42@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$42
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$45
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$45@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$45
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$48
	mov	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$48@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$48
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$51@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$51
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$51@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$51
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$54@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$54
	mov	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$54@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$54
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$57@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$57
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$57@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$57
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$60@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$60
	mov	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$60@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$60
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$63@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$63
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$63@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$63
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$66@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$66
	mov	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$66@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$66
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$69@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$69
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$69@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$69
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$72@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$72
	mov	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$72@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$72
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$75@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$75
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$75@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$75
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$78@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$78
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$78@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$78
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 64
$T19 = 64
$T20 = 64
$T21 = 64
$T22 = 72
$T23 = 80
$T24 = 80
$T25 = 80
$T26 = 80
$T27 = 80
$T28 = 80
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 112
$T34 = 112
data$ = 144
__$ArrayPad$ = 560
?dtor$81@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA PROC	; `NetCommon::LoadWSAFunctions'::`1'::dtor$81
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$81@?0??LoadWSAFunctions@NetCommon@@YAXXZ@4HA ENDP	; `NetCommon::LoadWSAFunctions'::`1'::dtor$81
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator(), COMDAT

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN26@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+10], 20514000		; 013904d0H
	mov	DWORD PTR [rbx], 566812281		; 21c8de79H
	mov	DWORD PTR [rbx+4], -73973131		; fb974275H
	mov	WORD PTR [rbx+8], 50004			; 0000c354H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 12   :     ProcessUtilities::PPROCFN::_LoadLibrary load = ProcessUtilities::GetFunctionAddress<ProcessUtilities::PPROCFN::_LoadLibrary>(kernel32, std::string(HIDE("LoadLibraryA")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN26@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator(), COMDAT

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 21830513		; 014d1b71H
	mov	DWORD PTR [rbx], 1417610314		; 547f044aH
	mov	DWORD PTR [rbx+4], -552652404		; df0f318cH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 14   :     HMODULE WINSOCK = load(winsock32.c_str());

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator(), COMDAT

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 32738114		; 01f38b42H
	mov	DWORD PTR [rbx], 1286776928		; 4cb2a860H
	mov	DWORD PTR [rbx+4], -1621755363		; 9f55fa1dH
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 17   :     StartWSA = ProcessUtilities::GetFunctionAddress<_WSAStartup>(WINSOCK, std::string(HIDE("WSAStartup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator(), COMDAT

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN16@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 23529225		; 01670709H
	mov	WORD PTR [rbx], 31831			; 00007c57H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 18   :     BindSocket = ProcessUtilities::GetFunctionAddress<_bind>(WINSOCK, std::string(HIDE("bind")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator(), COMDAT

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN25@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+11], 457			; 000001c9H
	mov	DWORD PTR [rbx], -1159708678		; bae03ffaH
	mov	DWORD PTR [rbx+4], -1666390802		; 9cace4eeH
	mov	WORD PTR [rbx+8], 14066			; 000036f2H
	mov	BYTE PTR [rbx+10], -5
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 19   :     CloseSocket = ProcessUtilities::GetFunctionAddress<_closesocket>(WINSOCK, std::string(HIDE("closesocket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN25@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator(), COMDAT

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN18@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 30794186		; 01d5e1caH
	mov	DWORD PTR [rbx], -293673836		; ee7ee494H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 20   :     CreateSocket = ProcessUtilities::GetFunctionAddress<_socket>(WINSOCK, std::string(HIDE("socket")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator(), COMDAT

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN16@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 26988016		; 019bcdf0H
	mov	WORD PTR [rbx], 13825			; 00003601H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 21   :     Receive = ProcessUtilities::GetFunctionAddress<_recv>(WINSOCK, std::string(HIDE("recv")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator(), COMDAT

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN18@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 18427565		; 01192eadH
	mov	DWORD PTR [rbx], 1762755140		; 69118244H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 22   :     SendTo = ProcessUtilities::GetFunctionAddress<_sendto>(WINSOCK, std::string(HIDE("sendto")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator(), COMDAT

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN20@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+6], 26847760		; 0199aa10H
	mov	DWORD PTR [rbx], 500048619		; 1dce22ebH
	mov	WORD PTR [rbx+4], 1349			; 00000545H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 23   :     ReceiveFrom = ProcessUtilities::GetFunctionAddress<_recvfrom>(WINSOCK, std::string(HIDE("recvfrom")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN20@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator(), COMDAT

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN16@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+2], 21339647		; 01459dffH
	mov	WORD PTR [rbx], 24308			; 00005ef4H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 24   :     Send = ProcessUtilities::GetFunctionAddress<_send>(WINSOCK, std::string(HIDE("send")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN16@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator(), COMDAT

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN22@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+8], 17111976		; 01051ba8H
	mov	DWORD PTR [rbx], -398182262		; e844388aH
	mov	DWORD PTR [rbx+4], 325070019		; 13602cc3H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 25   :     CleanWSA = ProcessUtilities::GetFunctionAddress<_WSACleanup>(WINSOCK, std::string(HIDE("WSACleanup")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator(), COMDAT

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN19@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	WORD PTR [rbx+7], 391			; 00000187H
	mov	DWORD PTR [rbx], -542647668		; dfa7da8cH
	mov	WORD PTR [rbx+4], 48710			; 0000be46H
	mov	BYTE PTR [rbx+6], 115			; 00000073H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 26   :     ConnectSocket = ProcessUtilities::GetFunctionAddress<_connect>(WINSOCK, std::string(HIDE("connect")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ
_TEXT	SEGMENT
this$dead$ = 48
??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ PROC ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator(), COMDAT

; 27   :     SocketListen = ProcessUtilities::GetFunctionAddress<_listen>(WINSOCK, std::string(HIDE("listen")));

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR gs:88
	mov	rcx, QWORD PTR [rax]
	mov	edx, OFFSET FLAT:??__J?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@51
	mov	eax, DWORD PTR [rdx+rcx]
	mov	r8d, OFFSET FLAT:?obfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4V45@A
	test	al, 1
	jne	SHORT $LN18@operator
	or	eax, 1
	mov	DWORD PTR [rdx+rcx], eax
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h

; 123  : 				m_data[i] = obfuscator.data()[i];

	mov	DWORD PTR [rbx+4], 30655444		; 01d3c3d4H
	mov	DWORD PTR [rbx], -174968191		; f5923281H
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 27   :     SocketListen = ProcessUtilities::GetFunctionAddress<_listen>(WINSOCK, std::string(HIDE("listen")));

	lea	rcx, OFFSET FLAT:??__Fobfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@YAXXZ ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
	call	__tlregdtor
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@operator:
	lea	rax, QWORD PTR [rcx+r8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ ENDP ; `NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
?dtor$0@?0???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4HA PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()'::`1'::dtor$0
	push	rbp
	mov	rbp, rdx
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@51
	mov	r8, QWORD PTR gs:88
	mov	r8, QWORD PTR [r8]
	add	r8, rax
	mov	r8d, DWORD PTR [r8]
	and	r8d, -2					; fffffffeH
	mov	rdx, QWORD PTR gs:88
	mov	eax, OFFSET FLAT:??__J?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@51
	mov	ecx, eax
	mov	rax, QWORD PTR [rdx]
	add	rax, rcx
	mov	DWORD PTR [rax], r8d
	pop	rbp
	ret	0
?dtor$0@?0???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4HA ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rdx+rcx], 0
	mov	WORD PTR [rdx+rcx+4], 0
	mov	BYTE PTR [rdx+rcx+6], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_13>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_13>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rdx+rcx], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_12>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_12>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rdx+rcx], 0
	mov	WORD PTR [rdx+rcx+8], 0
	mov	BYTE PTR [rdx+rcx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_11>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_11>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rdx+rcx], 0
	mov	BYTE PTR [rdx+rcx+4], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_10>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_10>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rdx+rcx], 0
	mov	BYTE PTR [rdx+rcx+8], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_9>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_9>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rdx+rcx], 0
	mov	WORD PTR [rdx+rcx+4], 0
	mov	BYTE PTR [rdx+rcx+6], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_8>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_8>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rdx+rcx], 0
	mov	BYTE PTR [rdx+rcx+4], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_7>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_7>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rdx+rcx], 0
	mov	WORD PTR [rdx+rcx+4], 0
	mov	BYTE PTR [rdx+rcx+6], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_6>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_6>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@4V45@A
	add	rcx, QWORD PTR [rax]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	ret	0
??__Fobfuscated_data@?1???R<lambda_5>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_5>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rdx+rcx], 0
	mov	BYTE PTR [rdx+rcx+4], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_4>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_4>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rdx+rcx], 0
	mov	WORD PTR [rdx+rcx+8], 0
	mov	BYTE PTR [rdx+rcx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_3>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_3>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	edx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@4V45@A
	mov	rcx, QWORD PTR [rax]

; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rdx+rcx], 0
	mov	WORD PTR [rdx+rcx+8], 0
	mov	BYTE PTR [rdx+rcx+10], 0
	ret	0
??__Fobfuscated_data@?1???R<lambda_2>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_2>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ
text$yd	SEGMENT
??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ PROC ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data'', COMDAT
	mov	rax, QWORD PTR gs:88
	mov	ecx, OFFSET FLAT:?obfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@4V45@A
	add	rcx, QWORD PTR [rax]

; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al
	ret	0
??__Fobfuscated_data@?1???R<lambda_1>@?1??LoadWSAFunctions@NetCommon@@YAXXZ@QEBAAEAV?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@XZ@YAXXZ ENDP ; ``NetCommon::LoadWSAFunctions'::`2'::<lambda_1>::operator()'::`2'::`dynamic atexit destructor for 'obfuscated_data''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp
;	COMDAT ?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z
_TEXT	SEGMENT
$T3 = 48
data$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
req$ = 88
key$ = 112
aes$ = 144
$T4 = 144
__$ArrayPad$ = 400
__$ReturnUdt$ = 448
data$ = 456
?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z PROC ; NetCommon::AESEncryptBlob, COMDAT

; 44   : BYTESTRING NetCommon::AESEncryptBlob(NET_BLOB data) {

$LN294:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-160]
	sub	rsp, 416				; 000001a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR data$GSCopy$[rsp], rdx
	xor	r14d, r14d

; 45   :     if ( IsBlobValid(data) == FALSE )

	lea	rcx, QWORD PTR $T4[rbp-256]
	call	??0NET_BLOB@@QEAA@AEBU0@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4279 :         return _Mypair._Myval2._Mysize == 0;

	cmp	QWORD PTR [rax+236], r14
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 105  :         return !b.aesKey.empty() && b.cr.valid || b.sr.valid || b.udp.isValid;

	je	SHORT $LN19@AESEncrypt
	cmp	DWORD PTR [rax], r14d
	jne	SHORT $LN20@AESEncrypt
$LN19@AESEncrypt:
	cmp	BYTE PTR [rax+48], 0
	jne	SHORT $LN20@AESEncrypt
	cmp	DWORD PTR [rax+216], 0
	jne	SHORT $LN20@AESEncrypt
	mov	rcx, rax
	call	??1NET_BLOB@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdi], r14
	mov	QWORD PTR [rdi+8], r14
	mov	QWORD PTR [rdi+16], r14
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 46   :         return {};

	jmp	$LN110@AESEncrypt
$LN20@AESEncrypt:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\net_common.h

; 105  :         return !b.aesKey.empty() && b.cr.valid || b.sr.valid || b.udp.isValid;

	mov	rcx, rax
	call	??1NET_BLOB@@QEAA@XZ
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR req$[rsp], xmm1
	mov	QWORD PTR req$[rsp+16], r14
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 50   :     if ( data.cr.valid ) {

	cmp	DWORD PTR [rbx], 0
	je	SHORT $LN3@AESEncrypt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	edx, 48					; 00000030H
	lea	rcx, QWORD PTR req$[rsp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 48					; 00000030H
	mov	rdx, rbx
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 54   :     }

	jmp	SHORT $LN289@AESEncrypt
$LN3@AESEncrypt:

; 55   :     else if ( data.sr.valid ) {

	cmp	BYTE PTR [rbx+48], 0
	je	SHORT $LN5@AESEncrypt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	edx, 128				; 00000080H
	lea	rcx, QWORD PTR req$[rsp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 128				; 00000080H
	lea	rdx, QWORD PTR [rbx+48]
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 59   :     }

	jmp	SHORT $LN289@AESEncrypt
$LN5@AESEncrypt:

; 60   :     else if ( data.udp.isValid ) {

	cmp	DWORD PTR [rbx+216], 0
	je	SHORT $LN249@AESEncrypt

; 61   :         req.resize(sizeof(UDPResponse));

	mov	edx, 44					; 0000002cH
	lea	rcx, QWORD PTR req$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 62   :         char* bytes = reinterpret_cast< char* >( &data.udp );

	lea	rdx, QWORD PTR [rbx+176]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 44					; 0000002cH
$LN289@AESEncrypt:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 66   :     BYTESTRING key = NetCommon::SerializeString(data.aesKey);

	mov	rcx, QWORD PTR req$[rsp]
	call	memmove
$LN249@AESEncrypt:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR key$[rsp], xmm0
	mov	QWORD PTR key$[rbp-240], rax
	lea	rdx, QWORD PTR [rbx+220]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	lea	rcx, QWORD PTR key$[rsp]
	call	?SerializeString@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; NetCommon::SerializeString
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 608  :         Aes(unsigned char key[key_bits]) : round_keys() {

	xor	edx, edx
	mov	r8d, 240				; 000000f0H
	lea	rcx, QWORD PTR aes$[rbp-256]
	call	memset

; 609  :             constexpr bool invalid_aes_key_bit_size = key_bits == 128 || key_bits == 192 || key_bits == 256;
; 610  :             static_assert( invalid_aes_key_bit_size, "The valid values are only: 128, 192 & 256" );
; 611  : 
; 612  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 613  :             if constexpr ( key_bits == 128 ) {
; 614  :                 AES_128_Key_Expansion(key, round_keys);
; 615  :             }
; 616  :             else if constexpr ( key_bits == 192 ) {
; 617  :                 AES_192_Key_Expansion(key, round_keys);
; 618  :             }
; 619  :             else if constexpr ( key_bits == 256 ) {
; 620  :                 AES_256_Key_Expansion(key, round_keys);

	lea	r8, QWORD PTR aes$[rbp-256]
	mov	rdx, QWORD PTR key$[rsp]
	call	?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ; Cipher::Aes<256>::AES_256_Key_Expansion

; 713  :             state = _mm_xor_si128(state, xmm_round_keys[0]);

	mov	rdx, QWORD PTR req$[rsp]
	movdqu	xmm5, XMMWORD PTR [rdx]
	movdqu	xmm0, XMMWORD PTR aes$[rbp-256]
	xorps	xmm0, xmm5
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 66   :     BYTESTRING key = NetCommon::SerializeString(data.aesKey);

	lea	rax, QWORD PTR aes$[rbp-240]
	mov	ecx, 6
	npad	7
$LL54@AESEncrypt:
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp

; 717  :                 state = _mm_aesenc_si128(state, xmm_round_keys[i]);

	aesenc	xmm0, XMMWORD PTR [rax]

; 718  :                 state = _mm_aesenc_si128(state, xmm_round_keys[i + 1]);

	aesenc	xmm0, XMMWORD PTR [rax+16]

; 714  : 
; 715  :             // perform usual rounds
; 716  :             for ( size_t i = 1; i < Nr - 1; i += 2 ) {

	lea	rax, QWORD PTR [rax+32]
	sub	rcx, 1
	jne	SHORT $LL54@AESEncrypt

; 719  :             }
; 720  : 
; 721  :             // last round
; 722  :             state = _mm_aesenc_si128(state, xmm_round_keys[Nr - 1]);

	aesenc	xmm0, XMMWORD PTR aes$[rbp-48]

; 723  :             state = _mm_aesenclast_si128(state, xmm_round_keys[Nr]);

	aesenclast xmm0, XMMWORD PTR aes$[rbp-32]

; 724  : 
; 725  :             // store from register to array
; 726  :             _mm_storeu_si128(( __m128i* ) ( block ), state);

	movdqu	XMMWORD PTR [rdx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR req$[rsp+16]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	r9, r14
	mov	QWORD PTR req$[rsp+16], r14

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR req$[rsp+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR req$[rsp+8], r14

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR req$[rsp]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	r8, r14
	mov	QWORD PTR req$[rsp], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [rdi+8], rcx
	mov	QWORD PTR [rdi+16], rdx

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR key$[rsp]
	test	rcx, rcx
	je	SHORT $LN81@AESEncrypt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR key$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN100@AESEncrypt

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN291@AESEncrypt
$LN100@AESEncrypt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR key$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR key$[rbp-240], r14
	mov	r9, QWORD PTR req$[rsp+16]
	mov	r8, QWORD PTR req$[rsp]
$LN81@AESEncrypt:

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	test	r8, r8
	je	SHORT $LN110@AESEncrypt

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	r9, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r8

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r9, 4096				; 00001000H
	jb	SHORT $LN129@AESEncrypt

; 171  :     _Bytes += _Non_user_size;

	add	r9, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [r8-8]
	sub	rax, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN292@AESEncrypt
$LN129@AESEncrypt:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r9
	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR req$[rsp], xmm0

; 2054 :             _Mylast  = nullptr;
; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR req$[rsp+16], r14
$LN110@AESEncrypt:
; File C:\Users\ethan\source\repos\DLL\DLL\Source\net_common.cpp

; 72   : }

	mov	rcx, rbx
	call	??1NET_BLOB@@QEAA@XZ
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+416]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
$LN292@AESEncrypt:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	npad	1
$LN291@AESEncrypt:
	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN288@AESEncrypt:
?AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z ENDP ; NetCommon::AESEncryptBlob
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 48
data$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
req$ = 88
key$ = 112
aes$ = 144
$T4 = 144
__$ArrayPad$ = 400
__$ReturnUdt$ = 448
data$ = 456
?dtor$0@?0??AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z@4HA PROC ; `NetCommon::AESEncryptBlob'::`1'::dtor$0
	mov	rcx, QWORD PTR data$GSCopy$[rdx]
	jmp	??1NET_BLOB@@QEAA@XZ
?dtor$0@?0??AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z@4HA ENDP ; `NetCommon::AESEncryptBlob'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 48
data$GSCopy$ = 80
__$ReturnUdt$GSCopy$ = 80
req$ = 88
key$ = 112
aes$ = 144
$T4 = 144
__$ArrayPad$ = 400
__$ReturnUdt$ = 448
data$ = 456
?dtor$3@?0??AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z@4HA PROC ; `NetCommon::AESEncryptBlob'::`1'::dtor$3
	lea	rcx, QWORD PTR req$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$3@?0??AESEncryptBlob@NetCommon@@YA?AV?$vector@EV?$allocator@E@std@@@std@@UNET_BLOB@@@Z@4HA ENDP ; `NetCommon::AESEncryptBlob'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0NET_BLOB@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
??0NET_BLOB@@QEAA@AEBU0@@Z PROC				; NET_BLOB::NET_BLOB, COMDAT
$LN19:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rsi, rcx
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax
	add	rcx, 16
	add	rdx, 16
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rbx, QWORD PTR [rsi+48]
	mov	QWORD PTR $T1[rsp], rbx
	movzx	eax, BYTE PTR [rdi+48]
	mov	BYTE PTR [rbx], al
	mov	eax, DWORD PTR [rdi+56]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rdi+60]
	mov	DWORD PTR [rbx+12], eax
	mov	eax, DWORD PTR [rdi+64]
	mov	DWORD PTR [rbx+16], eax
	lea	rcx, QWORD PTR [rbx+24]
	lea	rdx, QWORD PTR [rdi+72]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+56]
	lea	rdx, QWORD PTR [rdi+104]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+88]
	lea	rdx, QWORD PTR [rdi+136]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [rdi+168]
	mov	DWORD PTR [rbx+120], eax
	movups	xmm0, XMMWORD PTR [rdi+176]
	movups	XMMWORD PTR [rsi+176], xmm0
	movups	xmm1, XMMWORD PTR [rdi+192]
	movups	XMMWORD PTR [rsi+192], xmm1
	movsd	xmm0, QWORD PTR [rdi+208]
	movsd	QWORD PTR [rsi+208], xmm0
	mov	eax, DWORD PTR [rdi+216]
	mov	DWORD PTR [rsi+216], eax
	lea	rcx, QWORD PTR [rsi+220]
	lea	rdx, QWORD PTR [rdi+220]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0NET_BLOB@@QEAA@AEBU0@@Z ENDP				; NET_BLOB::NET_BLOB
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
?dtor$0@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA PROC		; `NET_BLOB::NET_BLOB'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1ClientRequest@@QEAA@XZ
?dtor$0@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA ENDP		; `NET_BLOB::NET_BLOB'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
?dtor$4@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA PROC		; `NET_BLOB::NET_BLOB'::`1'::dtor$4
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1ProcessInformation@@QEAA@XZ
?dtor$4@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA ENDP		; `NET_BLOB::NET_BLOB'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
?dtor$5@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA PROC		; `NET_BLOB::NET_BLOB'::`1'::dtor$5
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA ENDP		; `NET_BLOB::NET_BLOB'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
$T1 = 56
__that$ = 56
?dtor$1@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA PROC		; `NET_BLOB::NET_BLOB'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1ServerCommand@@QEAA@XZ
?dtor$1@?0???0NET_BLOB@@QEAA@AEBU0@@Z@4HA ENDP		; `NET_BLOB::NET_BLOB'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<7,9210896640802642925,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -19
	xor	BYTE PTR [rcx+1], 91			; 0000005bH
	xor	BYTE PTR [rcx+2], -31
	xor	BYTE PTR [rcx+3], -127			; ffffffffffffff81H
	xor	BYTE PTR [rcx+4], -79			; ffffffffffffffb1H
	xor	BYTE PTR [rcx+5], -83			; ffffffffffffffadH
	xor	BYTE PTR [rcx+6], -45			; ffffffffffffffd3H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<7,9210896640802642925,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<7,9210896640802642925,char>::~obfuscated_data<7,9210896640802642925,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	WORD PTR [rcx+4], 0
	mov	BYTE PTR [rcx+6], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<7,9210896640802642925,char>::~obfuscated_data<7,9210896640802642925,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAA@AEBV?$obfuscator@$06$0HPNDKNLBIBOBFLON@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAA@AEBV?$obfuscator@$06$0HPNDKNLBIBOBFLON@D@1@@Z PROC ; ay::obfuscated_data<7,9210896640802642925,char>::obfuscated_data<7,9210896640802642925,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+7], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAA@AEBV?$obfuscator@$06$0HPNDKNLBIBOBFLON@D@1@@Z ENDP ; ay::obfuscated_data<7,9210896640802642925,char>::obfuscated_data<7,9210896640802642925,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<8,-8716755408375925265,char>::operator char *, COMDAT

; 139  : 		{

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+8], 0

; 139  : 		{

	mov	rbx, rcx

; 147  : 			if ( m_encrypted )

	je	SHORT $LN6@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 8
	mov	r8, -8716755408375925265		; 8707dd23b1c9b5efH
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+8], 0
$LN6@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??B?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<8,-8716755408375925265,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<8,-8716755408375925265,char>::~obfuscated_data<8,-8716755408375925265,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<8,-8716755408375925265,char>::~obfuscated_data<8,-8716755408375925265,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@1@@Z PROC ; ay::obfuscated_data<8,-8716755408375925265,char>::obfuscated_data<8,-8716755408375925265,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+8], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAA@AEBV?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@1@@Z ENDP ; ay::obfuscated_data<8,-8716755408375925265,char>::obfuscated_data<8,-8716755408375925265,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,9007561748555066333,char>::operator char *, COMDAT

; 139  : 		{

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0

; 139  : 		{

	mov	rbx, rcx

; 147  : 			if ( m_encrypted )

	je	SHORT $LN6@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 11
	mov	r8, 9007561748555066333			; 7d0149afab056bddH
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN6@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??B?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,9007561748555066333,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,9007561748555066333,char>::~obfuscated_data<11,9007561748555066333,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,9007561748555066333,char>::~obfuscated_data<11,9007561748555066333,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@1@@Z PROC ; ay::obfuscated_data<11,9007561748555066333,char>::obfuscated_data<11,9007561748555066333,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@1@@Z ENDP ; ay::obfuscated_data<11,9007561748555066333,char>::obfuscated_data<11,9007561748555066333,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<5,-3929642162503730297,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -121			; ffffffffffffff87H
	xor	BYTE PTR [rcx+1], 59			; 0000003bH
	xor	BYTE PTR [rcx+2], -111			; ffffffffffffff91H
	xor	BYTE PTR [rcx+3], -7
	xor	BYTE PTR [rcx+4], 69			; 00000045H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<5,-3929642162503730297,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<5,-3929642162503730297,char>::~obfuscated_data<5,-3929642162503730297,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<5,-3929642162503730297,char>::~obfuscated_data<5,-3929642162503730297,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@1@@Z PROC ; ay::obfuscated_data<5,-3929642162503730297,char>::obfuscated_data<5,-3929642162503730297,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+5], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAA@AEBV?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@1@@Z ENDP ; ay::obfuscated_data<5,-3929642162503730297,char>::obfuscated_data<5,-3929642162503730297,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<9,-4071404544105560167,char>::operator char *, COMDAT

; 139  : 		{

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+9], 0

; 139  : 		{

	mov	rbx, rcx

; 147  : 			if ( m_encrypted )

	je	SHORT $LN6@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 9
	mov	r8, -4071404544105560167		; c77f77236bad4799H
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+9], 0
$LN6@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??B?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<9,-4071404544105560167,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<9,-4071404544105560167,char>::~obfuscated_data<9,-4071404544105560167,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+8], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<9,-4071404544105560167,char>::~obfuscated_data<9,-4071404544105560167,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@AEBV?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@AEBV?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@1@@Z PROC ; ay::obfuscated_data<9,-4071404544105560167,char>::obfuscated_data<9,-4071404544105560167,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+9], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAA@AEBV?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@1@@Z ENDP ; ay::obfuscated_data<9,-4071404544105560167,char>::obfuscated_data<9,-4071404544105560167,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<7,-7558938099074472137,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 55			; 00000037H
	xor	BYTE PTR [rcx+1], -25
	xor	BYTE PTR [rcx+2], 127			; 0000007fH
	xor	BYTE PTR [rcx+3], 13
	xor	BYTE PTR [rcx+4], -39			; ffffffffffffffd9H
	xor	BYTE PTR [rcx+5], 65			; 00000041H
	xor	BYTE PTR [rcx+6], 25

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<7,-7558938099074472137,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<7,-7558938099074472137,char>::~obfuscated_data<7,-7558938099074472137,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	WORD PTR [rcx+4], 0
	mov	BYTE PTR [rcx+6], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<7,-7558938099074472137,char>::~obfuscated_data<7,-7558938099074472137,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@1@@Z PROC ; ay::obfuscated_data<7,-7558938099074472137,char>::obfuscated_data<7,-7558938099074472137,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+7], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@1@@Z ENDP ; ay::obfuscated_data<7,-7558938099074472137,char>::obfuscated_data<7,-7558938099074472137,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<5,4171390554486297459,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 115			; 00000073H
	xor	BYTE PTR [rcx+1], 83			; 00000053H
	xor	BYTE PTR [rcx+2], -109			; ffffffffffffff93H
	xor	BYTE PTR [rcx+3], -69			; ffffffffffffffbbH
	xor	BYTE PTR [rcx+4], -101			; ffffffffffffff9bH

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<5,4171390554486297459,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<5,4171390554486297459,char>::~obfuscated_data<5,4171390554486297459,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<5,4171390554486297459,char>::~obfuscated_data<5,4171390554486297459,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@AEBV?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@AEBV?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@1@@Z PROC ; ay::obfuscated_data<5,4171390554486297459,char>::obfuscated_data<5,4171390554486297459,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+5], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAA@AEBV?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@1@@Z ENDP ; ay::obfuscated_data<5,4171390554486297459,char>::obfuscated_data<5,4171390554486297459,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<7,-7217698246706230297,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -25
	xor	BYTE PTR [rcx+1], -117			; ffffffffffffff8bH
	xor	BYTE PTR [rcx+2], 29
	xor	BYTE PTR [rcx+3], -123			; ffffffffffffff85H
	xor	BYTE PTR [rcx+4], -81			; ffffffffffffffafH
	xor	BYTE PTR [rcx+5], -107			; ffffffffffffff95H
	xor	BYTE PTR [rcx+6], -43			; ffffffffffffffd5H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<7,-7217698246706230297,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<7,-7217698246706230297,char>::~obfuscated_data<7,-7217698246706230297,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	WORD PTR [rcx+4], 0
	mov	BYTE PTR [rcx+6], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<7,-7217698246706230297,char>::~obfuscated_data<7,-7217698246706230297,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@1@@Z PROC ; ay::obfuscated_data<7,-7217698246706230297,char>::obfuscated_data<7,-7217698246706230297,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+7], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAA@AEBV?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@1@@Z ENDP ; ay::obfuscated_data<7,-7217698246706230297,char>::obfuscated_data<7,-7217698246706230297,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<12,-17003346941488231,char>::operator char *, COMDAT

; 139  : 		{

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+12], 0

; 139  : 		{

	mov	rbx, rcx

; 147  : 			if ( m_encrypted )

	je	SHORT $LN6@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 12
	mov	r8, -17003346941488231			; ffc3978bc98f5399H
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+12], 0
$LN6@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??B?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<12,-17003346941488231,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<12,-17003346941488231,char>::~obfuscated_data<12,-17003346941488231,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<12,-17003346941488231,char>::~obfuscated_data<12,-17003346941488231,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@1@@Z PROC ; ay::obfuscated_data<12,-17003346941488231,char>::obfuscated_data<12,-17003346941488231,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+12], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAA@AEBV?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@1@@Z ENDP ; ay::obfuscated_data<12,-17003346941488231,char>::obfuscated_data<12,-17003346941488231,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
??B?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<5,-769018879138130635,char>::operator char *, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	mov	rax, rcx
	je	SHORT $LN4@operator

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 53			; 00000035H
	xor	BYTE PTR [rcx+1], 21
	xor	BYTE PTR [rcx+2], 103			; 00000067H
	xor	BYTE PTR [rcx+3], 99			; 00000063H
	xor	BYTE PTR [rcx+4], 103			; 00000067H

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN4@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	ret	0
??B?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<5,-769018879138130635,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<5,-769018879138130635,char>::~obfuscated_data<5,-769018879138130635,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<5,-769018879138130635,char>::~obfuscated_data<5,-769018879138130635,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@AEBV?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@AEBV?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@1@@Z PROC ; ay::obfuscated_data<5,-769018879138130635,char>::obfuscated_data<5,-769018879138130635,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+5], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAA@AEBV?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@1@@Z ENDP ; ay::obfuscated_data<5,-769018879138130635,char>::obfuscated_data<5,-769018879138130635,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,-1502061074894816457,char>::operator char *, COMDAT

; 139  : 		{

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0

; 139  : 		{

	mov	rbx, rcx

; 147  : 			if ( m_encrypted )

	je	SHORT $LN6@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 11
	mov	r8, -1502061074894816457		; eb279b691ff3fb37H
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN6@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??B?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,-1502061074894816457,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,-1502061074894816457,char>::~obfuscated_data<11,-1502061074894816457,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,-1502061074894816457,char>::~obfuscated_data<11,-1502061074894816457,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@1@@Z PROC ; ay::obfuscated_data<11,-1502061074894816457,char>::obfuscated_data<11,-1502061074894816457,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@1@@Z ENDP ; ay::obfuscated_data<11,-1502061074894816457,char>::obfuscated_data<11,-1502061074894816457,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<11,-4962681195322312931,char>::operator char *, COMDAT

; 139  : 		{

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0

; 139  : 		{

	mov	rbx, rcx

; 147  : 			if ( m_encrypted )

	je	SHORT $LN6@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 11
	mov	r8, -4962681195322312931		; bb2103bf0b4d771dH
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN6@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??B?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<11,-4962681195322312931,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<11,-4962681195322312931,char>::~obfuscated_data<11,-4962681195322312931,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;

	mov	QWORD PTR [rcx], 0
	mov	WORD PTR [rcx+8], 0
	mov	BYTE PTR [rcx+10], 0

; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<11,-4962681195322312931,char>::~obfuscated_data<11,-4962681195322312931,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@1@@Z PROC ; ay::obfuscated_data<11,-4962681195322312931,char>::obfuscated_data<11,-4962681195322312931,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+11], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAA@AEBV?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@1@@Z ENDP ; ay::obfuscated_data<11,-4962681195322312931,char>::obfuscated_data<11,-4962681195322312931,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 48
??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ PROC ; ay::obfuscated_data<13,-8505844796237434571,char>::operator char *, COMDAT

; 139  : 		{

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0

; 139  : 		{

	mov	rbx, rcx

; 147  : 			if ( m_encrypted )

	je	SHORT $LN6@operator

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 13
	mov	r8, -8505844796237434571		; 89f52b3945a9b135H
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN6@operator:

; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??B?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAPEADXZ ENDP ; ay::obfuscated_data<13,-8505844796237434571,char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??1?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@XZ PROC ; ay::obfuscated_data<13,-8505844796237434571,char>::~obfuscated_data<13,-8505844796237434571,char>, COMDAT

; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	BYTE PTR [rcx+12], al

; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}

	ret	0
??1?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@XZ ENDP ; ay::obfuscated_data<13,-8505844796237434571,char>::~obfuscated_data<13,-8505844796237434571,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ??0?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@1@@Z
_TEXT	SEGMENT
this$ = 8
obfuscator$ = 16
??0?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@1@@Z PROC ; ay::obfuscated_data<13,-8505844796237434571,char>::obfuscated_data<13,-8505844796237434571,char>, COMDAT

; 126  : 
; 127  : 		~obfuscated_data()
; 128  : 		{
; 129  : 			// Zero m_data to remove it from memory
; 130  : 			for ( size_type i = 0; i < N; i++ )
; 131  : 			{
; 132  : 				m_data[i] = 0;
; 133  : 			}
; 134  : 		}
; 135  : 
; 136  : 		// Returns a pointer to the plain text string, decrypting it if
; 137  : 		// necessary
; 138  : 		operator CHAR_TYPE* ( )
; 139  : 		{
; 140  : 			decrypt();
; 141  : 			return m_data;
; 142  : 		}
; 143  : 
; 144  : 		// Manually decrypt the string
; 145  : 		void decrypt()
; 146  : 		{
; 147  : 			if ( m_encrypted )
; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;
; 151  : 			}
; 152  : 		}
; 153  : 
; 154  : 		// Manually re-encrypt the string
; 155  : 		void encrypt()
; 156  : 		{
; 157  : 			if ( !m_encrypted )
; 158  : 			{
; 159  : 				cipher(m_data, N, KEY);
; 160  : 				m_encrypted = true;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		// Returns true if this string is currently encrypted, false otherwise.
; 165  : 		bool is_encrypted() const
; 166  : 		{
; 167  : 			return m_encrypted;
; 168  : 		}
; 169  : 
; 170  : 	private:
; 171  : 
; 172  : 		// Local storage for the string. Call is_encrypted() to check whether or
; 173  : 		// not the string is currently obfuscated.
; 174  : 		CHAR_TYPE m_data[N];
; 175  : 
; 176  : 		// Whether data is currently encrypted
; 177  : 		bool m_encrypted{ true };

	mov	BYTE PTR [rcx+13], 1
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rdx+1]
	mov	BYTE PTR [rcx+1], al
	movzx	eax, BYTE PTR [rdx+2]
	mov	BYTE PTR [rcx+2], al
	movzx	eax, BYTE PTR [rdx+3]
	mov	BYTE PTR [rcx+3], al
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, BYTE PTR [rdx+11]
	mov	BYTE PTR [rcx+11], al
	movzx	eax, BYTE PTR [rdx+12]
	mov	BYTE PTR [rcx+12], al
	mov	rax, rcx
	ret	0
??0?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAA@AEBV?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@1@@Z ENDP ; ay::obfuscated_data<13,-8505844796237434571,char>::obfuscated_data<13,-8505844796237434571,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?encrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z
_TEXT	SEGMENT
this$ = 8
block$ = 16
?encrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z PROC	; Cipher::Aes<256>::encrypt_block, COMDAT

; 707  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 708  :             // load the current block & current round key into the registers
; 709  :             __m128i* xmm_round_keys = ( __m128i* ) round_keys;
; 710  :             __m128i state = _mm_loadu_si128(( __m128i* ) & block[0]);
; 711  : 
; 712  :             // original key
; 713  :             state = _mm_xor_si128(state, xmm_round_keys[0]);

	movdqu	xmm0, XMMWORD PTR [rdx]
	lea	rax, QWORD PTR [rcx+16]
	mov	r8d, 6
	xorps	xmm0, XMMWORD PTR [rcx]
$LL4@encrypt_bl:

; 714  : 
; 715  :             // perform usual rounds
; 716  :             for ( size_t i = 1; i < Nr - 1; i += 2 ) {
; 717  :                 state = _mm_aesenc_si128(state, xmm_round_keys[i]);

	aesenc	xmm0, XMMWORD PTR [rax]

; 718  :                 state = _mm_aesenc_si128(state, xmm_round_keys[i + 1]);

	aesenc	xmm0, XMMWORD PTR [rax+16]
	lea	rax, QWORD PTR [rax+32]
	sub	r8, 1
	jne	SHORT $LL4@encrypt_bl

; 719  :             }
; 720  : 
; 721  :             // last round
; 722  :             state = _mm_aesenc_si128(state, xmm_round_keys[Nr - 1]);

	aesenc	xmm0, XMMWORD PTR [rcx+208]

; 723  :             state = _mm_aesenclast_si128(state, xmm_round_keys[Nr]);

	aesenclast xmm0, XMMWORD PTR [rcx+224]

; 724  : 
; 725  :             // store from register to array
; 726  :             _mm_storeu_si128(( __m128i* ) ( block ), state);

	movdqu	XMMWORD PTR [rdx], xmm0

; 727  : #elif defined(HARDWARE_ACCELERATION_ARM_NEON_AES)
; 728  :             uint8x16_t* neon_round_keys = ( uint8x16_t* ) round_keys;
; 729  :             uint8x16_t state = vld1q_u8(block);
; 730  : 
; 731  :             // Initial round
; 732  :             state = vaesmcq_u8(vaeseq_u8(state, neon_round_keys[0]));
; 733  : 
; 734  :             // 8 main rounds
; 735  :             for ( size_t i = 1; i < Nr - 1; i += 2 ) {
; 736  :                 state = vaesmcq_u8(vaeseq_u8(state, neon_round_keys[i]));
; 737  :                 state = vaesmcq_u8(vaeseq_u8(state, neon_round_keys[i + 1]));
; 738  :             }
; 739  : 
; 740  :             // last 2 final round
; 741  :             state = vaeseq_u8(state, neon_round_keys[Nr - 1]);
; 742  :             state = veorq_u8(state, neon_round_keys[Nr]);
; 743  : 
; 744  :             // store the result to block
; 745  :             vst1q_u8(block, state);
; 746  : #else
; 747  :             state_transpose(block);
; 748  : 
; 749  :             add_round_key(block, &round_keys[0]);
; 750  : 
; 751  :             for ( size_t round = 1; round <= Nr - 1; ++round ) {
; 752  :                 sub_bytes(block);
; 753  :                 shift_rows(block);
; 754  :                 mix_columns(block);
; 755  :                 add_round_key(block, &round_keys[round * Nb * 4]);
; 756  :             }
; 757  : 
; 758  :             sub_bytes(block);
; 759  :             shift_rows(block);
; 760  :             add_round_key(block, &round_keys[Nb * Nr * 4]);
; 761  : 
; 762  :             state_transpose(block);
; 763  : #endif
; 764  :         }

	ret	0
?encrypt_block@?$Aes@$0BAA@@Cipher@@QEAAXPEAE@Z ENDP	; Cipher::Aes<256>::encrypt_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ??1?$Aes@$0BAA@@Cipher@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$Aes@$0BAA@@Cipher@@QEAA@XZ PROC			; Cipher::Aes<256>::~Aes<256>, COMDAT

; 698  :             std::memset(round_keys, 0x00, round_keys_size);

	xor	edx, edx
	mov	r8d, 240				; 000000f0H
	jmp	memset
??1?$Aes@$0BAA@@Cipher@@QEAA@XZ ENDP			; Cipher::Aes<256>::~Aes<256>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z
_TEXT	SEGMENT
this$ = 48
key$ = 56
??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z PROC		; Cipher::Aes<256>::Aes<256>, COMDAT

; 608  :         Aes(unsigned char key[key_bits]) : round_keys() {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	r8d, 240				; 000000f0H
	xor	edx, edx
	mov	rdi, rcx
	call	memset

; 609  :             constexpr bool invalid_aes_key_bit_size = key_bits == 128 || key_bits == 192 || key_bits == 256;
; 610  :             static_assert( invalid_aes_key_bit_size, "The valid values are only: 128, 192 & 256" );
; 611  : 
; 612  : #ifdef HARDWARE_ACCELERATION_INTEL_AESNI
; 613  :             if constexpr ( key_bits == 128 ) {
; 614  :                 AES_128_Key_Expansion(key, round_keys);
; 615  :             }
; 616  :             else if constexpr ( key_bits == 192 ) {
; 617  :                 AES_192_Key_Expansion(key, round_keys);
; 618  :             }
; 619  :             else if constexpr ( key_bits == 256 ) {
; 620  :                 AES_256_Key_Expansion(key, round_keys);

	mov	r8, rdi
	mov	rdx, rbx
	call	?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ; Cipher::Aes<256>::AES_256_Key_Expansion

; 621  :             }
; 622  : #elif defined(HARDWARE_ACCELERATION_ARM_NEON_AES)
; 623  :             // key expansion
; 624  :             unsigned char temp[4];
; 625  :             unsigned char rcon[4];
; 626  : 
; 627  :             size_t i = 0;
; 628  : 
; 629  :             while ( i < Nk * 4 ) {
; 630  :                 round_keys[i] = key[i];
; 631  :                 round_keys[i + 1] = key[i + 1];
; 632  :                 i += 2;
; 633  :             }
; 634  : 
; 635  :             while ( i < round_keys_size ) {
; 636  :                 temp[0] = round_keys[i - 4];
; 637  :                 temp[1] = round_keys[i - 4 + 1];
; 638  :                 temp[2] = round_keys[i - 4 + 2];
; 639  :                 temp[3] = round_keys[i - 4 + 3];
; 640  : 
; 641  :                 if ( i / 4 % Nk == 0 ) {
; 642  :                     rot_dword(temp);
; 643  :                     sub_dword(temp);
; 644  :                     rcon_n(rcon, i / ( Nk * 4 ));
; 645  :                     xor_dword(temp, rcon, temp);
; 646  :                 }
; 647  :                 else if ( Nk > 6 && i / 4 % Nk == 4 ) {
; 648  :                     sub_dword(temp);
; 649  :                 }
; 650  : 
; 651  :                 round_keys[i + 0] = round_keys[i - 4 * Nk] ^ temp[0];
; 652  :                 round_keys[i + 1] = round_keys[i + 1 - 4 * Nk] ^ temp[1];
; 653  :                 round_keys[i + 2] = round_keys[i + 2 - 4 * Nk] ^ temp[2];
; 654  :                 round_keys[i + 3] = round_keys[i + 3 - 4 * Nk] ^ temp[3];
; 655  : 
; 656  :                 i += 4;
; 657  :             }
; 658  : #else
; 659  :             // key expansion
; 660  :             unsigned char temp[4];
; 661  :             unsigned char rcon[4];
; 662  : 
; 663  :             size_t i = 0;
; 664  : 
; 665  :             while ( i < Nk * 4 ) {
; 666  :                 round_keys[i] = key[i];
; 667  :                 round_keys[i + 1] = key[i + 1];
; 668  :                 i += 2;
; 669  :             }
; 670  : 
; 671  :             while ( i < round_keys_size ) {
; 672  :                 temp[0] = round_keys[i - 4];
; 673  :                 temp[1] = round_keys[i - 4 + 1];
; 674  :                 temp[2] = round_keys[i - 4 + 2];
; 675  :                 temp[3] = round_keys[i - 4 + 3];
; 676  : 
; 677  :                 if ( i / 4 % Nk == 0 ) {
; 678  :                     rot_dword(temp);
; 679  :                     sub_dword(temp);
; 680  :                     rcon_n(rcon, i / ( Nk * 4 ));
; 681  :                     xor_dword(temp, rcon, temp);
; 682  :                 }
; 683  :                 else if ( Nk > 6 && i / 4 % Nk == 4 ) {
; 684  :                     sub_dword(temp);
; 685  :                 }
; 686  : 
; 687  :                 round_keys[i + 0] = round_keys[i - 4 * Nk] ^ temp[0];
; 688  :                 round_keys[i + 1] = round_keys[i + 1 - 4 * Nk] ^ temp[1];
; 689  :                 round_keys[i + 2] = round_keys[i + 2 - 4 * Nk] ^ temp[2];
; 690  :                 round_keys[i + 3] = round_keys[i + 3 - 4 * Nk] ^ temp[3];
; 691  : 
; 692  :                 i += 4;
; 693  :             }
; 694  : #endif
; 695  :         }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$Aes@$0BAA@@Cipher@@QEAA@QEAE@Z ENDP		; Cipher::Aes<256>::Aes<256>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1799 :         auto& _My_data = _Mypair._Myval2;
; 1800 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rax, rdx

; 1801 :     }

	ret	0
?begin@?$vector@EV?$allocator@E@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::data, COMDAT

; 1791 :         return _STD _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx]

; 1792 :     }

	ret	0
?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT

; 1584 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN40:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1551 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1584 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rbx, rdx

; 1551 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]

; 1584 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rdi, rcx

; 1551 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, rsi
	sub	rcx, rdx

; 1552 :         if (_Newsize < _Oldsize) { // trim

	cmp	rbx, rcx
	jae	SHORT $LN4@resize

; 1553 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rbx]

; 1554 :             _Orphan_range(_Newlast, _Mylast);
; 1555 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1556 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1557 :             _Mylast = _Newlast;
; 1558 :             return;

	jmp	SHORT $LN37@resize
$LN4@resize:

; 1559 :         }
; 1560 : 
; 1561 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1562 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rdx

; 1563 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rbx, rax
	jbe	SHORT $LN6@resize

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rbx
	mov	rcx, rdi

; 1587 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1565 :                 return;
; 1566 :             }
; 1567 : 
; 1568 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1569 :             const pointer _Oldlast = _Mylast;
; 1570 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1571 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1572 :             } else {
; 1573 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1574 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	mov	rcx, rsi
	call	memset

; 2014 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
$LN37@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1587 :     }

	mov	QWORD PTR [rdi+8], rax
$LN5@resize:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back, COMDAT

; 866  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	r8, rdx

; 775  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;
; 800  :         ++_Mylast;

	inc	QWORD PTR [rcx+8]

; 867  :         _Emplace_one_at_back(_Val);
; 868  :     }

	ret	0
$LN4@push_back:

; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 760  :     _CONSTEXPR20 ~vector() noexcept {

$LN35:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN5@vector

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@vector

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@vector

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@vector:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN5@vector:

; 766  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN32@vector:
??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 695  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 696  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 697  :     }

	mov	rax, rcx

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 695  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 696  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 697  :     }

	ret	0
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 602  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 603  :     }

	mov	rax, rcx
	ret	0
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT

; 4279 :         return _Mypair._Myval2._Mysize == 0;

	cmp	QWORD PTR [rcx+16], 0
	sete	al

; 4280 :     }

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN11@c_str

; 4149 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 4150 :     }

	ret	0
$LN11@c_str:

; 4149 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 4150 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rdx, rcx

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN5@Unchecked_

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rcx]
$LN5@Unchecked_:

; 3987 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]
	add	rax, rdx

; 3988 :     }

	ret	0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN11@Unchecked_

; 3979 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3980 :     }

	ret	0
$LN11@Unchecked_:

; 3979 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 3980 :     }

	ret	0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN123:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	r14, rdx

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rbx, rcx

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdx+16]

; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN17@basic_stri

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdx]
$LN17@basic_stri:

; 2672 :         if (_Count > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rdi
	ja	$LN120@basic_stri

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	rsi, 15
	ja	SHORT $LN25@basic_stri

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rsi

; 2510 :     }

	mov	rax, rbx

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0

; 2510 :     }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN25@basic_stri:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rcx, rsi
	or	rcx, 15
	cmp	rcx, rdi

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN35@basic_stri

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN66@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN65@basic_stri

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN52@basic_stri
$LN35@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	edx, 22
	mov	rdi, rcx
	cmp	rcx, rdx
	cmovb	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rdi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN52@basic_stri

; 197  :         return nullptr;
; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN55@basic_stri

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN121@basic_stri
	jmp	SHORT $LN66@basic_stri
$LN55@basic_stri:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN52@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]
	mov	QWORD PTR [rbx], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2510 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN65@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN121@basic_stri:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN120@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN118@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 47   :         this->_Adopt(_Pvector);
; 48   :     }

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAA@PEAEPEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<7,9210896640802642925,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -19
	xor	BYTE PTR [rcx+1], 91			; 0000005bH
	xor	BYTE PTR [rcx+2], -31
	xor	BYTE PTR [rcx+3], -127			; ffffffffffffff81H
	xor	BYTE PTR [rcx+4], -79			; ffffffffffffffb1H
	xor	BYTE PTR [rcx+5], -83			; ffffffffffffffadH
	xor	BYTE PTR [rcx+6], -45			; ffffffffffffffd3H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$06$0HPNDKNLBIBOBFLON@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<7,9210896640802642925,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$06$0HPNDKNLBIBOBFLON@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$06$0HPNDKNLBIBOBFLON@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<7,9210896640802642925,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$06$0HPNDKNLBIBOBFLON@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<7,9210896640802642925,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<8,-8716755408375925265,char>::decrypt, COMDAT

; 146  : 		{

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+8], 0
	mov	rbx, rcx
	je	SHORT $LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 8
	mov	r8, -8716755408375925265		; 8707dd23b1c9b5efH
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+8], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decrypt@?$obfuscated_data@$07$0?HIPICCNMEODGEKBB@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<8,-8716755408375925265,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<8,-8716755408375925265,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$07$0?HIPICCNMEODGEKBB@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<8,-8716755408375925265,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,9007561748555066333,char>::decrypt, COMDAT

; 146  : 		{

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rbx, rcx
	je	SHORT $LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 11
	mov	r8, 9007561748555066333			; 7d0149afab056bddH
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decrypt@?$obfuscated_data@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,9007561748555066333,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,9007561748555066333,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0HNABEJKPKLAFGLNN@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,9007561748555066333,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<5,-3929642162503730297,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -121			; ffffffffffffff87H
	xor	BYTE PTR [rcx+1], 59			; 0000003bH
	xor	BYTE PTR [rcx+2], -111			; ffffffffffffff91H
	xor	BYTE PTR [rcx+3], -7
	xor	BYTE PTR [rcx+4], 69			; 00000045H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<5,-3929642162503730297,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<5,-3929642162503730297,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$04$0?DGIIOELKAGGOMEHJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<5,-3929642162503730297,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<9,-4071404544105560167,char>::decrypt, COMDAT

; 146  : 		{

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+9], 0
	mov	rbx, rcx
	je	SHORT $LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 9
	mov	r8, -4071404544105560167		; c77f77236bad4799H
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+9], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decrypt@?$obfuscated_data@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<9,-4071404544105560167,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<9,-4071404544105560167,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$08$0?DIIAIINMJEFCLIGH@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<9,-4071404544105560167,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<7,-7558938099074472137,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 55			; 00000037H
	xor	BYTE PTR [rcx+1], -25
	xor	BYTE PTR [rcx+2], 127			; 0000007fH
	xor	BYTE PTR [rcx+3], 13
	xor	BYTE PTR [rcx+4], -39			; ffffffffffffffd9H
	xor	BYTE PTR [rcx+5], 65			; 00000041H
	xor	BYTE PTR [rcx+6], 25

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<7,-7558938099074472137,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<7,-7558938099074472137,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$06$0?GIOGLOCGPCIABIMJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<7,-7558938099074472137,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<5,4171390554486297459,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 115			; 00000073H
	xor	BYTE PTR [rcx+1], 83			; 00000053H
	xor	BYTE PTR [rcx+2], -109			; ffffffffffffff93H
	xor	BYTE PTR [rcx+3], -69			; ffffffffffffffbbH
	xor	BYTE PTR [rcx+4], -101			; ffffffffffffff9bH

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$04$0DJODMBJLLLJDFDHD@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<5,4171390554486297459,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<5,4171390554486297459,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$04$0DJODMBJLLLJDFDHD@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<5,4171390554486297459,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<7,-7217698246706230297,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+7], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], -25
	xor	BYTE PTR [rcx+1], -117			; ffffffffffffff8bH
	xor	BYTE PTR [rcx+2], 29
	xor	BYTE PTR [rcx+3], -123			; ffffffffffffff85H
	xor	BYTE PTR [rcx+4], -81			; ffffffffffffffafH
	xor	BYTE PTR [rcx+5], -107			; ffffffffffffff95H
	xor	BYTE PTR [rcx+6], -43			; ffffffffffffffd5H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+7], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<7,-7217698246706230297,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<7,-7217698246706230297,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$06$0?GECKGKFAHKOCHEBJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<7,-7217698246706230297,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<12,-17003346941488231,char>::decrypt, COMDAT

; 146  : 		{

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+12], 0
	mov	rbx, rcx
	je	SHORT $LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 12
	mov	r8, -17003346941488231			; ffc3978bc98f5399H
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+12], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decrypt@?$obfuscated_data@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<12,-17003346941488231,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<12,-17003346941488231,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0M@$0?DMGIHEDGHAKMGH@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<12,-17003346941488231,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<5,-769018879138130635,char>::decrypt, COMDAT

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+5], 0
	je	SHORT $LN2@decrypt

; 70   : 			data[i] ^= CHAR_TYPE(( key >> ( ( i % 8 ) * 8 ) ) & 0xFF);

	xor	BYTE PTR [rcx], 53			; 00000035H
	xor	BYTE PTR [rcx+1], 21
	xor	BYTE PTR [rcx+2], 103			; 00000067H
	xor	BYTE PTR [rcx+3], 99			; 00000063H
	xor	BYTE PTR [rcx+4], 103			; 00000067H

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);
; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rcx+5], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	ret	0
?decrypt@?$obfuscated_data@$04$0?KKMBKJIJMJIOKML@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<5,-769018879138130635,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<5,-769018879138130635,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$04$0?KKMBKJIJMJIOKML@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<5,-769018879138130635,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,-1502061074894816457,char>::decrypt, COMDAT

; 146  : 		{

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rbx, rcx
	je	SHORT $LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 11
	mov	r8, -1502061074894816457		; eb279b691ff3fb37H
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decrypt@?$obfuscated_data@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,-1502061074894816457,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,-1502061074894816457,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0?BENIGEJGOAAMAEMJ@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,-1502061074894816457,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<11,-4962681195322312931,char>::decrypt, COMDAT

; 146  : 		{

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+11], 0
	mov	rbx, rcx
	je	SHORT $LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 11
	mov	r8, -4962681195322312931		; bb2103bf0b4d771dH
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+11], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decrypt@?$obfuscated_data@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<11,-4962681195322312931,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<11,-4962681195322312931,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0L@$0?EENOPMEAPELCIIOD@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<11,-4962681195322312931,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ PROC ; ay::obfuscated_data<13,-8505844796237434571,char>::decrypt, COMDAT

; 146  : 		{

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 147  : 			if ( m_encrypted )

	cmp	BYTE PTR [rcx+13], 0
	mov	rbx, rcx
	je	SHORT $LN2@decrypt

; 148  : 			{
; 149  : 				cipher(m_data, N, KEY);

	mov	edx, 13
	mov	r8, -8505844796237434571		; 89f52b3945a9b135H
	call	??$cipher@D@ay@@YAXPEAD_K1@Z		; ay::cipher<char>

; 150  : 				m_encrypted = false;

	mov	BYTE PTR [rbx+13], 0
$LN2@decrypt:

; 151  : 			}
; 152  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decrypt@?$obfuscated_data@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEAAXXZ ENDP ; ay::obfuscated_data<13,-8505844796237434571,char>::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\obfuscate.h
;	COMDAT ?data@?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEBAPEBDXZ PROC ; ay::obfuscator<13,-8505844796237434571,char>::data, COMDAT

; 95   : 			return &m_data[0];

	mov	rax, rcx

; 96   : 		}

	ret	0
?data@?$obfuscator@$0N@$0?HGAKNEMGLKFGEOML@D@ay@@QEBAPEBDXZ ENDP ; ay::obfuscator<13,-8505844796237434571,char>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z
_TEXT	SEGMENT
this$dead$ = 8
user_key$ = 16
key$ = 24
?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z PROC ; Cipher::Aes<256>::AES_256_Key_Expansion, COMDAT

; 218  :             __m128i tmp1, tmp2, tmp3;
; 219  :             __m128i* key_sched = ( __m128i* ) key;
; 220  :             tmp1 = _mm_loadu_si128(( __m128i* ) user_key);
; 221  :             tmp3 = _mm_loadu_si128(( __m128i* ) ( user_key + 16 ));

	movdqu	xmm3, XMMWORD PTR [rdx+16]
	movdqu	xmm0, XMMWORD PTR [rdx]

; 223  :             key_sched[1] = tmp3;

	movdqu	XMMWORD PTR [r8+16], xmm3

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm2, xmm0

; 222  :             key_sched[0] = tmp1;

	movdqu	XMMWORD PTR [r8], xmm0

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	pslldq	xmm2, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm1, xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm2, 4
	xorps	xmm1, xmm0

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm4, xmm2
	xorps	xmm4, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm2, 4

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm4, xmm2

; 224  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x01);

	aeskeygenassist xmm0, xmm3, 1

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm4, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm3
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 225  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 226  :             key_sched[2] = tmp1;

	movdqu	XMMWORD PTR [r8+32], xmm4

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm4, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm4
	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 227  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 228  :             key_sched[3] = tmp3;

	movdqu	XMMWORD PTR [r8+48], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm4

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm3, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm3, xmm1

; 229  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x02);

	aeskeygenassist xmm0, xmm2, 2

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm3, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 230  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 231  :             key_sched[4] = tmp1;

	movdqu	XMMWORD PTR [r8+64], xmm3

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm0, xmm2

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm3, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm3
	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 232  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 233  :             key_sched[5] = tmp3;

	movdqu	XMMWORD PTR [r8+80], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm3, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm3, xmm1

; 234  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x04);

	aeskeygenassist xmm0, xmm2, 4

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm3, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 235  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 236  :             key_sched[6] = tmp1;

	movdqu	XMMWORD PTR [r8+96], xmm3

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm0, xmm2

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm3, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm3

; 237  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 238  :             key_sched[7] = tmp3;

	movdqu	XMMWORD PTR [r8+112], xmm2

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm3, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm3, xmm1

; 239  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x08);

	aeskeygenassist xmm0, xmm2, 8

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm3, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 240  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 241  :             key_sched[8] = tmp1;

	movdqu	XMMWORD PTR [r8+128], xmm3

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm2

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm3, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm3
	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 242  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 243  :             key_sched[9] = tmp3;

	movdqu	XMMWORD PTR [r8+144], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm3, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm3, xmm1

; 244  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x10);

	aeskeygenassist xmm0, xmm2, 16

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm3, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 245  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 246  :             key_sched[10] = tmp1;

	movdqu	XMMWORD PTR [r8+160], xmm3

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm2

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm2, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm2, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm1
	aeskeygenassist xmm0, xmm3, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm3
	pslldq	xmm1, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 247  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 248  :             key_sched[11] = tmp3;

	movdqu	XMMWORD PTR [r8+176], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm3

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm4, xmm1

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm4, xmm0

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm4, xmm1

; 249  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x20);

	aeskeygenassist xmm0, xmm2, 32			; 00000020H

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm4, xmm1

; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqa	xmm1, xmm2
	pslldq	xmm1, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm0, xmm1

; 250  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 251  :             key_sched[12] = tmp1;

	movdqu	XMMWORD PTR [r8+192], xmm4

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm0, xmm2

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	movdqa	xmm3, xmm1

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4
	xorps	xmm3, xmm0

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm3, xmm1
	aeskeygenassist xmm0, xmm4, 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm3, xmm1

; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqa	xmm1, xmm4
	pslldq	xmm1, 4

; 252  :             KEY_256_ASSIST_2(&tmp1, &tmp3);
; 253  :             key_sched[13] = tmp3;

	movdqu	XMMWORD PTR [r8+208], xmm3

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm0, xmm1

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	movdqa	xmm2, xmm1
	xorps	xmm0, xmm4
	xorps	xmm2, xmm0

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm1, 4

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm2, xmm1

; 254  :             tmp2 = _mm_aeskeygenassist_si128(tmp3, 0x40);

	aeskeygenassist xmm0, xmm3, 64			; 00000040H

; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);

	pshufd	xmm1, xmm0, 255				; 000000ffH

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm2, xmm1

; 255  :             KEY_256_ASSIST_1(&tmp1, &tmp2);
; 256  :             key_sched[14] = tmp1;

	movdqu	XMMWORD PTR [r8+224], xmm2

; 257  :         }

	ret	0
?AES_256_Key_Expansion@?$Aes@$0BAA@@Cipher@@AEAAXPEBEPEAE@Z ENDP ; Cipher::Aes<256>::AES_256_Key_Expansion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT

; 2039 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2040 :         auto& _Al         = _Getal();
; 2041 :         auto& _My_data    = _Mypair._Myval2;
; 2042 :         pointer& _Myfirst = _My_data._Myfirst;
; 2043 :         pointer& _Mylast  = _My_data._Mylast;
; 2044 :         pointer& _Myend   = _My_data._Myend;
; 2045 : 
; 2046 :         _My_data._Orphan_all();
; 2047 : 
; 2048 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2049 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2050 :             _ASAN_VECTOR_REMOVE;
; 2051 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN21@Tidy

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN18@Tidy

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN21@Tidy:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2053 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2054 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2055 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2057 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN28@Tidy:
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2235 :         const value_type* _Result = _Bx._Buf;
; 2236 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@Myptr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2241 :     }

	ret	0
$LN8@Myptr:

; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

	mov	rax, rcx

; 2241 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15

; 2226 :         value_type* _Result = _Bx._Buf;
; 2227 :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@Myptr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2232 :     }

	ret	0
$LN8@Myptr:

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, rcx

; 2232 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 718  :         return _Al;

	mov	rax, rcx

; 719  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?KEY_256_ASSIST_2@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
tmp1$ = 16
tmp3$ = 24
?KEY_256_ASSIST_2@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z PROC ; Cipher::Aes<256>::KEY_256_ASSIST_2, COMDAT

; 205  :             __m128i tmp2, tmp4;
; 206  :             tmp4 = _mm_aeskeygenassist_si128(*tmp1, 0x0);
; 207  :             tmp2 = _mm_shuffle_epi32(tmp4, 0xaa);
; 208  :             tmp4 = _mm_slli_si128(*tmp3, 0x4);

	movdqu	xmm2, XMMWORD PTR [r8]
	movdqa	xmm0, xmm2
	pslldq	xmm0, 4

; 209  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm0

; 210  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm0, 4

; 211  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm0

; 212  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm0, 4

; 213  :             *tmp3 = _mm_xor_si128(*tmp3, tmp4);

	xorps	xmm2, xmm0
	aeskeygenassist xmm0, XMMWORD PTR [rdx], 0
	pshufd	xmm1, xmm0, 170				; 000000aaH

; 214  :             *tmp3 = _mm_xor_si128(*tmp3, tmp2);

	xorps	xmm2, xmm1
	movdqu	XMMWORD PTR [r8], xmm2

; 215  :         }

	ret	0
?KEY_256_ASSIST_2@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z ENDP ; Cipher::Aes<256>::KEY_256_ASSIST_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\aes.hpp
;	COMDAT ?KEY_256_ASSIST_1@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
tmp1$ = 16
tmp2$ = 24
?KEY_256_ASSIST_1@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z PROC ; Cipher::Aes<256>::KEY_256_ASSIST_1, COMDAT

; 193  :             __m128i tmp4;
; 194  :             *tmp2 = _mm_shuffle_epi32(*tmp2, 0xff);
; 195  :             tmp4 = _mm_slli_si128(*tmp1, 0x4);

	movdqu	xmm1, XMMWORD PTR [rdx]
	pshufd	xmm2, XMMWORD PTR [r8], 255		; 000000ffH
	movdqa	xmm0, xmm1
	pslldq	xmm0, 4

; 196  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm1, xmm0
	movdqu	XMMWORD PTR [r8], xmm2

; 197  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm0, 4

; 198  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm1, xmm0

; 199  :             tmp4 = _mm_slli_si128(tmp4, 0x4);

	pslldq	xmm0, 4

; 200  :             *tmp1 = _mm_xor_si128(*tmp1, tmp4);

	xorps	xmm1, xmm0

; 201  :             *tmp1 = _mm_xor_si128(*tmp1, *tmp2);

	xorps	xmm1, xmm2
	movdqu	XMMWORD PTR [rdx], xmm1

; 202  :         }

	ret	0
?KEY_256_ASSIST_1@?$Aes@$0BAA@@Cipher@@AEAAXPEAT__m128i@@0@Z ENDP ; Cipher::Aes<256>::KEY_256_ASSIST_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z PROC	; std::allocator<unsigned char>::deallocate, COMDAT

; 947  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 948  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 949  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 951  :     }

	add	rsp, 40					; 00000028H

; 258  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ENDP	; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1278 :     // check that [_First, _Last) forms an iterator range
; 1279 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1280 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1281 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1282 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1283 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1284 :         _Verify_range(_First, _Last);
; 1285 :     }
; 1286 : }

	ret	0
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6APEAUHINSTANCE__@@PEBD@Z@ProcessUtilities@@YAP6APEAUHINSTANCE__@@PEBD@ZPEAU1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<HINSTANCE__ * (__cdecl*)(char const *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHGPEAUWSAData@@@Z@ProcessUtilities@@YAP6AHGPEAUWSAData@@@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned short,WSAData *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,sockaddr const *,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_K@Z@ProcessUtilities@@YAP6AH_K@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6A_KHHH@Z@ProcessUtilities@@YAP6A_KHHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<unsigned __int64 (__cdecl*)(int,int,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHH@Z@ProcessUtilities@@YAP6AH_KPEADHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHHPEBUsockaddr@@H@Z@ProcessUtilities@@YAP6AH_KPEBDHHPEBUsockaddr@@H@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int,sockaddr const *,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEADHHPEAUsockaddr@@PEAH@Z@ProcessUtilities@@YAP6AH_KPEADHHPEAUsockaddr@@PEAH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char *,int,int,sockaddr *,int *)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KPEBDHH@Z@ProcessUtilities@@YAP6AH_KPEBDHH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,char const *,int,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AHXZ@ProcessUtilities@@YAP6AHXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(void)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h
;	COMDAT ??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,int)>, COMDAT

; 69   : 	fpType GetFunctionAddress(HMODULE lib, std::string proc) {

$LN46:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR proc$GSCopy$[rsp], rdx

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rax
	mov	rcx, rbx
	call	?_GetFuncAddress@ProcessUtilities@@YAP6A_JXZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ProcessUtilities::_GetFuncAddress
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, 15

; 4868 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@GetFunctio

; 2643 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 950  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@GetFunctio

; 171  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@GetFunctio

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@GetFunctio:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 4875 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4876 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 4877 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4878 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Users\ethan\source\repos\DLL\DLL\Headers\procutils.h

; 70   : 		return reinterpret_cast< fpType >( _GetFuncAddress(lib, proc) );

	mov	rax, rbx

; 71   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN33@GetFunctio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN43@GetFunctio:
??$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
proc$GSCopy$ = 72
__$ArrayPad$ = 80
lib$ = 112
proc$ = 120
?dtor$0@?0???$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,int)>'::`1'::dtor$0
	mov	rcx, QWORD PTR proc$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$GetFunctionAddress@P6AH_KH@Z@ProcessUtilities@@YAP6AH_KH@ZPEAUHINSTANCE__@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `ProcessUtilities::GetFunctionAddress<int (__cdecl*)(unsigned __int64,int)>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_First$ = 72
_Last$ = 80
_Dest$ = 88
??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z PROC ; std::copy<char *,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >, COMDAT

; 4719 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

$LN20:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rcx

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rsi, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	mov	r8, rsi

; 4719 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

	mov	rbx, r9

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rcx, QWORD PTR [rsi+rbx]

; 4720 :     _STD _Adl_verify_range(_First, _Last);
; 4721 :     const auto _UFirst = _STD _Get_unwrapped(_First);
; 4722 :     const auto _ULast  = _STD _Get_unwrapped(_Last);
; 4723 :     const auto _UDest  = _STD _Get_unwrapped_n(_Dest, _STD _Idl_distance<_InIt>(_UFirst, _ULast));
; 4724 :     _STD _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));
; 4725 :     return _Dest;

	mov	rax, rdi
	mov	QWORD PTR [rdi], rcx

; 4726 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$copy@PEADV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@PEAD0V10@@Z ENDP ; std::copy<char *,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z PROC	; std::_Get_unwrapped<char * &>, COMDAT

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	ret	0
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ENDP	; std::_Get_unwrapped<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Idl_distance@PEADPEAD@std@@YA?A_PAEBQEAD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEADPEAD@std@@YA?A_PAEBQEAD0@Z PROC	; std::_Idl_distance<char *,char *>, COMDAT

; 1466 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1467 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1468 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]

; 1469 :     } else {
; 1470 :         return _Distance_unknown{};
; 1471 :     }
; 1472 : }

	ret	0
??$_Idl_distance@PEADPEAD@std@@YA?A_PAEBQEAD0@Z ENDP	; std::_Idl_distance<char *,char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z
_TEXT	SEGMENT
_It$ = 8
_Off$dead$ = 16
??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z PROC ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &,__int64>, COMDAT

; 1371 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1372 :         return _It + 0;
; 1373 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1374 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1375 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1376 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1377 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1378 : 
; 1379 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1380 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1381 :             "integer overflow");
; 1382 :         (void) _COff;
; 1383 : 
; 1384 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1385 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1386 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1387 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1388 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1389 :     } else {
; 1390 :         // pass through iterator that doesn't participate in checking
; 1391 :         return static_cast<_Iter&&>(_It);
; 1392 :     }
; 1393 : }

	ret	0
??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z ENDP ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@E@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z PROC		; std::_Unfancy_maybe_null<unsigned char>, COMDAT

; 47   :     return _Ptr;

	mov	rax, rcx

; 48   : }

	ret	0
??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z ENDP		; std::_Unfancy_maybe_null<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>, COMDAT

; 1545 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1546 :         // trim or append elements, provide strong guarantee
; 1547 :         auto& _Al           = _Getal();
; 1548 :         auto& _My_data      = _Mypair._Myval2;
; 1549 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1550 :         pointer& _Mylast    = _My_data._Mylast;
; 1551 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rbx, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rdi, rcx
	mov	rcx, rsi
	sub	rcx, rdx

; 1552 :         if (_Newsize < _Oldsize) { // trim

	cmp	rbx, rcx
	jae	SHORT $LN2@Resize

; 1553 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rbx]

; 1554 :             _Orphan_range(_Newlast, _Mylast);
; 1555 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1556 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1557 :             _Mylast = _Newlast;
; 1558 :             return;

	jmp	SHORT $LN35@Resize
$LN2@Resize:

; 1559 :         }
; 1560 : 
; 1561 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1562 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rdx

; 1563 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rbx, rax
	jbe	SHORT $LN4@Resize

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rbx
	mov	rcx, rdi

; 1581 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1564 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1565 :                 return;
; 1566 :             }
; 1567 : 
; 1568 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1569 :             const pointer _Oldlast = _Mylast;
; 1570 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1571 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1572 :             } else {
; 1573 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1574 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	mov	rcx, rsi
	call	memset

; 2014 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
$LN35@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1581 :     }

	mov	QWORD PTR [rdi+8], rax
$LN3@Resize:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>, COMDAT

; 770  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	r8, rdx

; 771  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 772  :         auto& _My_data   = _Mypair._Myval2;
; 773  :         pointer& _Mylast = _My_data._Mylast;
; 774  : 
; 775  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 800  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rcx+8], rdx

; 780  :     }

	ret	0
$LN2@Emplace_on:

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z PROC ; std::move<std::allocator<unsigned char> &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ENDP ; std::move<std::allocator<unsigned char> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
;	COMDAT ??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z PROC	; std::exchange<unsigned char *,std::nullptr_t>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ENDP	; std::exchange<unsigned char *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>, COMDAT

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1496 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
_Val1$ = 24
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1501 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
this$ = 64
_Arg$ = 72
_Count$ = 80
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 2662 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN99:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2663 :         auto& _My_data = _Mypair._Myval2;
; 2664 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2665 : 
; 2666 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2667 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2668 :         } else {
; 2669 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2670 :         }
; 2671 : 
; 2672 :         if (_Count > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rsi, r8
	mov	rbp, rdx
	mov	rdi, rcx
	cmp	r8, rbx
	ja	$LN96@Construct

; 2674 :         }
; 2675 : 
; 2676 :         auto& _Al       = _Getal();
; 2677 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2678 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2679 : 
; 2680 :         if (_Count <= _Small_string_capacity) {

	cmp	r8, 15
	ja	SHORT $LN3@Construct

; 2681 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 2682 :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 4763 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rsi
	or	rax, 15
	cmp	rax, rbx

; 4764 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN13@Construct

; 4765 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN44@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN43@Construct

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN30@Construct
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\utility

; 74   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbx, rax
	cmp	rax, rcx
	cmovb	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2616 :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN31@Construct

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN30@Construct
$LN31@Construct:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN33@Construct

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN97@Construct
	jmp	SHORT $LN44@Construct
$LN33@Construct:

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN30@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2715 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]
	mov	QWORD PTR [rdi], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbp

; 2683 : 
; 2684 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2685 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2688 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2689 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2690 :             } else { // _Strat == _Construct_strategy::_From_string
; 2691 : #ifdef _INSERT_STRING_ANNOTATION
; 2692 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2693 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2694 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2695 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2696 :             }
; 2697 : 
; 2698 :             _Proxy._Release();
; 2699 :             return;
; 2700 :         }
; 2701 : 
; 2702 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());
; 2703 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 2704 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 2705 : 
; 2706 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rdi+16], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2707 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx

; 2716 :         }
; 2717 : 
; 2718 :         _ASAN_STRING_CREATE(*this);
; 2719 :         _Proxy._Release();
; 2720 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
$LN43@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN97@Construct:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN96@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xstring

; 2673 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN94@Construct:
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 1064 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1065 :     using _Ty = typename _Alloc::value_type;
; 1066 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1067 :         for (; _First != _Last; ++_First) {
; 1068 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1069 :         }
; 1070 :     }
; 1071 : }

	ret	0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped, COMDAT

; 345  :         return _STD _Unfancy_maybe_null(this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 346  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAPEAEXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z
_TEXT	SEGMENT
this$dead$ = 8
_Off$dead$ = 16
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset, COMDAT

; 111  : #if _ITERATOR_DEBUG_LEVEL == 0
; 112  :         (void) _Off;
; 113  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 114  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 115  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 116  :         _STL_VERIFY(_Off == 0 || _Mycont, "cannot seek invalidated vector iterator");
; 117  :         if (_Off < 0) {
; 118  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 119  :         }
; 120  : 
; 121  :         if (_Off > 0) {
; 122  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 123  :         }
; 124  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
; 125  :     }

	ret	0
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT

; 2181 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@E@std@@QEAA@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT

; 939  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@E@std@@QEAA@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z PROC ; std::_Copy_unchecked<char *,char *,unsigned char *>, COMDAT

; 4688 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4689 :     // copy [_First, _Last) to [_Dest, ...)
; 4690 :     // note: _Copy_unchecked has callers other than the copy family
; 4691 :     if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
; 4692 :         return _STD _Copy_vbool(_First, _Last, _Dest);
; 4693 :     } else {
; 4694 :         if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {
; 4695 : #if _HAS_CXX20
; 4696 :             if (!_STD is_constant_evaluated())
; 4697 : #endif // _HAS_CXX20
; 4698 :             {
; 4699 : #if _HAS_CXX20
; 4700 :                 if constexpr (!is_same_v<_InIt, _Sent>) {
; 4701 :                     return _STD _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
; 4702 :                 } else
; 4703 : #endif // _HAS_CXX20
; 4704 :                 {
; 4705 :                     return _STD _Copy_memmove(_First, _Last, _Dest);
; 4706 :                 }
; 4707 :             }
; 4708 :         }
; 4709 : 
; 4710 :         for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4711 :             *_Dest = *_First;
; 4712 :         }
; 4713 : 
; 4714 :         return _Dest;
; 4715 :     }
; 4716 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_unchecked@PEADPEADPEAE@std@@YAPEAEPEAD0PEAE@Z ENDP ; std::_Copy_unchecked<char *,char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>, COMDAT

; 1405 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1406 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1407 :     } else {
; 1408 :         _It = _STD forward<_UIter>(_UIt);
; 1409 :     }
; 1410 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 80
_Newsize$ = 88
_Val$dead$ = 96
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1505 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN108:
	push	rbx
	push	rbp
	push	r14
	sub	rsp, 48					; 00000030H

; 1506 :         if (_Newsize > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rbp, rdx
	mov	r14, rcx
	cmp	rdx, rbx
	ja	$LN105@Resize_rea
	mov	QWORD PTR [rsp+96], rsi

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], r15

; 1508 :         }
; 1509 : 
; 1510 :         auto& _Al         = _Getal();
; 1511 :         auto& _My_data    = _Mypair._Myval2;
; 1512 :         pointer& _Myfirst = _My_data._Myfirst;
; 1513 :         pointer& _Mylast  = _My_data._Mylast;
; 1514 : 
; 1515 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r15, QWORD PTR [rcx+8]
	sub	r15, QWORD PTR [rcx]

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [r14]

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN10@Resize_rea

; 1971 :             return _Max; // geometric growth would overflow

	mov	rcx, -9223372036854775770		; 8000000000000026H
$LN34@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN33@Resize_rea

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN20@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1975 : 
; 1976 :         if (_Geometric < _Newsize) {

	cmp	rbx, rbp
	cmovb	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	test	rbx, rbx
	jne	SHORT $LN21@Resize_rea

; 197  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN20@Resize_rea
$LN21@Resize_rea:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN23@Resize_rea

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN106@Resize_rea
	jmp	SHORT $LN34@Resize_rea
$LN23@Resize_rea:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN20@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1527 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r8, rbp
	lea	rcx, QWORD PTR [rdi+r15]
	sub	r8, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1531 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1910 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1541 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rbp
	mov	rdx, rdi
	mov	rcx, r14
	mov	rdi, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+32]

; 1542 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rbp
	pop	rbx

; 1541 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
$LN33@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN106@Resize_rea:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN105@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1507 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN103@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >, COMDAT

; 2004 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN29:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	xor	edx, edx

; 2004 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	mov	rbx, rcx

; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	memset

; 2005 :     // value-initialize _Count objects to raw _First, using _Al
; 2006 :     using _Ptrty = typename _Alloc::value_type*;
; 2007 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2008 : #if _HAS_CXX20
; 2009 :         if (!_STD is_constant_evaluated())
; 2010 : #endif // _HAS_CXX20
; 2011 :         {
; 2012 :             auto _PFirst = _Unfancy(_First);
; 2013 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2014 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]

; 2015 :         }
; 2016 :     }
; 2017 : 
; 2018 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2019 :     for (; 0 < _Count; --_Count) {
; 2020 :         _Backout._Emplace_back();
; 2021 :     }
; 2022 : 
; 2023 :     return _Backout._Release();
; 2024 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@AEBE@std@@YAAEBEAEBE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBE@std@@YAAEBEAEBE@Z PROC			; std::forward<unsigned char const &>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@AEBE@std@@YAAEBEAEBE@Z ENDP			; std::forward<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>, COMDAT

; 784  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 785  :         auto& _My_data   = _Mypair._Myval2;
; 786  :         pointer& _Mylast = _My_data._Mylast;
; 787  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 788  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 789  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 790  :             _ASAN_VECTOR_MODIFY(1);
; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	movzx	eax, BYTE PTR [rdx]
	mov	r8, QWORD PTR [rcx+8]
	mov	BYTE PTR [r8], al

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);
; 799  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 800  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rcx+8], rdx

; 801  : 
; 802  :         return _Result;
; 803  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
_TEXT	SEGMENT
this$ = 96
_Whereptr$ = 104
<_Val_0>$ = 112
??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>, COMDAT

; 806  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN128:
	push	rbp
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 807  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 808  :         _Alty& _Al        = _Getal();
; 809  :         auto& _My_data    = _Mypair._Myval2;
; 810  :         pointer& _Myfirst = _My_data._Myfirst;
; 811  :         pointer& _Mylast  = _My_data._Mylast;
; 812  : 
; 813  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 814  : 
; 815  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 816  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	r15, rbp
	sub	r15, rdx
	sub	rax, rdx

; 817  : 
; 818  :         if (_Oldsize == max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	mov	r13, r8
	mov	r14, rcx
	cmp	rax, rdi
	je	$LN125@Emplace_re

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+40], rsi

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	QWORD PTR [rsp+32], r12

; 820  :         }
; 821  : 
; 822  :         const size_type _Newsize = _Oldsize + 1;

	lea	r12, QWORD PTR [rax+1]

; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rdi
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN12@Emplace_re

; 1971 :             return _Max; // geometric growth would overflow

	mov	rcx, -9223372036854775770		; 8000000000000026H
$LN36@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN35@Emplace_re

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN22@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 196  :     if (_Bytes == 0) {

	mov	rdi, r12
	cmp	rax, r12
	cmovae	rdi, rax
	test	rdi, rdi
	jne	SHORT $LN23@Emplace_re

; 197  :         return nullptr;

	xor	ebx, ebx
	jmp	SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN25@Emplace_re

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN126@Emplace_re
	jmp	SHORT $LN36@Emplace_re
$LN25@Emplace_re:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN22@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 830  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	movzx	ecx, BYTE PTR [r13]
	lea	rsi, QWORD PTR [rbx+r15]
	mov	BYTE PTR [rsi], cl

; 831  :         _Constructed_first = _Newvec + _Whereoff;
; 832  : 
; 833  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [r14+8]
	mov	rdx, QWORD PTR [r14]
	cmp	rbp, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 839  :         } else { // provide basic guarantee

	jmp	SHORT $LN123@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rbp
	sub	r8, rdx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1910 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	rcx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rbp

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbp
$LN123@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	call	memmove

; 843  :         }
; 844  :         _CATCH_ALL
; 845  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 846  :         _Al.deallocate(_Newvec, _Newcapacity);
; 847  :         _RERAISE;
; 848  :         _CATCH_END
; 849  : 
; 850  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rdi
	mov	r8, r12
	mov	rdx, rbx
	mov	rcx, r14
	call	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
	mov	rbx, QWORD PTR [rsp+112]

; 851  :         return _Newvec + _Whereoff;

	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+32]

; 852  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
$LN35@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN126@Emplace_re:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN125@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 819  :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN122@Emplace_re:
??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z PROC ; std::forward<std::allocator<unsigned char> >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ENDP ; std::forward<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z PROC		; std::forward<unsigned char *>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z ENDP		; std::forward<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release, COMDAT

; 1785 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1786 :         return _Last;
; 1787 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1775 :         _STD _Destroy_range(_First, _Last, _Al);
; 1776 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1769 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z
_TEXT	SEGMENT
this$ = 8
_It$ = 16
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to, COMDAT

; 221  :         _Ptr = _STD _Refancy_maybe_null<_Tptr>(const_cast<value_type*>(_It));

	mov	QWORD PTR [rcx], rdx

; 222  :     }

	ret	0
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 2141 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2142 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlength:
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT

; 2017 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2018 :         // orphan all iterators, discard old array, acquire new array
; 2019 :         auto& _Al         = _Getal();
; 2020 :         auto& _My_data    = _Mypair._Myval2;
; 2021 :         pointer& _Myfirst = _My_data._Myfirst;
; 2022 :         pointer& _Mylast  = _My_data._Mylast;
; 2023 :         pointer& _Myend   = _My_data._Myend;
; 2024 : 
; 2025 :         _My_data._Orphan_all();
; 2026 : 
; 2027 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN6@Change_arr

; 2028 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2029 :             _ASAN_VECTOR_REMOVE;
; 2030 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 258  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector

; 2034 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp]
	mov	QWORD PTR [rbx], rdi

; 2037 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi]
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();
; 1968 :         const auto _Max              = max_size();
; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1966 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1967 :         const size_type _Oldcapacity = capacity();
; 1968 :         const auto _Max              = max_size();
; 1969 : 
; 1970 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax
	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1971 :             return _Max; // geometric growth would overflow
; 1972 :         }
; 1973 : 
; 1974 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1975 : 
; 1976 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1977 :             return _Newsize; // geometric growth would be insufficient
; 1978 :         }
; 1979 : 
; 1980 :         return _Geometric; // geometric growth is sufficient
; 1981 :     }

	ret	0
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT

; 1877 :         return (_STD min)(

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1878 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1879 :     }

	ret	0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT

; 2189 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2190 :     }

	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT

; 1882 :         auto& _My_data = _Mypair._Myval2;
; 1883 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]

; 1884 :     }

	ret	0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT

; 1508 :         return *this;

	mov	rax, rcx

; 1509 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z PROC	; std::_Copy_memmove<char *,unsigned char *>, COMDAT

; 4613 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4614 :     auto _FirstPtr              = _STD _To_address(_First);
; 4615 :     auto _LastPtr               = _STD _To_address(_Last);
; 4616 :     auto _DestPtr               = _STD _To_address(_Dest);
; 4617 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4618 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4619 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4624 :     } else {
; 4625 :         return _Dest + (_LastPtr - _FirstPtr);
; 4626 :     }
; 4627 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEADPEAE@std@@YAPEAEPEAD0PEAE@Z ENDP	; std::_Copy_memmove<char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z PROC		; std::_To_address<char *>, COMDAT

; 4482 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4483 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4484 : }

	ret	0
??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z ENDP		; std::_To_address<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z PROC		; std::_To_address<unsigned char *>, COMDAT

; 4482 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4483 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4484 : }

	ret	0
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ENDP		; std::_To_address<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >, COMDAT

; 2177 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN33:
	sub	rsp, 40					; 00000028H

; 2178 : #if _HAS_CXX23
; 2179 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2180 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2181 :         _Count                  = _Allocated;
; 2182 :         return _Ptr;
; 2183 :     } else
; 2184 : #endif // _HAS_CXX23
; 2185 :     {
; 2186 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 196  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN6@Allocate_a

; 197  :         return nullptr;

	xor	eax, eax

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Allocate_a:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@Allocate_a

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN32@Allocate_a

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@Allocate_a

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2187 :     }
; 2188 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@Allocate_a:
	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN32@Allocate_a:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN18@Allocate_a:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN30@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@E@std@@@std@@YAPEAEAEAV?$allocator@E@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z PROC	; std::_Get_unwrapped<unsigned char * const &>, COMDAT

; 1305 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1306 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1307 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1308 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1309 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1310 :     } else {
; 1311 :         return static_cast<_Iter&&>(_It);
; 1312 :     }
; 1313 : }

	ret	0
??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z ENDP	; std::_Get_unwrapped<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1905 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN24:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1905 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1918 :             return _Dest + (_ULast - _UFirst);

	sub	rsi, rbx
	lea	rax, QWORD PTR [rdi+rsi]

; 1919 :         }
; 1920 :     }
; 1921 : 
; 1922 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1923 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1924 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1925 :     }
; 1926 : 
; 1927 :     return _Backout._Release();
; 1928 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Unfancy@E@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@E@std@@YAPEAEPEAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT

; 36   :     return _Ptr;

	mov	rax, rcx

; 37   : }

	ret	0
??$_Unfancy@E@std@@YAPEAEPEAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 1995 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1996 :     char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));
; 1997 :     char* const _Last_ch  = reinterpret_cast<char*>(_STD _To_address(_Last));
; 1998 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	mov	rbx, rdx
	sub	r8, rcx
	xor	edx, edx
	call	memset

; 1999 :     return _Last;

	mov	rax, rbx

; 2000 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	BYTE PTR [rax], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 1781 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1782 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z PROC	; std::_Construct_in_place<unsigned char,unsigned char const &>, COMDAT

; 382  : #if _HAS_CXX20
; 383  :     if (_STD is_constant_evaluated()) {
; 384  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 385  :     } else
; 386  : #endif // _HAS_CXX20
; 387  :     {
; 388  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 389  :     }
; 390  : }

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	ret	0
??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z ENDP	; std::_Construct_in_place<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z PROC	; std::_Refancy_maybe_null<unsigned char *,0>, COMDAT

; 282  :     return _Ptr;

	mov	rax, rcx

; 283  : }

	ret	0
??$_Refancy_maybe_null@PEAE$0A@@std@@YAPEAEPEAE@Z ENDP	; std::_Refancy_maybe_null<unsigned char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT

; 953  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 196  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 197  :         return nullptr;

	xor	eax, eax

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@allocate:

; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 154  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN29@allocate

; 101  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@allocate:

; 101  :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 954  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 955  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 956  :     }

	add	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN29@allocate:

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN16@allocate:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	_invalid_parameter_noinfo_noreturn
	int	3
$LN27@allocate:
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$to_address@D@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@D@std@@YAPEADQEAD@Z PROC			; std::to_address<char>, COMDAT

; 453  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 454  :     return _Val;

	mov	rax, rcx

; 455  : }

	ret	0
??$to_address@D@std@@YAPEADQEAD@Z ENDP			; std::to_address<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$to_address@E@std@@YAPEAEQEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@E@std@@YAPEAEQEAE@Z PROC			; std::to_address<unsigned char>, COMDAT

; 453  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 454  :     return _Val;

	mov	rax, rcx

; 455  : }

	ret	0
??$to_address@E@std@@YAPEAEQEAE@Z ENDP			; std::to_address<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$move@AEAE@std@@YA$$QEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAE@std@@YA$$QEAEAEAE@Z PROC			; std::move<unsigned char &>, COMDAT

; 1548 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1549 : }

	ret	0
??$move@AEAE@std@@YA$$QEAEAEAE@Z ENDP			; std::move<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z PROC	; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4613 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4614 :     auto _FirstPtr              = _STD _To_address(_First);
; 4615 :     auto _LastPtr               = _STD _To_address(_Last);
; 4616 :     auto _DestPtr               = _STD _To_address(_Dest);
; 4617 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4618 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4619 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4620 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4621 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4622 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4623 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4624 :     } else {
; 4625 :         return _Dest + (_LastPtr - _FirstPtr);
; 4626 :     }
; 4627 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z ENDP	; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>, COMDAT

; 1780 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 1781 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1782 :     }

	ret	0
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$addressof@E@std@@YAPEAEAEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@E@std@@YAPEAEAEAE@Z PROC			; std::addressof<unsigned char>, COMDAT

; 1560 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1561 : }

	ret	0
??$addressof@E@std@@YAPEAEAEAE@Z ENDP			; std::addressof<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z PROC	; std::construct_at<unsigned char,unsigned char const &,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z ENDP	; std::construct_at<unsigned char,unsigned char const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\type_traits
;	COMDAT ??$forward@E@std@@YA$$QEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@E@std@@YA$$QEAEAEAE@Z PROC			; std::forward<unsigned char>, COMDAT

; 1537 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1538 : }

	ret	0
??$forward@E@std@@YA$$QEAEAEAE@Z ENDP			; std::forward<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory
;	COMDAT ??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xmemory

; 702  :     }

	ret	0
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z PROC		; std::construct_at<unsigned char,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z ENDP		; std::construct_at<unsigned char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\include\xutility
;	COMDAT ??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z PROC	; std::construct_at<unsigned char,unsigned char,0>, COMDAT

; 375  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 376  : }

	ret	0
??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z ENDP	; std::construct_at<unsigned char,unsigned char,0>
_TEXT	ENDS
END
